这个问题问得**非常到位**。
如果说时间复杂度决定「会不会超时」，**空间复杂度决定「会不会爆内存、思路是否优雅」**。
而 JS 又是**最容易被“隐式空间”坑到的语言**。

下面我会用 **规则 → JS 特有点 → 大量真实案例 → 易错点 → 训练方法**，系统讲清楚 **JS 空间复杂度**。

---

# 一、空间复杂度是什么（一句话版）

> **空间复杂度 = 输入规模 n 变大时，额外占用内存的增长趋势**

⚠️ **只算「额外空间」**
❌ 不算输入本身
❌ 不算输出本身（面试/LeetCode 默认）

---

# 二、JS 空间复杂度判断 6 条铁律（必背）

### 1️⃣ 只看“额外”创建的数据结构

```js
let sum = 0;      // O(1)
let arr = [];    // O(n)
let map = new Map(); // O(n)
```

---

### 2️⃣ 原地修改 = O(1)

```js
nums[i] = 0;
swap(nums, i, j);
```

---

### 3️⃣ 递归空间 ≠ 0（调用栈要算）

```js
dfs(n - 1);
```

➡ **O(n)**（最容易被忽略）

---

### 4️⃣ slice / substring / spread 会开新内存

```js
s.slice(...)
[...arr]
```

➡ **O(k)** 新空间

---

### 5️⃣ Map / Set 的空间 = 存多少元素

```js
map.set(key, val);
```

➡ **O(n)**

---

### 6️⃣ 常数个变量，永远 O(1)

```js
let l, r, sum, ans;
```

---

# 三、JS 常见空间复杂度模板（大量案例）

---

## ① 常量空间 O(1)

### 示例 1：双指针

```js
let l = 0, r = n - 1;
while (l < r) {
  l++;
  r--;
}
```

✔️ **只用了几个变量 → O(1)**

---

### 示例 2：原地修改数组

```js
for (let i = 0; i < nums.length; i++) {
  nums[i] = nums[i] * 2;
}
```

✔️ **没有新数组 → O(1)**

---

### 典型题

* Two Sum II
* 移除元素
* 反转数组
* 颜色分类（荷兰国旗）

---

## ② 线性空间 O(n)

---

### 示例 3：辅助数组

```js
let res = [];
for (let i = 0; i < n; i++) {
  res.push(nums[i]);
}
```

➡ **O(n)**

---

### 示例 4：Map / Set

```js
const set = new Set();
for (let x of nums) {
  set.add(x);
}
```

➡ **O(n)**

---

### 示例 5：前缀和数组

```js
const pre = new Array(n + 1);
```

➡ **O(n)**

---

### 典型题

* Two Sum（哈希表）
* 前缀和
* 滑动窗口（带 Map）
* 无重复字符的最长子串

---

## ③ 二维空间 O(n²)

---

### 示例 6：DP 表

```js
const dp = Array.from({ length: n }, () =>
  new Array(n).fill(0)
);
```

➡ **O(n²)**

---

### 典型题

* 最长回文子串（DP）
* 编辑距离
* 不同路径（二维 DP）

---

## ④ 递归调用栈（隐形空间）

---

### 示例 7：线性递归

```js
function dfs(n) {
  if (n === 0) return;
  dfs(n - 1);
}
```

➡ **O(n)**（调用栈）

---

### 示例 8：二分递归

```js
dfs(l, r) {
  dfs(l, mid);
}
```

➡ **O(log n)**

---

### 示例 9：回溯

```js
function backtrack(path) {
  if (path.length === n) return;
  for (...) {
    path.push(...);
    backtrack(path);
    path.pop();
  }
}
```

➡ **栈深 O(n)**
➡ **结果集通常 O(n!)**

---

## ⑤ 结果集是否算空间？

### 面试 / LeetCode 规则

> **输出结果一般不计入额外空间**

```js
res.push(path.slice());
```

✔️ `res` 不算
✔️ 但 `path` / `used` 算

---

# 四、结合你做过的题（非常关键）

---

## 1️⃣ Two Sum II

```js
let l = 0, r = n - 1;
```

➡ **空间：O(1)**

---

## 2️⃣ minSubArrayLen

```js
let sum = 0;
```

➡ **空间：O(1)**

---

## 3️⃣ findSubstring

```js
const need = new Map();
const window = new Map();
```

➡ **空间：O(k)**
k = words 中单词种类数

---

## 4️⃣ 三数之和

```js
nums.sort(...)
```

➡ **辅助空间：O(log n)**（排序递归栈）

---

## 5️⃣ 合并 K 个链表（分治）

➡ **递归栈：O(log k)**

---

## 6️⃣ 全排列

```js
used = new Array(n)
```

➡ **O(n)**（栈 + used）

---

# 五、JS 空间复杂度 7 大天坑（必看）

---

### ❌ 1. slice / substring 在循环里

```js
for (...) {
  s.slice(...) // 新字符串！
}
```

➡ **隐式 O(n²)**

---

### ❌ 2. 扩展运算符

```js
newArr = [...oldArr];
```

➡ **O(n)** 新数组

---

### ❌ 3. shift / unshift

```js
arr.shift();
```

➡ **不仅慢，还可能临时复制内存**

---

### ❌ 4. 递归没算栈空间

> 面试最容易被扣分点

---

### ❌ 5. 以为 Map 是 O(1) 空间

❌ 它是 **查找 O(1)**，不是空间

---

### ❌ 6. 忽略字符串不可变

```js
s += char;
```

➡ 每次都是新字符串

---

### ❌ 7. JSON.parse / stringify

➡ 深拷贝，空间 O(n)

---

# 六、空间复杂度判断 3 步法（必杀）

### 每次写完代码，问自己：

1️⃣ **新建了哪些数组 / Map / Set？**
2️⃣ **递归调用最大深度是多少？**
3️⃣ **有没有 slice / spread / concat？**

---

# 七、训练方案（你现在最适合）

### 🔥 7 道空间复杂度专项题

1. 移除元素（O(1)）
2. 反转字符串（原地 vs 新数组）
3. 两数之和（Map vs 排序双指针）
4. 爬楼梯（DP 数组 vs 滚动变量）
5. 合并两个有序数组（原地）
6. 全排列（栈空间）
7. LRU 缓存（Map + 双向链表）

---

## 最后一句（非常重要）

> **JS 的空间复杂度，90% 输在“你没意识到它在分配内存”**

如果你愿意，下一步我可以：

* 🔍 把你一段 JS 算法 **逐行标注空间复杂度**
* 🧪 出 **10 道空间复杂度判断题（不写代码）**
* 🧠 给你一份 **JS 空间复杂度速查表（面试用）**

你选一个，我直接开始。
