# JavaScript 中的搜索算法概览

JavaScript（JS）中的搜索算法主要包括基础的**线性 / 顺序查找**、高效的**二分查找（折半查找）**，以及基于**树结构**（如二叉搜索树）、**哈希查找**，和针对字符串的 **KMP、Boyer–Moore** 等算法。  
这些算法覆盖了从简单线性时间到高效对数时间，再到复杂字符串匹配的多种场景，是数据处理与算法面试的基础内容。

---

## 一、基础与数组查找

### 1. 顺序查找（Linear Search）
- 最简单的查找方式
- 从头到尾逐个元素比较
- 适用于**未排序数据**
- 时间复杂度：O(n)

### 2. 二分查找（Binary Search）
- 要求数据**有序**
- 每次将搜索区间缩小一半
- 时间复杂度：O(log n)
- 空间复杂度：O(1)（迭代实现）

### 3. 插值查找（Interpolation Search）
- 二分查找的改进
- 根据查找值在区间中的比例估算位置
- 更适合**分布均匀的有序数据**
- 平均复杂度优于二分查找，但最坏仍为 O(n)

### 4. 分块查找（Block Search）
- 顺序查找 + 索引查找的结合
- 将数据分块，先定位块，再块内顺序查找
- 适合静态数据、查找频繁的场景

---

## 二、基于树与图的查找

### 1. 二叉搜索树查找（Binary Search Tree, BST）
- 左子树 < 根节点 < 右子树
- 支持高效的查找、插入和删除
- 平均时间复杂度：O(log n)
- 极端情况下可能退化为 O(n)

### 2. AVL 树 / 红黑树查找
- **自平衡二叉搜索树**
- 保证树的高度为 O(log n)
- 查找、插入、删除稳定在 O(log n)
- JavaScript 引擎内部常用于有序结构实现

### 3. 哈希查找（Hash Table）
- 通过哈希函数直接定位数据
- 平均时间复杂度接近 O(1)
- JavaScript 中的典型实现：
  - `Object`
  - `Map`
  - `Set`

### 4. 图搜索：BFS / DFS
- **广度优先搜索（BFS）**
- **深度优先搜索（DFS）**
- 常用于图或树结构
- 通过遍历节点寻找目标元素

---

## 三、字符串查找（String Searching）

### 1. 朴素字符串查找（Brute-Force）
- 从头开始逐字符匹配
- 实现简单，但效率低
- 时间复杂度：O(n × m)

### 2. KMP 算法（Knuth–Morris–Pratt）
- 对模式串进行预处理（部分匹配表 / next 数组）
- 避免重复比较
- 时间复杂度：O(n + m)

### 3. Boyer–Moore 算法
- 从模式串尾部开始匹配
- 利用坏字符和好后缀规则进行大步跳跃
- 实际应用中性能非常优秀

### 4. Rabin–Karp 算法
- 使用哈希值进行子串比较
- 适合多模式匹配
- 可能存在哈希冲突问题

---

## 四、JavaScript 中的实际应用

### 数组查找
- `Array.prototype.indexOf()` / `includes()`  
  → 顺序查找
- `Array.prototype.find()` / `findIndex()`  
  → 顺序查找，返回元素或索引

### 哈希结构
- `Object` / `Map` / `Set`  
  → 基于哈希查找，访问速度快

### 字符串查找
- `String.prototype.indexOf()`
- `String.prototype.search()`
- `String.prototype.includes()`

---

## 总结

- **未排序数据**：顺序查找
- **有序数组**：二分查找 / 插值查找
- **频繁查找**：哈希查找
- **树与图结构**：BST / AVL / 红黑树 / BFS / DFS
- **字符串匹配**：KMP、Boyer–Moore、Rabin–Karp

搜索算法的选择直接影响程序性能，是 JavaScript 开发和算法面试中的核心基础。
