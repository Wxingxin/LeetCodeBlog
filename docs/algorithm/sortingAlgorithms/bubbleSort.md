# 冒泡排序

> **冒泡排序：不断比较相邻元素，把大的（或小的）像气泡一样“冒”到一端。**

### 核心思想

1. **相邻元素两两比较**
2. **顺序不对就交换**
3. **一轮下来，最大值（或最小值）会被放到正确位置**
4. **重复多轮，直到整体有序**

📌 每一轮都会“确定”一个元素的位置
📌 排好序的部分 **不再参与比较**

### 执行过程拆解

以数组为例：

```js
[5, 3, 8, 4];
```

第 1 轮

- 5 vs 3 → 交换 → [3, 5, 8, 4]
- 5 vs 8 → 不换
- 8 vs 4 → 交换 → [3, 5, 4, 8]

👉 最大值 **8** 已到末尾

---

第 2 轮

- 3 vs 5 → 不换
- 5 vs 4 → 交换 → [3, 4, 5, 8]

👉 次大值 **5** 到位

---

第 3 轮

- 3 vs 4 → 不换
  👉 已有序，结束

### 基础版

```js
function bubbleSort(arr) {
  const n = arr.length;

  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换相邻元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }

  return arr;
}
```

📌 重点：

- 内层循环：负责“冒泡”
- `n - 1 - i`：避免比较已经排好的尾部

---

### 优化版

思想：**如果一轮下来没有发生交换，说明已经有序**

```js
function bubbleSort(arr) {
  const n = arr.length;

  for (let i = 0; i < n - 1; i++) {
    let swapped = false;

    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }

    // 如果本轮没有发生交换，直接结束
    if (!swapped) break;
  }

  return arr;
}
```

📌 面试可以这样说：

> “通过加一个标志位，冒泡排序在接近有序时可降为 O(n)”

## 六、时间 & 空间复杂度（必背）

| 项目       | 复杂度                      |
| ---------- | --------------------------- |
| 最好情况   | **O(n)**（已排序 + 优化版） |
| 平均情况   | O(n²)                       |
| 最坏情况   | O(n²)                       |
| 空间复杂度 | **O(1)**                    |
| 稳定性     | ✅ 稳定                     |

---

## 七、为什么冒泡排序是“稳定排序”？（高频）

> 因为只在 **严格大于** 时才交换，
> **相等元素的相对顺序不会改变**

---

## 八、冒泡排序的优缺点

### ✅ 优点

- 思想简单
- 容易实现
- 稳定排序

### ❌ 缺点

- 时间复杂度高
- 实际项目中几乎不用
- 面试更多考思想而不是性能

---

## 九、面试标准回答模板（直接背）

> 冒泡排序通过相邻元素两两比较，把较大的元素逐步移动到数组的一端。
> 每一轮确定一个元素的最终位置，时间复杂度为 O(n²)，空间复杂度为 O(1)，属于稳定排序。
> 当数组接近有序时，可通过设置交换标志位进行优化。
