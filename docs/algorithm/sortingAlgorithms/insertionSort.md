好，这一篇我给你把 **JS 的插入排序（Insertion Sort）** 讲成一套**“从小白到面试官都点头”的完整笔记**。
结构同样是：**思想 → 步骤 → 代码 → 变种 → 优化 → 易错点 → 面试总结**，直接可背可用 ✅

---

# 一、插入排序的核心思想（一句话）

> **把数组分成「已排序区间」和「未排序区间」，每次从未排序区取一个数，插入到已排序区的正确位置。**

📌 类比记忆：
👉 **打牌时整理手牌**（一张一张插入）

---

# 二、插入排序的直观理解（白话）

数组：

```js
[5, 3, 4, 1, 2];
```

### 排序过程（默认第 0 位已排好）

1️⃣ `[5] | 3 4 1 2`
👉 插入 3 → `[3, 5]`

2️⃣ `[3, 5] | 4 1 2`
👉 插入 4 → `[3, 4, 5]`

3️⃣ `[3, 4, 5] | 1 2`
👉 插入 1 → `[1, 3, 4, 5]`

4️⃣ `[1, 3, 4, 5] | 2`
👉 插入 2 → `[1, 2, 3, 4, 5]`

📌 **左边始终有序，右边逐渐减少**

---

# 三、算法层面的标准步骤

```text
for i = 1 到 n-1:
    current = arr[i]
    j = i - 1

    while j >= 0 且 arr[j] > current:
        arr[j + 1] = arr[j]   // 后移
        j--

    arr[j + 1] = current     // 插入
```

---

# 四、JS 标准实现（面试最推荐）

```js
function insertionSort(arr) {
  const n = arr.length;

  for (let i = 1; i < n; i++) {
    let current = arr[i];
    let j = i - 1;

    // 向右移动比 current 大的元素
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }

    // 插入到正确位置
    arr[j + 1] = current;
  }

  return arr;
}
```

✅ 特点：

- 原地排序
- 稳定
- 小数据非常快

---

# 五、插入排序的本质（重要）

📌 插入排序 ≠ 交换排序
它是：

> **“移动 + 插入”**

而不是：

```js
// ❌ 冒泡式写法（效率低）
[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
```

---

# 六、插入排序的常见变种大全

---

## 1️⃣ 从大到小排序

```js
function insertionSortDesc(arr) {
  for (let i = 1; i < arr.length; i++) {
    let cur = arr[i];
    let j = i - 1;

    while (j >= 0 && arr[j] < cur) {
      arr[j + 1] = arr[j];
      j--;
    }

    arr[j + 1] = cur;
  }
  return arr;
}
```

---

## 2️⃣ 使用交换版本（不推荐，但好理解）

```js
function insertionSortSwap(arr) {
  for (let i = 1; i < arr.length; i++) {
    let j = i;
    while (j > 0 && arr[j - 1] > arr[j]) {
      [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]];
      j--;
    }
  }
  return arr;
}
```

⚠️ 比标准写法 **慢很多**

---

## 3️⃣ 二分插入排序（优化比较次数）

📌 思想：

- 在「已排序区」中 **用二分查找插入位置**
- 移动次数不变

```js
function binaryInsertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let cur = arr[i];
    let left = 0;
    let right = i - 1;

    // 二分找位置
    while (left <= right) {
      let mid = (left + right) >> 1;
      if (arr[mid] > cur) right = mid - 1;
      else left = mid + 1;
    }

    // 整体右移
    for (let j = i - 1; j >= left; j--) {
      arr[j + 1] = arr[j];
    }

    arr[left] = cur;
  }
  return arr;
}
```

📌 时间复杂度仍是 O(n²)，但 **比较更少**

---

## 4️⃣ 希尔排序 = 插入排序的升级版

> 希尔排序的核心就是 **分组插入排序**

（你之后学希尔排序会秒懂）

---

# 七、时间 & 空间复杂度（重点）

| 情况           | 时间复杂度 |
| -------------- | ---------- |
| 最好（已排序） | **O(n)**   |
| 最坏（逆序）   | **O(n²)**  |
| 平均           | **O(n²)**  |
| 空间复杂度     | **O(1)**   |
| 稳定性         | ✅ 稳定    |

📌 插入排序是 **唯一一个最好情况是 O(n) 的简单排序**

---

# 八、插入排序 vs 选择 / 冒泡

| 对比       | 插入排序 | 选择排序 | 冒泡排序 |
| ---------- | -------- | -------- | -------- |
| 是否稳定   | ✅       | ❌       | ✅       |
| 是否自适应 | ✅       | ❌       | ✅       |
| 最好情况   | O(n)     | O(n²)    | O(n)     |
| 交换次数   | 少       | 很少     | 多       |
| 实际应用   | ⭐⭐⭐⭐ | ⭐       | ⭐⭐     |

📌 **小规模 + 近乎有序 = 插入排序之王**

---

# 九、常见易错点（必看）

❌ **忘记保存 current**

```js
// 错误 ❌
while (arr[j] > arr[i]) {
  arr[j + 1] = arr[j];
}
```

✅ 正确：

```js
let current = arr[i];
```

---

❌ **while 写成 if**

```js
// ❌ 只能移动一次
if (arr[j] > current) { ... }
```

---

❌ **j + 1 写成 j**

```js
arr[j] = current; // ❌ 覆盖
```

---

# 十、一句话面试总结（直接背）

> 插入排序将数组分为已排序区和未排序区，每次取未排序区的一个元素，通过移动已排序区中较大的元素，将其插入到正确位置。它是稳定的原地排序，对近乎有序的数据性能极佳。

---

如果你愿意，我可以继续帮你 👇

- 🔥 用 **图解 + 动画思维**再走一遍
- 🔥 总结 **什么时候用插入排序，什么时候不用**
- 🔥 和 **希尔 / 快排 / 归并**建立完整排序体系

你下一步想学哪一个？
