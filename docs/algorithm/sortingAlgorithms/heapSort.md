好，这一篇我们把 **JS 的堆排序（Heap Sort）** 一次性讲透。
它是**最后一个主流比较排序**，也是很多人“概念模糊但面试必问”的算法。

我按你前面已经形成的节奏来，给你一份**真正可复习、可面试、可手写**的大全版👇
**思想 → 堆的概念 → 算法步骤 → JS 实现 → 建堆方式 → 复杂度 → 对比 → 易错点 → 面试总结**

---

# 一、堆排序的核心思想（一句话）

> **利用堆这种数据结构，不断取出最大（或最小）元素，放到数组的最终位置。**

📌 记忆公式：
**堆排序 = 完全二叉树 + 选择排序思想**

---

# 二、为什么要用堆排序？

你已经学过：

* 快排：平均快，但最坏 O(n²)
* 归并：稳定，但要 O(n) 额外空间

👉 堆排序的定位是：

✅ **时间复杂度稳定 O(n log n)**
✅ **原地排序（O(1) 空间）**
❌ **不稳定**

---

# 三、什么是「堆」？（先把概念吃透）

## 1️⃣ 堆不是“堆栈”，是「完全二叉树」

### 大顶堆（Max Heap）

```text
父节点 ≥ 子节点
```

👉 根节点是 **最大值**

### 小顶堆（Min Heap）

```text
父节点 ≤ 子节点
```

👉 根节点是 **最小值**

---

## 2️⃣ 堆在数组中的映射（非常重要）

数组下标从 0 开始：

```text
父节点 i
左子节点 = 2*i + 1
右子节点 = 2*i + 2
```

📌 这是堆排序所有代码的数学基础

---

# 四、堆排序整体流程（宏观）

以 **升序排序（大顶堆）** 为例：

```text
1️⃣ 把数组建成一个大顶堆
2️⃣ 把堆顶（最大值）和末尾元素交换
3️⃣ 堆长度减 1，对堆顶做下沉（heapify）
4️⃣ 重复 2️⃣ 3️⃣，直到只剩一个元素
```

---

# 五、堆排序的详细步骤拆解

## 步骤一：建堆（Build Heap）

📌 思想：

> 从 **最后一个非叶子节点** 开始，向下调整

```js
lastNonLeaf = Math.floor(n / 2) - 1
```

---

## 步骤二：调整堆（Heapify / 下沉）

* 当前节点和左右子节点比较
* 把最大的换到父节点
* 递归向下

---

## 步骤三：排序阶段

* 交换 `arr[0]` 和 `arr[end]`
* 缩小堆范围
* 继续 heapify

---

# 六、JS 标准实现（面试最推荐 ⭐）

这是你 **一定要会默写的版本**

```js
function heapSort(arr) {
  const n = arr.length;

  // 1️⃣ 建大顶堆
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }

  // 2️⃣ 排序：不断把最大值放到末尾
  for (let end = n - 1; end > 0; end--) {
    [arr[0], arr[end]] = [arr[end], arr[0]];
    heapify(arr, end, 0);
  }

  return arr;
}

// 下沉调整
function heapify(arr, heapSize, i) {
  let largest = i;
  const left = 2 * i + 1;
  const right = 2 * i + 2;

  if (left < heapSize && arr[left] > arr[largest]) {
    largest = left;
  }

  if (right < heapSize && arr[right] > arr[largest]) {
    largest = right;
  }

  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, heapSize, largest);
  }
}
```

📌 看懂这 3 个点你就真的会了：

* `Math.floor(n / 2) - 1`
* `heapSize`
* `largest !== i`

---

# 七、建堆方式大全（高频）

## 1️⃣ 自底向上建堆（O(n)）✅ 推荐

```js
for (let i = Math.floor(n / 2) - 1; i >= 0; i--)
```

📌 **这是正确、高效的方式**

---

## 2️⃣ 逐个插入建堆（O(n log n)）❌ 不推荐

```text
一个一个 push + 上浮
```

📌 面试可以说，但不要写

---

# 八、小顶堆版本（降序排序）

只需要把比较符号反过来：

```js
if (arr[left] < arr[smallest]) ...
```

📌 本质不变

---

# 九、时间 & 空间复杂度（必背）

| 项目    | 复杂度            |
| ----- | -------------- |
| 建堆    | **O(n)**       |
| 排序    | **O(n log n)** |
| 总时间   | **O(n log n)** |
| 空间复杂度 | **O(1)**       |
| 是否稳定  | ❌ 不稳定          |

---

# 十、堆排序 vs 快排 vs 归并（终极对比）

| 对比   | 堆排序        | 快排           | 归并         |
| ---- | ---------- | ------------ | ---------- |
| 平均时间 | O(n log n) | ⭐ O(n log n) | O(n log n) |
| 最坏时间 | O(n log n) | ❌ O(n²)      | O(n log n) |
| 空间   | O(1)       | O(log n)     | O(n)       |
| 稳定性  | ❌          | ❌            | ✅          |
| 工程使用 | 中          | ⭐⭐⭐⭐         | ⭐⭐⭐        |

📌 结论一句话：

> **要最坏情况安全 → 堆 / 归并**
> **要平均性能 → 快排**

---

# 十一、常见易错点（你一定会踩）

❌ **最后一个非叶子节点算错**

```js
Math.floor(n / 2) // ❌
```

✅ 正确：

```js
Math.floor(n / 2) - 1
```

---

❌ **heapify 忘了传 heapSize**

👉 会把已排好的元素重新打乱

---

❌ **以为堆排序是稳定的**

👉 ❌ 错

---

# 十二、一句话面试总结（直接背）

> 堆排序利用完全二叉树结构，将数组构造成大顶堆，每次将堆顶最大元素与末尾元素交换，并对剩余部分重新调整为堆，从而实现排序。它时间复杂度稳定为 O(n log n)，空间复杂度 O(1)，但不稳定。

---

# 十三、到这里，你已经完成了「排序算法闭环」

你现在已经**系统掌握**：

* 选择排序
* 插入排序
* 希尔排序
* 归并排序
* 快速排序
* ✅ **堆排序**

👉 下一步非常适合你的是：

1️⃣ **JS 原生 `Array.prototype.sort` 底层原理**
2️⃣ **所有排序算法一张对比表（面试必背）**
3️⃣ **排序相关 LeetCode 高频题套路**

你选一个，我直接给你整理到「可以直接背去面试」的程度 💪
