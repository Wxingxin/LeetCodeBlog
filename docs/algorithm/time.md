这个问题问得非常好 👍
**JS 里时间复杂度的学习，最有效的方法就是：规则 + 大量“真实代码案例”对照**。
下面我会按 **「认知规则 → JS 常见结构 → 高频算法题案例 → 易错点」** 来系统讲一遍，尽量用你熟悉的 LeetCode / 前端 JS 场景。

---

# 一、时间复杂度是什么（一句话版）

> **时间复杂度 = 输入规模 n 变大时，代码执行次数增长的趋势**

* 不是运行快慢（和机器无关）
* 不看常数，只看 **最高阶**
* 目标：判断 **规模变大时，代码“爆不爆”**

---

# 二、JS 时间复杂度判断 6 条铁律（非常重要）

### 1️⃣ 顺序代码：**相加**

```js
for (...) {...}   // O(n)
for (...) {...}   // O(n)
```

➡ **O(n + n) = O(n)**

---

### 2️⃣ 嵌套循环：**相乘**

```js
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    ...
  }
}
```

➡ **O(n²)**

---

### 3️⃣ 循环步长翻倍 / 减半：**O(log n)**

```js
while (n > 1) {
  n = Math.floor(n / 2);
}
```

➡ **O(log n)**（二分、快慢指针常见）

---

### 4️⃣ 只看最坏情况（Big-O）

```js
if (x === target) return;
```

即使可能提前结束，也按 **最坏情况**算。

---

### 5️⃣ 忽略常数和低阶

```js
O(3n + 100) → O(n)
O(n² + n) → O(n²)
```

---

### 6️⃣ Map / Set / Object 查找 ≈ O(1)

```js
map.get(key)
set.has(x)
obj[key]
```

---

# 三、JS 中最常见的时间复杂度模板（案例版）

---

## ① 单循环遍历数组 → O(n)

```js
for (let i = 0; i < nums.length; i++) {
  sum += nums[i];
}
```

✔️ `Two Sum`（一次遍历版）
✔️ `maxSubArray`
✔️ `minSubArrayLen`（滑动窗口）

---

## ② 双指针（左右夹逼）→ O(n)

```js
let l = 0, r = n - 1;
while (l < r) {
  ...
  l++; // 或 r--
}
```

📌 **关键点**：两个指针都只走一遍数组

### 典型题

* Two Sum II
* 三数之和（外层 O(n)，内层双指针 O(n) → 总 O(n²)）
* 回文字符串判断

---

## ③ 滑动窗口 → O(n)

```js
let l = 0;
for (let r = 0; r < n; r++) {
  ...
  while (条件) {
    l++;
  }
}
```

❗ 很多人误以为是 O(n²)，其实：

> `l` 和 `r` 都最多走 n 次 → **O(2n) = O(n)**

### 典型题

* `minSubArrayLen`
* `lengthOfLongestSubstring`
* `findSubstring`（困难版）

---

## ④ 双重循环 → O(n²)

```js
for (let i = 0; i < n; i++) {
  for (let j = i + 1; j < n; j++) {
    ...
  }
}
```

### 典型题

* 暴力 Two Sum
* 冒泡排序
* 选择排序

---

## ⑤ 排序相关 → O(n log n)

```js
nums.sort((a, b) => a - b);
```

📌 JS 中 `Array.prototype.sort`：

* 平均：**O(n log n)**
* 引擎实现不同（V8 是 Timsort）

### 常见组合

```js
nums.sort(...)
for (...) {...}
```

➡ **O(n log n + n) = O(n log n)**

---

## ⑥ 二分查找 → O(log n)

```js
while (l <= r) {
  const mid = (l + r) >> 1;
  if (...) ...
}
```

### 典型题

* 搜索插入位置
* 搜索旋转数组
* 平方根

---

## ⑦ 递归 & 分治

### 1️⃣ 线性递归 → O(n)

```js
function dfs(n) {
  if (n === 0) return;
  dfs(n - 1);
}
```

---

### 2️⃣ 二分递归 → O(log n)

```js
dfs(l, r) {
  dfs(l, mid);
}
```

---

### 3️⃣ 经典分治（归并排序）

```js
T(n) = 2T(n/2) + O(n)
```

➡ **O(n log n)**

---

## ⑧ 回溯（指数级）

```js
function backtrack(path) {
  for (...) {
    backtrack(newPath);
  }
}
```

➡ 常见复杂度：

* 子集：O(2ⁿ)
* 全排列：O(n!)

### 典型题

* 全排列
* N 皇后
* 组合总和

---

# 四、结合你做过的题（快速对照）

| 题目             | 核心结构      | 时间复杂度                 |
| -------------- | --------- | --------------------- |
| Two Sum II     | 双指针       | O(n)                  |
| minSubArrayLen | 滑动窗口      | O(n)                  |
| findSubstring  | 多窗口滑动     | O(n × wordLen) ≈ O(n) |
| 三数之和           | for + 双指针 | O(n²)                 |
| 合并 K 个链表       | 分治        | O(n log k)            |
| 排序链表           | 归并排序      | O(n log n)            |

---

# 五、JS 时间复杂度最容易踩的 5 个坑

### ❌ 1. 在循环里用 `slice / substring`

```js
for (...) {
  s.slice(...) // O(k)
}
```

➡ 可能升级成 **O(n²)**

---

### ❌ 2. 在循环里用 `shift()`

```js
arr.shift(); // O(n)
```

📌 JS 数组头删是线性时间

---

### ❌ 3. `includes()` 放在循环里

```js
for (...) {
  arr.includes(x) // O(n)
}
```

➡ 总复杂度 **O(n²)**
✔️ 用 `Set`

---

### ❌ 4. 误判滑动窗口为 O(n²)

👉 这是面试常见误区

---

### ❌ 5. 忽略递归层数

```js
dfs() {
  dfs();
  dfs();
}
```

➡ 指数级，不是 O(n)

---

# 六、学习路线（非常适合你现在）

### 第一步：背模板（必须）

* 单循环
* 双指针
* 滑动窗口
* 二分
* DFS / 回溯

### 第二步：每写一道题，强制回答 3 个问题

1. **循环几层？**
2. **指针/变量最多走几次？**
3. **有没有隐藏的 O(n) 操作？**

### 第三步：做 20 道后，你会“本能判断”

---

## 最后一句话（给你吃定心丸）

> **90% 的 JS 算法题，时间复杂度判断只靠：循环层数 + 指针是否回头**

如果你愿意，下一步我可以：

* 用 **10 道 LeetCode 题** 给你做「时间复杂度专项训练」
* 或把你写过的某段 JS 代码，**逐行标复杂度**帮你训练“算法眼”
