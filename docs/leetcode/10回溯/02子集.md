# 题

- 给你一个整数数组 `nums` ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

- 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

## 示例 1：

输入：`nums = [1,2,3]`

输出：`[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]`

## 示例 2：

输入：`nums = [0]`

输出：`[[],[0]]`

# 解

## 🧠 思路：

## JavaScript 代码（回溯法）

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
  const res = []; // 最终结果：所有子集
  const path = []; // 当前路径：当前已经选了哪些数

  // 回溯函数，start 表示“下一次可以选择的起始下标”
  const backtrack = (start) => {
    // 每到达一层递归，就把当前 path 加入结果
    // 因为：path 本身就是一个合法的子集（包括空集）
    res.push(path.slice()); // 注意拷贝一份

    // 从 start 开始，尝试选择后面的每一个数
    for (let i = start; i < nums.length; i++) {
      path.push(nums[i]); // ① 做选择：把 nums[i] 加入当前子集
      backtrack(i + 1); // ② 递归：下一层只能从 i+1 开始选，避免重复
      path.pop(); // ③ 撤销选择（回溯）
    }
  };

  // 从下标 0 开始回溯
  backtrack(0);
  return res;
};
```

---

# 🔍 用例：nums = [1, 2, 3] 的搜索树

### 初始：path = []

加入结果：`[]`

```
        []
    /     |     \
  [1]    [2]    [3]
 /  \     |       \
[1,2][1,3][2,3]   [3]
  |
[1,2,3]
```

生成顺序大致如下：

1. `[]`
2. `[1]`
3. `[1,2]`
4. `[1,2,3]`
5. `[1,3]`
6. `[2]`
7. `[2,3]`
8. `[3]`

输出：

```js
[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]];
```

---

# 🎉 小总结

- 回溯模板非常简洁：进入每层递归就保存当前 `path`
- `start` 参数保证不会出现重复子集
- 时间复杂度：O(n \* 2^n)，因为总共有 2^n 个子集

---

如果你愿意，我可以继续给你：

- **更直观的图形化 DFS 扩展过程**
- **位运算法（位掩码）生成所有子集**
- **子集 II 版本（含重复数字的去重技巧）**

告诉我即可！
