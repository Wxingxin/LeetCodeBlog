# 题

给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

## 示例 1：

输入：`s = "aab"`
输出：`[["a","a","b"],["aa","b"]]`

## 示例 2：

输入：`s = "a"`
输出：`[["a"]]`

# 解

**题目**：LeetCode 131. Palindrome Partitioning（回文分割）  
给你一个字符串 `s`，请把 `s` 切成若干个子串，使得 **每个子串都是回文**，返回所有可能的分割方案。

### 思路概览

经典的 **回溯（DFS） + 动态规划预处理回文子串** 组合。

1. 用 DP 先算出 `s[i…j]` 是否是回文（O(n²)），后面判断时直接 O(1) 查表。
2. 回溯过程中从 `start` 开始尝试所有可能的切点 `i`，如果 `s[start…i]` 是回文，就把它加入当前路径，继续递归处理后面的部分。
3. 当 `start === s.length` 时说明已经切完，把当前路径拷贝一份加入答案。

### 完整代码（JavaScript）

```javascript
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function (s) {
  const n = s.length;
  const ans = [];

  // Step 1: DP 预处理所有子回文串
  // dp[i][j] = true 表示 s[i..j] 是回文
  const dp = Array.from({ length: n }, () => Array(n).fill(false));

  // 从长度 1 开始填表
  for (let i = 0; i < n; i++) dp[i][i] = true; // 单个字符

  for (let len = 2; len <= n; len++) {
    // 子串长度
    for (let i = 0; i <= n - len; i++) {
      let j = i + len - 1; // 右端点
      if (len === 2) {
        dp[i][j] = s[i] === s[j];
      } else {
        dp[i][j] = s[i] === s[j] && dp[i + 1][j - 1];
      }
    }
  }

  // Step 2: 回溯
  const path = [];

  function backtrack(start) {
    if (start === n) {
      // 已经切完整个字符串
      ans.push([...path]); // 拷贝一份加入答案
      return;
    }

    for (let end = start; end < n; end++) {
      if (dp[start][end]) {
        // s[start..end] 是回文
        path.push(s.substring(start, end + 1));
        backtrack(end + 1); // 继续切后面的部分
        path.pop(); // 回溯
      }
    }
  }

  backtrack(0);
  return ans;
};
```

### 示例 1 详细过程：`s = "aab"`

```
dp 回文表（true 的位置）：
    0 1 2
  0 T T F   a
  1   T T   a
  2     T   b
```

回溯过程：

```
backtrack(0)
├─ end=0 : "a" 是回文 → path=["a"] → backtrack(1)
│   ├─ end=1 : "a" 是回文 → path=["a","a"] → backtrack(2)
│   │   ├─ end=2 : "b" 是回文 → path=["a","a","b"] → backtrack(3) → 加入答案 [["a","a","b"]]
│   │   pop "b"
│   └─ end=2 : "ab" 不是回文 → 跳过
│   pop "a"
│   └─ end=2 : "aab" 不是回文 → 跳过
├─ end=1 : "aa" 是回文 → path=["aa"] → backtrack(2)
│   ├─ end=2 : "b" 是回文 → path=["aa","b"] → backtrack(3) → 加入答案 [["aa","b"]]
│   pop "b"
pop "aa"
```

最终答案：`[["a","a","b"],["aa","b"]]`

### 示例 2：`s = "a"`

```
只有一种切法 → [["a"]]
```

### 示例 3：`s = "efe"`

```
可能的切法：
["e","f","e"]
["e","efe"]
["efe"]
→ 输出 [["e","f","e"],["e","efe"],["efe"]]
```

### 时间复杂度

- DP 预处理：O(n²)
- 回溯：最坏情况下有 2ⁿ⁻¹ 种切法（每个位置切或不切），每种检查回文 O(1)，总计 O(n·2ⁿ)
- 整体：**O(n·2ⁿ)**（符合题目要求）

这套写法在面试中非常清晰、易于讲解，强烈推荐掌握！
