# 题
给你一个字符串 s，找到 s 中最长的 回文 子串。

 

## 示例 1：

输入：`s = "babad"`
输出：`"bab"`
解释："aba" 同样是符合题意的答案。
## 示例 2：

输入：`s = "cbbd"`
输出：`"bb"`
# 

这题（最长回文子串，LeetCode 5）最常用、最好写、面试最稳的解法是：**中心扩展法**
时间复杂度 **O(n²)**，空间 **O(1)**，实现简单、好理解。

---

## 一、核心思路（中心扩展）

回文串的“中心”有两种情况：

1. **奇数长度回文**：中心是一个字符

* 例如 `"bab"` 中心是 `'a'`

2. **偶数长度回文**：中心是两个字符之间

* 例如 `"bb"` 中心是两个 `'b'` 中间

所以我们对每个位置 `i`：

* 以 `(i, i)` 扩展（奇数）
* 以 `(i, i+1)` 扩展（偶数）
  取最大即可。

---

## 二、结合示例讲解

### 示例 1：`"babad"`

* i=1（字符 'a'）

  * 奇数中心 `(1,1)` 扩展：`"a"` → `"bab"`（左右是 b 和 b）✅
* i=2（字符 'b'）

  * 奇数中心 `(2,2)` 扩展：`"b"` → `"aba"` ✅
    最终最长可能是 `"bab"` 或 `"aba"`（题目允许任意一个）。

### 示例 2：`"cbbd"`

* i=1（字符 'b'）

  * 偶数中心 `(1,2)` 扩展：`"bb"` ✅
    最长是 `"bb"`

---

## 三、代码实现（JS + 详细注释）

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  if (!s || s.length < 2) return s;

  // 记录最长回文的起始位置和长度
  let start = 0;
  let maxLen = 1;

  // 从中心 (l, r) 向两边扩展，返回该中心能得到的最长回文长度
  function expandAroundCenter(l, r) {
    // 只要左右没越界且字符相等，就继续扩展
    while (l >= 0 && r < s.length && s[l] === s[r]) {
      l--;
      r++;
    }
    // 退出循环时，l 和 r 已经多走了一步
    // 实际回文区间是 [l+1, r-1]，长度是 (r-1) - (l+1) + 1 = r - l - 1
    return r - l - 1;
  }

  for (let i = 0; i < s.length; i++) {
    // 1) 奇数长度回文：中心在 i
    const len1 = expandAroundCenter(i, i);

    // 2) 偶数长度回文：中心在 i 和 i+1 之间
    const len2 = expandAroundCenter(i, i + 1);

    // 取两种中心下更长的回文长度
    const len = Math.max(len1, len2);

    // 如果找到更长的回文，更新起点和长度
    if (len > maxLen) {
      maxLen = len;

      /**
       * 已知中心在 i，回文长度为 len
       * 回文起点 = i - Math.floor((len - 1) / 2)
       * 这是同时兼容奇数/偶数的写法
       */
      start = i - Math.floor((len - 1) / 2);
    }
  }

  // 从 start 截取长度为 maxLen 的子串
  return s.substring(start, start + maxLen);
};
```

---

## 四、复杂度

* 时间：O(n²)（每个中心最多扩展 O(n)）
* 空间：O(1)

---

如果你还想更进一步（更快的 **Manacher 算法 O(n)**），我也可以继续用同样的“结合案例+注释”方式讲，但中心扩展法一般已经足够通过面试和题库。
