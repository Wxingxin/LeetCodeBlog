# 题
给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
 

## 示例 1：

输入：`word1 = "horse", word2 = "ros"`
输出：`3`
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

# 解

下面是 LeetCode 72「编辑距离」（Edit Distance）。这是经典二维 DP：`dp[i][j]` 表示把 **word1 的前 i 个字符**变成 **word2 的前 j 个字符**的最少操作数。

---

## 代码（超详细注释）

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
  const m = word1.length;
  const n = word2.length;

  // dp[i][j]：将 word1 前 i 个字符(0..i-1) 转成 word2 前 j 个字符(0..j-1) 的最少操作数
  // 尺寸 (m+1) x (n+1)，多出来的一行一列用于处理“空串”
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));

  // 1️⃣ 初始化：把 word1 前 i 个字符变成空串，只能“删除” i 次
  for (let i = 0; i <= m; i++) {
    dp[i][0] = i;
  }

  // 2️⃣ 初始化：把空串变成 word2 前 j 个字符，只能“插入” j 次
  for (let j = 0; j <= n; j++) {
    dp[0][j] = j;
  }

  // 3️⃣ 状态转移：填表
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      // 当前比较的字符
      const c1 = word1[i - 1];
      const c2 = word2[j - 1];

      if (c1 === c2) {
        // 3.1️⃣ 字符相等：不用做操作，直接继承左上角
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        // 3.2️⃣ 字符不等：三种操作取最小
        // 替换：把 c1 替换成 c2 → 来自 dp[i-1][j-1] + 1
        const replace = dp[i - 1][j - 1] + 1;

        // 删除：删除 word1 的当前字符 c1 → 来自 dp[i-1][j] + 1
        const del = dp[i - 1][j] + 1;

        // 插入：在 word1 末尾插入一个字符 c2（让它对齐 word2 的当前字符）
        // 等价于：先把 word1 前 i 个字符变成 word2 前 j-1 个字符，再插入 c2
        // → 来自 dp[i][j-1] + 1
        const insert = dp[i][j - 1] + 1;

        dp[i][j] = Math.min(replace, del, insert);
      }
    }
  }

  // 4️⃣ dp[m][n] 就是把整个 word1 变成整个 word2 的最少操作数
  return dp[m][n];
};
```

---

## 为什么这三种转移是对的？（一句话对应一个操作）

假设我们正在算 `dp[i][j]`，也就是：
把 `word1[0..i-1]` 变成 `word2[0..j-1]`。

当最后一个字符不相等时：

1. **替换** `word1[i-1] -> word2[j-1]`
   那前面部分就得先变好：`dp[i-1][j-1]`，再 +1 次替换

2. **删除** `word1[i-1]`
   删除后，word1 变短了一位，要匹配的 word2 还没变：`dp[i-1][j]`，再 +1 次删除

3. **插入** `word2[j-1]` 到 word1 末尾
   插入后 word2 的最后一位就“对齐了”，所以插入前需要先把 word1 变到 `word2` 的前 `j-1` 位：`dp[i][j-1]`，再 +1 次插入

---

## 结合示例详细推演：`word1="horse"`, `word2="ros"`，答案 3

我们不把整张 6x4 表全写出来（太大），但把**关键路径**讲清楚：

### 初始化含义

* `dp[i][0]=i`：`"horse"` 变 `""` 只能删：5 次
* `dp[0][j]=j`：`""` 变 `"ros"` 只能插：3 次

### 关键对齐过程（理解 dp 如何“选择操作”）

目标：`horse -> ros`

#### 1) h vs r 不同

在某个格子会做出选择：**替换 h 为 r**

* 相当于走了“replace”这条路：`dp` 从左上角来 +1

得到：`horse -> rorse`（1 次）

#### 2) 接下来处理多余字符

`rorse` 想变 `rose`：删掉第二个 `r`

* 走“delete”路线：从上方来 +1

得到：`rorse -> rose`（2 次）

#### 3) 最后 `rose` 变 `ros`：删掉 `e`

* 再一次 delete

得到：`rose -> ros`（3 次）

这条路径刚好对应示例解释的 3 步，DP 会在所有可能操作组合里选出最少的那条，所以输出 3。

---

## 复杂度

* 时间：`O(m*n)`
* 空间：`O(m*n)`（如果你需要，我可以继续给你一维滚动数组压缩到 `O(n)` 的写法，也能配案例推演）

如果你想，我还可以把 `"horse"` 和 `"ros"` 的整张 dp 表画出来，帮助你直观看到每一格是怎么选出最小值的。
