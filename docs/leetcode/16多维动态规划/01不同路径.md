# 题
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

## 示例 1：
![](./img/a1.png)


输入：`m = 3, n = 7`
输出：`28`
## 示例 2：

输入：`m = 3, n = 2`
输出：`3`
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
`1. 向右 -> 向下 -> 向下`
`2. 向下 -> 向下 -> 向右`
`3. 向下 -> 向右 -> 向下`
## 示例 3：

输入：`m = 7, n = 3`
输出：`28`
## 示例 4：

输入：`m = 3, n = 3`
输出：`6`
# 解

好，我们结合**示例 m = 3, n = 7**，一步一步把代码拆开讲清楚，并把**详细注释**直接写进代码里，保证你一行一行都能对得上 👇

---

## 一、核心思路（先用人话理解）

机器人从 **左上角 (0,0)** 到 **右下角 (m-1,n-1)**：

* 只能 **向右** 或 **向下**
* 到达某个格子 `(i,j)`，只能来自：

  * 上面 `(i-1,j)`
  * 左边 `(i,j-1)`

👉 **路径数 = 上方路径数 + 左方路径数**

这就是动态规划。

---

## 二、状态定义

我们用一维数组 `dp`：

```js
dp[j] = 当前行中，到达第 j 列的路径总数
```

为什么可以用一维？

* 因为当前行只依赖 **上一行（dp[j]）** 和 **当前行左边（dp[j-1]）**

---

## 三、完整代码 + 超详细注释

```js
/**
 * @param {number} m  行数
 * @param {number} n  列数
 * @return {number}   不同路径的数量
 */
var uniquePaths = function(m, n) {

  // 1️⃣ 创建 dp 数组，长度为 n（列数）
  // dp[j] 表示：到达当前行第 j 列的路径数
  const dp = new Array(n).fill(1);

  /*
    初始化为什么都是 1？
    - 第一行：只能一直向右走
    - 不管走到哪一列，路径都只有 1 条
    例：m=3, n=7
    第一行 dp = [1,1,1,1,1,1,1]
  */

  // 2️⃣ 从第 2 行开始遍历（i = 1）
  for (let i = 1; i < m; i++) {

    // 3️⃣ 从第 2 列开始遍历（j = 1）
    for (let j = 1; j < n; j++) {

      /*
        dp[j]     → 上方的路径数（上一行）
        dp[j - 1] → 左边的路径数（当前行）

        状态转移公式：
        到达 (i,j) 的路径数 = 上方 + 左方
      */
      dp[j] = dp[j] + dp[j - 1];
    }

    /*
      每一行结束后，dp 数组代表这一整行的路径数
      例如 m=3,n=7 时：

      第 2 行结束：
      dp = [1,2,3,4,5,6,7]

      第 3 行结束：
      dp = [1,3,6,10,15,21,28]
    */
  }

  // 4️⃣ 返回右下角的路径数
  return dp[n - 1];
};
```

---

## 四、结合示例 m = 3, n = 7 手动推演

### 🔹 初始（第一行）

```
dp = [1,1,1,1,1,1,1]
```

### 🔹 第二行

```
j=1 → 1+1=2
j=2 → 2+1=3
j=3 → 3+1=4
...
dp = [1,2,3,4,5,6,7]
```

### 🔹 第三行

```
j=1 → 2+1=3
j=2 → 3+3=6
j=3 → 6+4=10
...
dp = [1,3,6,10,15,21,28]
```

👉 右下角 = `28`

---

## 五、为什么从 j=1 开始？

* `dp[0]` 是第一列
* 第一列只能一直向下走
* 所以每一行 `dp[0]` 都是 `1`
* 避免越界，也符合逻辑

---

## 六、一句话总结

> **每个格子的路径数 = 来自上方的路径数 + 来自左方的路径数**

如果你愿意，我可以：

* 画 ASCII 表格一步步画路径
* 用二维 dp 写一版对比
* 用组合数学方法再讲一遍

直接告诉我你想用哪种方式 👍
