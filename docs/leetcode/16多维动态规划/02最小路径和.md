# 题 

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

 

## 示例 1：


输入：`grid = [[1,3,1],[1,5,1],[4,2,1]]`
输出：`7`
解释：因为路径 1→3→1→1→1 的总和最小。
## 示例 2：

输入：`grid = [[1,2,3],[4,5,6]]`
输出：`12`

# 解

下面是 LeetCode 64「最小路径和」。思路和你刚做的“不同路径”很像：**到达某格的最小和 = min(上方最小和, 左方最小和) + 当前格子值**。

我给你一维 DP（省空间）版本，并把注释写到“手把手可推演”的程度，然后用两个示例完整走一遍。

---

## 代码（超详细注释 + 一维 DP）

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
  const m = grid.length;        // 行数
  const n = grid[0].length;     // 列数

  // dp[j] 表示：当前处理到的这一行里，到达第 j 列的「最小路径和」
  const dp = new Array(n).fill(0);

  // 1️⃣ 初始化起点 (0,0)
  dp[0] = grid[0][0];

  // 2️⃣ 初始化第一行（只能从左往右走，不能从上来）
  // 所以：dp[j] = dp[j-1] + grid[0][j]
  for (let j = 1; j < n; j++) {
    dp[j] = dp[j - 1] + grid[0][j];
  }

  // 现在 dp 存的是「第一行」每个位置的最小路径和

  // 3️⃣ 从第二行开始逐行更新
  for (let i = 1; i < m; i++) {

    // 3.1️⃣ 更新当前行的第一列（只能从上往下走，不能从左来）
    // dp[0] 之前存的是「上一行第一列的最小和」
    // 到当前行第一列：只能 dp[0] + grid[i][0]
    dp[0] = dp[0] + grid[i][0];

    // 3.2️⃣ 更新当前行的其余列
    for (let j = 1; j < n; j++) {
      // dp[j]   → 还没更新前，代表「上一行同列」的最小和（上方）
      // dp[j-1] → 已经更新过，代表「当前行左边」的最小和（左方）

      // 到 (i,j) 的最小路径和 = min(上方, 左方) + 当前格子的值
      dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];
    }
  }

  // 4️⃣ dp[n-1] 就是到达右下角的最小路径和
  return dp[n - 1];
};
```

---

## 示例 1 推演：`grid = [[1,3,1],[1,5,1],[4,2,1]]`

网格：

```
1 3 1
1 5 1
4 2 1
```

### ✅ 第一步：初始化 dp（第一行）

* dp[0] = 1
* dp[1] = 1 + 3 = 4
* dp[2] = 4 + 1 = 5

此时：

```
dp = [1, 4, 5]
含义：到第一行各位置的最小和
```

### ✅ 第二行 i=1（行 [1,5,1]）

先更新第一列：

* dp[0] = 1 + 1 = 2

更新 j=1：

* 上方 dp[1]=4
* 左方 dp[0]=2
* dp[1] = min(4,2) + 5 = 7

更新 j=2：

* 上方 dp[2]=5
* 左方 dp[1]=7
* dp[2] = min(5,7) + 1 = 6

此时：

```
dp = [2, 7, 6]
```

### ✅ 第三行 i=2（行 [4,2,1]）

更新第一列：

* dp[0] = 2 + 4 = 6

更新 j=1：

* 上方 dp[1]=7
* 左方 dp[0]=6
* dp[1] = min(7,6) + 2 = 8

更新 j=2：

* 上方 dp[2]=6
* 左方 dp[1]=8
* dp[2] = min(6,8) + 1 = 7

最终：

```
dp = [6, 8, 7]
右下角 = 7 ✅
```

路径就是：`1 → 3 → 1 → 1 → 1 = 7`

---

## 示例 2 推演：`grid = [[1,2,3],[4,5,6]]`

```
1 2 3
4 5 6
```

初始化第一行：

* dp = [1, 3, 6]

第二行：

* dp[0] = 1 + 4 = 5
* dp[1] = min(3,5) + 5 = 8
* dp[2] = min(6,8) + 6 = 12

答案：`12 ✅`

---

## 你只要记住这句就够了

* **不同路径**：`dp = 上 + 左`
* **最小路径和**：`dp = min(上, 左) + 当前值`

如果你想，我也可以再给你一版「直接在 grid 原地修改」的写法（空间 O(1)）。
