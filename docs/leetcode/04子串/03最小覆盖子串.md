# 题目

给定两个字符串 **s 和 t**，长度分别是 **m 和 n**，返回 s 中的 **最短窗口** 子串，使得该子串**包含 t 中**的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 ""。

测试用例保证答案唯一。

## 示例 1：

输入：`s = "ADOBECODEBANC", t = "ABC"`

输出：`"BANC"`

解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

## 示例 2：

输入：`s = "a", t = "a"`

输出：`"a"`

解释：整个字符串 s 是最小覆盖子串。

## 示例 3:

输入: `s = "a", t = "aa"`

输出: `""`

解释: t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。

#

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
function minWindow(s, t) {
  if (t.length > s.length) return "";

  // 1. 统计 t 中每个字符出现的次数
  const need = new Map();
  for (const char of t) {
    need.set(char, (need.get(char) || 0) + 1);
  }

  // 2. 当前窗口中已经满足的字符数量
  let valid = 0; // 有多少种字符已经满足需求
  const totalNeed = need.size; // t 中有多少种不同字符

  // 3. 当前窗口中每个字符的计数
  const window = new Map();

  let left = 0;
  let right = 0;
  let minLen = Infinity;
  let minStart = 0; // 记录最小窗口的起始位置

  while (right < s.length) {
    const charRight = s[right];

    // 1. 右指针扩张：把字符加入窗口
    if (need.has(charRight)) {
      window.set(charRight, (window.get(charRight) || 0) + 1);
      // 如果这个字符的数量刚好达到需求，valid + 1
      if (window.get(charRight) === need.get(charRight)) {
        valid++;
      }
    }

    // 2. 当窗口已经包含所有字符时，尝试收缩左边界
    while (valid === totalNeed) {
      // 更新最小窗口
      if (right - left + 1 < minLen) {
        minLen = right - left + 1;
        minStart = left;
      }

      const charLeft = s[left];
      // 左指针收缩：移除左边字符
      if (need.has(charLeft)) {
        window.set(charLeft, window.get(charLeft) - 1);
        // 如果这个字符数量低于需求，valid 减 1
        if (window.get(charLeft) < need.get(charLeft)) {
          valid--;
        }
      }
      left++;
    }

    right++;
  }

  return minLen === Infinity ? "" : s.slice(minStart, minStart + minLen);
}
```

太好了！我们就用最经典、最能体现所有细节的例子来 **手把手、一步一步** 讲解「最小覆盖子串」是怎么工作的。

### 经典案例（LeetCode 官方样例）

```js
s = "ADOBECODEBANC";
t = "ABC";
```

目标：找 s 中最短的子串，**必须同时包含 A、B、C 各至少 1 次**  
答案：`"BANC"`（长度 4）

我们现在用上面那段 JS 代码，**完整模拟执行过程**，让你看清每一个指针、每一个计数的变化！

---

### 初始化阶段

```js
need = { A: 1, B: 1, C: 1 }; // t 中需要什么
window = {}; // 当前窗口里有什么（初始为空）
valid = 0; // 当前满足条件的字符种类数（0/3）
(left = 0), (right = 0);
minLen = Infinity;
minStart = 0;
```

---

### 详细执行过程（每一步都写出来）

| right | 加入的字符 | window 更新后 | valid | 窗口内容 | 是否收缩左边？ | 收缩细节      | 当前最优 |
| ----- | ---------- | ------------- | ----- | -------- | -------------- | ------------- | -------- |
| 0     | A          | {A:1}         | 1     | A        | 否             | —             | —        |
| 1     | D          | {A:1}         | 1     | AD       | 否             | —             | —        |
| 2     | O          | {A:1}         | 1     | ADO      | 否             | —             | —        |
| 3     | B          | {A:1,B:1}     | 2     | ADOB     | 否             | —             | —        |
| 4     | E          | {A:1,B:1}     | 2     | ADOBE    | 否             | —             | —        |
| 5     | C          | {A:1,B:1,C:1} | 3     | ADOBEC   | 是！valid===3  | 开始收缩 left | —        |

**right = 5 时，valid 变成 3！窗口 "ADOBEC" 已经包含 ABC → 可以收缩左边了！**

#### 开始收缩左指针（关键！）

| left | 移除的字符 | window 更新后 | valid 是否变？ | 说明                   | 当前窗口 |
| ---- | ---------- | ------------- | -------------- | ---------------------- | -------- |
| 0    | A          | {A:0,B:1,C:1} | →2             | A 不够了！             | DOBEC    |
| 1    | D          | {A:0,B:1,C:1} | 2              | D 不在 need 中，无影响 | OBEC     |
| 2    | O          | {A:0,B:1,C:1} | 2              | O 不在 need 中         | BEC      |
| 3    | B          | {A:0,B:0,C:1} | 2              | B 不够了！停止收缩     | EC       |

**收缩到这里停了**，因为 valid < 3 了，不能再缩了。

此时：

- 窗口是 s[3..5] → "BEC"
- 长度 = 3，但缺少 A → 不合法
- 但我们之前记录过一个合法窗口 "ADOBEC"（长度 6）

→ 更新最小长度：`minLen = 6`, `minStart = 0`

---

继续向右扩张 right

| right | 加入字符 | window 更新后 | valid | 说明                   |
| ----- | -------- | ------------- | ----- | ---------------------- |
| 6     | O        | {A:0,B:0,C:1} | 2     | 无影响                 |
| 7     | D        | {A:0,B:0,C:1} | 2     | 无影响                 |
| 8     | E        | {A:0,B:0,C:1} | 2     | 无影响                 |
| 9     | B        | {A:0,B:1,C:1} | 2     | B 补上了               |
| 10    | A        | {A:1,B:1,C:1} | 3     | A 也补上了！又满足了！ |

**right = 10 时，valid 再次变成 3！**

当前窗口：s[left=3 ... right=10] → "BECODEBA"

虽然很长，但包含 ABC → 可以开始收缩左边！

#### 第二次收缩（关键中的关键！）

| left | 移除字符 | window 更新后 | valid | 说明       | 当前窗口 |
| ---- | -------- | ------------- | ----- | ---------- | -------- |
| 3    | B        | {A:1,B:0,C:1} | 2     | B 不够了   | ECODEBA  |
| 4    | E        | {A:1,B:0,C:1} | 2     | 无影响     | CODEBA   |
| 5    | C        | {A:1,B:0,C:0} | 1     | C 不够了   | ODEBA    |
| 6    | O        | {A:1,B:0,C:0} | 1     | 无影响     | DEBA     |
| 7    | D        | {A:1,B:0,C:0} | 1     | 无影响     | EBA      |
| 8    | E        | {A:1,B:0,C:0} | 1     | 无影响     | BA       |
| 9    | B        | {A:1,B:0,C:0} | 1     | B 又不够了 | A        |
| 10   | A        | {A:0,B:0,C:0} | 0     | 全不够了   | 空       |

收缩过程中，我们在 **right=12** 之前，有一个关键时刻：

**当 right=12，加入 "N" 时**，窗口是 s[9..12] → "BANC"

让我们回溯一下：

| right | 加入字符 | 关键时刻（right=12）                             |
| ----- | -------- | ------------------------------------------------ |
| 11    | N        | —                                                |
| 12    | C        | → window = {A:1, B:1, C:1}（来自之前的 B,A,N,C） |

**right = 12 时，window 内容：**

- A 来自 "A" (index 10)
- B 来自 "B" (index 9)
- C 来自 "C" (index 12)
- 当前 left = 9（因为前面收缩到这里还没破坏 valid）

→ 窗口是 s[9..12] → "BANC"

→ 长度 = 4 < 6 → **更新答案！**

```js
minLen = 4;
minStart = 9;
```

之后 right 再往后走，已经没有更短的了。

---

### 最终结果

```js
return s.slice(9, 9 + 4) → "BANC"
```

完美！

---

### 执行过程总结图（强烈建议你手画一遍）

```
s:  A D O B E C O D E B A N C
idx:0 1 2 3 4 5 6 7 8 9 10 11 12

第一次满足：     [A D O B E C]         → 长度6
第二次满足 + 收缩 →         [B A N C]   → 长度4 ← 答案！
```

---

### 为什么这道题是 Hard？

因为它把滑动窗口的所有精华都用上了：

- 动态维护窗口状态（valid 计数）
- 左右指针配合（扩张 + 收缩）
- 及时更新最优解
- 处理重复字符（计数而非存在性）

---

### 一句话记住核心逻辑

> **右指针负责“找可行解”，左指针负责“优化解”**

右指针疯狂扩张，直到包含所有字符 → 左指针拼命收缩，直到刚好不满足 → 记录答案 → 继续右移找更优解

---

现在你彻底掌握了「最小覆盖子串」！

想我再用这个例子手写一遍所有变量变化（表格形式）？或者你想看：

- 包含重复字符的例子（如 t = "AABB"）
- 不存在解的例子
- 边界情况（s 比 t 短、t 只有一个字符）

随时安排！冲就完事儿了！
