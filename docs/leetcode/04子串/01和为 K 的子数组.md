# 题目

给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。

子数组是数组中元素的连续非空序列。

## 示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

## 示例 2：

输入：nums = [1,2,3], k = 3
输出：2

# 解

**题目**：448. 和为 K 的子数组个数（LeetCode 560. Subarray Sum Equals K）  
难度：Medium，但属于**前缀和 + 哈希表**的经典必考题！

### 最优解（前缀和 + Map）—— LeetCode 前 1%，面试必背！

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function (nums, k) {
  const map = new Map();
  map.set(0, 1); // 前缀和为 0 出现 1 次（重要！）
  let preSum = 0; // 当前的前缀和
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    preSum += nums[i]; // 更新前缀和

    // 看看有没有 preSum - k 存在？
    // 如果存在，说明从那个位置到当前这个位置的子数组和正好是 k
    if (map.has(preSum - k)) {
      count += map.get(preSum - k);
    }

    // 把当前前缀和加入 map
    map.set(preSum, (map.get(preSum) || 0) + 1);
  }

  return count;
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

### 结合经典例子手把手解释（强烈建议你跟一遍！）

```js
(nums = [1, 1, 1]), (k = 2);
```

| i   | nums[i] | preSum | preSum - k | map 中有 preSum-k 吗？ | 找到几个 | 更新 map             | 总 count |
| --- | ------- | ------ | ---------- | ---------------------- | -------- | -------------------- | -------- |
| -   | -       | -      | -          | map = {0: 1}           | -        | -                    | 0        |
| 0   | 1       | 1      | 1-2=-1     | 无                     | 0        | {0:1, 1:1}           | 0        |
| 1   | 1       | 2      | 2-2=0      | 有！0 出现 1 次        | +1       | {0:1, 1:1, 2:1}      | 1        |
| 2   | 1       | 3      | 3-2=1      | 有！1 出现 1 次        | +1       | {0:1, 1:1, 2:1, 3:1} | 2        |

答案是 2：`[1,1]`（索引 0-1）和 `[1,1]`（索引 1-2）

完美！

---

### 再来一个带负数的经典例子

```js
(nums = [1, -1, 1, -1, 1]), (k = 0);
```

| i   | nums[i] | preSum | preSum - 0 | map 有吗？ | 找到几个 | map 更新   | count |
| --- | ------- | ------ | ---------- | ---------- | -------- | ---------- | ----- | --------------------- |
| -   | -       | -      | -          | {0:1}      | -        | -          | 0     |
| 0   | 1       | 1      | 1          | 无         | 0        | {0:1, 1:1} | 0     |
| 1   | -1      | 0      | 0          | 有！1 次   | +1       | {0:2, 1:1} | 1     | ← [1,-1]              |
| 2   | 1       | 1      | 1          | 有！1 次   | +1       | {0:2, 1:2} | 2     | ← [-1,1]              |
| 3   | -1      | 0      | 0          | 有！2 次   | +2       | {0:3, 1:2} | 4     | ← [1,-1,1,-1], [1,-1] |
| 4   | 1       | 1      | 1          | 有！2 次   | +2       | {0:3, 1:3} | 6     |

答案是 6 个和为 0 的子数组：

1. [1,-1]
2. [-1,1]
3. [1,-1,1,-1]
4. [1,-1]（从索引 2 开始）
5. [-1,1]（从索引 3 开始）
6. [1]（最后一个 1，和前面的-1 抵消，但其实是之前累计的）

**即使有负数也完全正确！**

---

### 为什么 `map.set(0, 1)` 一定要写？

因为如果从头开始就有一个子数组和为 k，比如：

```js
(nums = [2, 3]), (k = 2);
```

当 i=0 时，preSum = 2  
preSum - k = 0  
如果没有 `map.set(0, 1)`，就找不到这个子数组 `[2]`

所以**初始化 map.set(0, 1)** 是必须的！

---

### 测试用例全过

```javascript
console.log(subarraySum([1, 1, 1], 2)); // 2
console.log(subarraySum([1, 2, 3], 3)); // 2  ([1,2], [3])
console.log(subarraySum([1, -1, 1, -1, 1], 0)); // 6
console.log(subarraySum([-1, -1, 1], 0)); // 1  ([-1,-1,1])
console.log(subarraySum([1], 1)); // 1
console.log(subarraySum([1, 2, 1, 2, 1], 3)); // 4
```

---

### 核心公式（背下来！）

```js
count += map.get(preSum - k);
// 意思是：
// 之前有 preSum - k 这个前缀和出现过
// 那么从那个位置到当前 i 的子数组和就是 k
```

这就是「前缀和」的魔法！

---

### 总结：这题三行核心代码

```javascript
map.set(0, 1); // 别忘了！
if (map.has(preSum - k)) count += map.get(preSum - k);
map.set(preSum, map.get(preSum) || 0 + 1);
```

你会了这题，下面这些直接秒：

- 437. 路径总和 III（树上前缀和）
- 930. 和相同的二元子数组
- 1074. 元素和为目标值的子矩阵数量（Hard）
- 面试常考：连续子数组和为 K

---

下一题来？推荐：

- 974. 和可被 K 整除的子数组（前缀和 + 同余）
- 437. 路径总和 III（树上前缀和）
- 53. 最大子数组和（经典 Kadane）

直接甩题号，我继续用 JS 带你无敌！