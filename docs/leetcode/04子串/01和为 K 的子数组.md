# 题目

给你一个整数数组 `nums` 和一个整数 `k` ，

请你统计并返回 该数组中和为 `k` 的子数组的个数 。

:::info 信息
子数组是数组中元素的连续非空序列。
:::

## 示例 1：

输入：`nums = [1,1,1], k = 2`

输出：`2`

## 示例 2：

输入：`nums = [1,2,3], k = 3`

输出：`2`

# 解

## 思路

### 1️⃣ 什么是前缀和？

前缀和 `preSum[i]` 表示：

> **从数组开头到第 i 个元素的总和**

如果：

```text
preSum[j] - preSum[i] = k
```

就说明：

```text
nums[i+1 ... j] 的和 = k
```

---

### 2️⃣ 为什么用 `Map`？

- 我们需要 **快速知道某个前缀和出现过几次**
- `Map` 可以在 **O(1)** 时间内完成查找和更新
- 适合这种「边遍历边统计」的问题

---

### 3️⃣ 核心公式（记住它）

> **如果当前前缀和是 `preSum`，
> 那么只要之前出现过 `preSum - k`，
> 就说明存在子数组和为 `k`**

出现几次，就能形成几个子数组。

---

### 4️⃣ 为什么一开始要 `map.set(0, 1)`？

这是一个**非常关键的细节**：

- 当 `preSum === k` 时
- `preSum - k === 0`
- 如果不提前放一个 `0 → 1`
- 就会漏掉「从下标 0 开始的子数组」

👉 这是新手最容易漏的点

## code

```javascript
/**
 * @param {number[]} nums  输入数组
 * @param {number} k       目标和
 * @return {number}        和为 k 的连续子数组个数
 */
var subarraySum = function (nums, k) {
  // 用 Map 记录「前缀和 -> 出现次数」
  const map = new Map();

  // 前缀和为 0 的情况先放进去 1 次
  // 这样可以处理「从下标 0 开始的子数组」刚好等于 k 的情况
  map.set(0, 1);

  let preSum = 0; // 当前遍历到位置时的前缀和
  let count = 0; // 符合条件的子数组数量

  for (let i = 0; i < nums.length; i++) {
    // 1. 累加当前元素，得到新的前缀和
    preSum += nums[i];

    // 2. 查找是否存在 preSum - k
    // 如果存在，说明：
    //   之前某个位置的前缀和为 preSum - k
    //   当前前缀和为 preSum
    //   那么中间这段子数组的和正好是 k
    if (map.has(preSum - k)) {
      count += map.get(preSum - k);
    }

    // 3. 把当前前缀和存入 map（次数 +1）
    map.set(preSum, (map.get(preSum) || 0) + 1);
  }

  // 返回最终统计结果
  return count;
};
```

### 结合经典例子手把手解释（强烈建议你跟一遍！）

```js
(nums = [1, 1, 1]), (k = 2);
```

| i   | nums[i] | preSum | preSum - k | map 中有 preSum-k 吗？ | 找到几个 | 更新 map             | 总 count |
| --- | ------- | ------ | ---------- | ---------------------- | -------- | -------------------- | -------- |
| -   | -       | -      | -          | map = {0: 1}           | -        | -                    | 0        |
| 0   | 1       | 1      | 1-2=-1     | 无                     | 0        | {0:1, 1:1}           | 0        |
| 1   | 1       | 2      | 2-2=0      | 有！0 出现 1 次        | +1       | {0:1, 1:1, 2:1}      | 1        |
| 2   | 1       | 3      | 3-2=1      | 有！1 出现 1 次        | +1       | {0:1, 1:1, 2:1, 3:1} | 2        |

答案是 2：`[1,1]`（索引 0-1）和 `[1,1]`（索引 1-2）

完美！

---

### 再来一个带负数的经典例子

```js
(nums = [1, -1, 1, -1, 1]), (k = 0);
```

| i   | nums[i] | preSum | preSum - 0 | map 有吗？ | 找到几个 | map 更新   | count |                       |
| --- | ------- | ------ | ---------- | ---------- | -------- | ---------- | ----- | --------------------- |
| -   | -       | -      | -          | {0:1}      | -        | -          | 0     |                       |
| 0   | 1       | 1      | 1          | 无         | 0        | {0:1, 1:1} | 0     |
| 1   | -1      | 0      | 0          | 有！1 次   | +1       | {0:2, 1:1} | 1     | ← [1,-1]              |
| 2   | 1       | 1      | 1          | 有！1 次   | +1       | {0:2, 1:2} | 2     | ← [-1,1]              |
| 3   | -1      | 0      | 0          | 有！2 次   | +2       | {0:3, 1:2} | 4     | ← [1,-1,1,-1], [1,-1] |
| 4   | 1       | 1      | 1          | 有！2 次   | +2       | {0:3, 1:3} | 6     |                       |

答案是 6 个和为 0 的子数组：

1. [1,-1]
2. [-1,1]
3. [1,-1,1,-1]
4. [1,-1]（从索引 2 开始）
5. [-1,1]（从索引 3 开始）
6. [1]（最后一个 1，和前面的-1 抵消，但其实是之前累计的）

**即使有负数也完全正确！**

---

### 为什么 `map.set(0, 1)` 一定要写？

因为如果从头开始就有一个子数组和为 k，比如：

```js
(nums = [2, 3]), (k = 2);
```

当 i=0 时，preSum = 2  
preSum - k = 0  
如果没有 `map.set(0, 1)`，就找不到这个子数组 `[2]`

所以**初始化 map.set(0, 1)** 是必须的！

---

### 测试用例全过

```javascript
console.log(subarraySum([1, 1, 1], 2)); // 2
console.log(subarraySum([1, 2, 3], 3)); // 2  ([1,2], [3])
console.log(subarraySum([1, -1, 1, -1, 1], 0)); // 6
console.log(subarraySum([-1, -1, 1], 0)); // 1  ([-1,-1,1])
console.log(subarraySum([1], 1)); // 1
console.log(subarraySum([1, 2, 1, 2, 1], 3)); // 4
```

---

### 核心公式（背下来！）

```js
count += map.get(preSum - k);
// 意思是：
// 之前有 preSum - k 这个前缀和出现过
// 那么从那个位置到当前 i 的子数组和就是 k
```

这就是「前缀和」的魔法！

---

### 总结：这题三行核心代码

```javascript
map.set(0, 1); // 别忘了！
if (map.has(preSum - k)) count += map.get(preSum - k);
map.set(preSum, map.get(preSum) || 0 + 1);
```

你会了这题，下面这些直接秒：

- 437. 路径总和 III（树上前缀和）
- 930. 和相同的二元子数组
- 1074. 元素和为目标值的子矩阵数量（Hard）
- 面试常考：连续子数组和为 K

---

下一题来？推荐：

- 974. 和可被 K 整除的子数组（前缀和 + 同余）
- 437. 路径总和 III（树上前缀和）
- 53. 最大子数组和（经典 Kadane）

直接甩题号，我继续用 JS 带你无敌！
