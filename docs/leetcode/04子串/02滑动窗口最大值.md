#

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

## 示例 1：

输入：`nums = [1,3,-1,-3,5,3,6,7], k = 3`
输出：`[3,3,5,5,6,7]`
解释：
滑动窗口的位置 最大值

---

`[1  3  -1] -3  5  3  6  7       3`
`1 [3  -1  -3] 5  3  6  7       3`
`1  3 [-1  -3  5] 3  6  7       5`
`1  3  -1 [-3  5  3] 6  7       5`
`1  3  -1  -3 [5  3  6] 7       6`
`1  3  -1  -3  5 [3  6  7]      7`

## 示例 2：

输入：`nums = [1], k = 1`
输出：`[1]`
# 

这题经典解法是 **单调队列（deque）**：队列里存“下标”，并且保证队列对应的值 **从队头到队尾单调递减**。这样队头永远是当前窗口最大值的下标。

核心规则（每来一个新元素 `i`）：

1. **踢掉过期下标**：如果队头下标 `< i - k + 1`，说明它已经不在窗口里了，弹出队头。
2. **维护单调递减**：当队尾对应的值 `<= nums[i]`，队尾就不可能再成为最大值了（被更大的新元素“压制”），弹出队尾。
3. **加入新下标**：把 `i` 入队。
4. 当 `i >= k-1`（窗口形成了），此时 **队头就是最大值**，加入答案。

---

## 结合示例 1 走一遍（nums = [1,3,-1,-3,5,3,6,7], k=3）

我们记录队列里存的 **下标**（同时看对应值）：

* i=0, 值=1
  队列=[] → 入队 0 → [0(1)]（窗口未满）

* i=1, 值=3
  维护递减：队尾 1 <= 3，弹出 0
  入队 1 → [1(3)]（窗口未满）

* i=2, 值=-1
  队尾 3 <= -1? 否
  入队 2 → [1(3),2(-1)]
  窗口满了（[0..2]），最大值 = nums[1]=3 → ans=[3]

* i=3, 值=-3（窗口 [1..3]）
  过期：队头 1 是否 < 1？否（正好还在）
  维护递减：-1 <= -3? 否
  入队 3 → [1(3),2(-1),3(-3)]
  最大值=nums[1]=3 → ans=[3,3]

* i=4, 值=5（窗口 [2..4]）
  过期：队头 1 < 2，是，弹出 1
  维护递减：从队尾开始
  nums[3]=-3 <= 5 弹出3
  nums[2]=-1 <= 5 弹出2
  入队 4 → [4(5)]
  最大值=5 → ans=[3,3,5]

后面同理，会得到 `[3,3,5,5,6,7]`。

---

## JS 代码（含详细注释）

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
  const n = nums.length;
  if (n === 0 || k === 0) return [];
  if (k === 1) return nums.slice(); // 每个窗口就一个元素

  const deque = []; // 存下标，且对应 nums 值单调递减（队头最大）
  const res = [];

  for (let i = 0; i < n; i++) {
    // 1) 移除队头过期元素：窗口左边界是 i - k + 1
    const left = i - k + 1;
    if (deque.length && deque[0] < left) {
      deque.shift();
    }

    // 2) 维护单调递减：把所有 <= 当前值的队尾都弹掉
    while (deque.length && nums[deque[deque.length - 1]] <= nums[i]) {
      deque.pop();
    }

    // 3) 当前下标入队
    deque.push(i);

    // 4) 窗口形成后，记录最大值（队头）
    if (i >= k - 1) {
      res.push(nums[deque[0]]);
    }
  }

  return res;
};
```

---

## 复杂度

* 时间：**O(n)**（每个元素最多进队/出队一次）
* 空间：**O(k)**（队列最多存 k 个下标）

如果你愿意，我也可以把示例 1 的每一步队列内容（下标/值）用表格完整打印出来，帮助你更直观看懂。

