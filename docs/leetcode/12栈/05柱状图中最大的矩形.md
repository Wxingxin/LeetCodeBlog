# 题
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

示例 1：

输入：nums = [1,3,4,2,2]
输出：2
示例 2：

输入：nums = [3,1,3,4,2]
输出：3
示例 3 :

输入：nums = [3,3,3,3,3]
输出：3

# 解

这是 LeetCode 84. 柱状图中最大的矩形（Largest Rectangle in Histogram），一道经典的 **单调栈** 问题。

**思路：**
对于每个柱子 i，我们想知道：以它为「高度」的最大矩形面积是多少？
即找到左边第一个比它矮的柱子（left[i]）和右边第一个比它矮的柱子（right[i]），
那么以 i 为高度的矩形宽度就是 `right[i] - left[i] - 1`，面积就是 `heights[i] * width`。

使用单调递增栈可以 O(n) 求出每个柱子的左右边界。

**代码（单调栈，推荐写法）：**

```javascript
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function (heights) {
  const n = heights.length;
  const stack = []; // 存索引，栈中高度严格递增
  let maxArea = 0;

  for (let i = 0; i <= n; i++) {
    // 当前高度（到末尾时用 0 强制清栈）
    const h = i === n ? 0 : heights[i];

    // 维护单调递增栈
    while (stack.length && heights[stack[stack.length - 1]] > h) {
      const height = heights[stack.pop()]; // 弹出的是“柱子高度”
      // 左边界：
      // 左边界是栈顶剩余的那个柱子
      // 右边界是当前 i
      const left = stack.length ? stack[stack.length - 1] : -1;
      const width = i - left - 1;
      maxArea = Math.max(maxArea, height * width);
    }
    stack.push(i);
  }
  return maxArea;
};
```

**示例验证：**

```js
console.log(largestRectangleArea([2, 1, 5, 6, 2, 3])); // 10
console.log(largestRectangleArea([2, 4])); // 6
console.log(largestRectangleArea([1])); // 1
```

**为什么这样是对的？**

- 当我们弹出一个柱子时，说明右边第一个比它矮的已经找到（就是当前 i）
- 栈里剩下的就是左边第一个比它矮的（栈是递增的）
- 这样每个柱子恰好被弹出一次，时间复杂度 O(n)，空间 O(n)

这是该问题最优解法，已被广泛用于面试和竞赛。

#

太好了！我们就用这个经典例子 `[2,1,5,6,2,3]` 来**手把手、一步一步**完整模拟单调栈的整个过程，让你彻底看懂为什么能得到最大面积 10。

---

### 输入：`heights = [2, 1, 5, 6, 2, 3]`

索引： 0 1 2 3 4 5

我们用单调栈的策略是：

> 维护一个**严格递增**的栈（存的是下标），  
> 当遇到一个比栈顶矮的柱子时，说明栈顶柱子的“右边界”找到了，就可以计算以它为高的最大矩形了！

---

### 详细模拟过程（推荐拿笔跟着画）

| i   | 当前高度 h | 操作                   | 栈的状态（从底到顶） | 弹出的柱子   | 计算面积                                       | 当前 maxArea |
| --- | ---------- | ---------------------- | -------------------- | ------------ | ---------------------------------------------- | ------------ |
|     |            | 初始化                 | []                   |              |                                                | 0            |
| 0   | 2          | 入栈                   | [0]                  |              |                                                | 0            |
| 1   | 1          | 1 < 2，弹出 0          | [] → [1]             | 柱子 0(高 2) | 宽度=1-(-1)-1=1 → 2×1=2                        | 2            |
|     |            | 入栈 1                 | [1]                  |              |                                                |              |
| 2   | 5          | 5 > 1，入栈            | [1,2]                |              |                                                | 2            |
| 3   | 6          | 6 > 5，入栈            | [1,2,3]              |              |                                                | 2            |
| 4   | 2          | 2 < 6，开始弹出！      |                      |              |                                                |              |
|     |            | 弹出 3(高 6)           | [1,2]                | 柱子 3(高 6) | 左边界=2，右边界=4<br>宽度=4-2-1=1 → 6×1=6     | 6            |
|     |            | 2 < 5，继续弹出        | [1]                  | 柱子 2(高 5) | 左边界=1，右边界=4<br>宽度=4-1-1=2 → 5×2=10    | **10**       |
|     |            | 2 > 1，入栈            | [1,4]                |              |                                                | 10           |
| 5   | 3          | 3 > 2，入栈            | [1,4,5]              |              |                                                | 10           |
| 6   | 0（虚拟）  | 强制清栈，计算剩余柱子 |                      |              |                                                |              |
|     |            | 弹出 5(高 3)           | [1,4]                | 柱子 5(高 3) | 左边界=4，右边界=6<br>宽度=6-4-1=1 → 3×1=3     | 10           |
|     |            | 弹出 4(高 2)           | [1]                  | 柱子 4(高 2) | 左边界=1，右边界=6<br>宽度=6-1-1=4 → 2×4=8     | 10           |
|     |            | 弹出 1(高 1)           | []                   | 柱子 1(高 1) | 左边界=-1，右边界=6<br>宽度=6-(-1)-1=6 → 1×6=6 | 10           |

最终 maxArea = **10**

---

### 关键时刻：面积为 10 是怎么来的？

当 i=4（高度 2）时

我们连续弹出：

1. 先弹出 索引 3（高度 6）：宽度只有 1 → 面积 6
2. 再弹出 索引 2（高度 5）：
   - 左边最近比 5 矮的是 索引 1（高度 1）
   - 右边最近比 5 矮的是 索引 4（高度 2）
   - 所以宽度 = 4 - 1 - 1 = 2
   - 面积 = 5 × 2 = **10**（覆盖了索引 2 和 3 这两根柱子）

这块红色区域就是：

```
    █████
    █████
██  █████   ██
██  █████   ██
██  █████   ██
```

正是题目中画的那个最大矩形！

---

### 总结：每个柱子能拓展到的最大宽度

| 索引 | 高度 | 左边界 | 右边界 | 宽度 | 面积   |
| ---- | ---- | ------ | ------ | ---- | ------ |
| 0    | 2    | -1     | 1      | 1    | 2      |
| 1    | 1    | -1     | 6      | 6    | 6      |
| 2    | 5    | 1      | 4      | 2    | **10** |
| 3    | 6    | 2      | 4      | 1    | 6      |
| 4    | 2    | 1      | 6      | 4    | 8      |
| 5    | 3    | 4      | 6      | 1    | 3      |

最大值就是 10

---

**结论**：  
使用单调栈，我们在 O(n) 时间内精准找到了每一个柱子作为“最小高度”时能拓展的最大宽度，从而算出全局最大矩形面积。

这个例子是理解单调栈解决“柱状图最大矩形”的最佳案例，建议多画几遍，彻底掌握后，类似题目（接雨水、最大矩形等）就都迎刃而解了！
