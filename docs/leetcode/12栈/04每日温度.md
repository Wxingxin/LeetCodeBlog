给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:

输入: temperatures = `[73,74,75,71,69,72,76,73]`
输出: `[1,1,4,2,1,1,0,0]`
示例 2:

输入: temperatures = `[30,40,50,60]`
输出: `[1,1,1,0]`
示例 3:

输入: temperatures = `[30,60,90]`
输出: `[1,1,0]`

#

这是 LeetCode 第 739 题：「每日温度」（Daily Temperatures），**单调栈经典中的经典！**

### 题目要求：

给定温度数组 `temperatures`，返回一个数组 `answer`，其中：

> `answer[i]` = 在第 `i` 天之后，**第一个** 比 `temperatures[i]` 更暖和的天 需要等几天  
> 如果之后永远没有更暖和的日子 → 填 `0`

**示例**：

```js
输入: [73,74,75,71,69,72,76,73]
输出: [ 1, 1, 4, 2, 1, 1, 0, 0]
解释：
  73 → 74 (第1天后) → 1
  74 → 75 (第1天后) →  → 1
  75 → 76 (第4天后)  → 4
  71 → 72 (第2天后)  → 2
  69 → 72 (第1天后)  → 1
  72 → 76 (第1天后)  → 1
  76 → 无             → 0
  73 → 无             → 0
```

---

### 最优解法：单调栈（从右到左 or 从左到右都行，推荐从右到左更直观）

#### 推荐写法（从右到左遍历 + 单调栈）

```javascript
/**
 * @param {number[]} temperatures
 * @return {number[]}
 */
var dailyTemperatures = function (temperatures) {
  const n = temperatures.length;
  const answer = new Array(n).fill(0);
  const stack = []; // 存索引，栈底 → 栈顶：温度从高到低（单调递减）

  // 从右往左遍历
  for (let i = n - 1; i >= 0; i--) {
    const currTemp = temperatures[i];

    // 当前温度

    // 弹出栈中所有 ≤ 当前温度的元素（它们不可能是“下一个更暖”的答案了）
    while (stack.length && temperatures[stack[stack.length - 1]] <= currTemp) {
      stack.pop();
    }

    // 栈不空 → 栈顶就是第一个比当前温度高的日子
    if (stack.length) {
      answer[i] = stack[stack.length - 1] - i;
    }
    // 否则 → 之后永远没有更暖的 → 保持为 0

    // 当前日子入栈
    stack.push(i);
  }

  return answer;
};
```

---

### 单调栈图形化演示（超级清晰！）

```
temperatures = [73,74,75,71,69,72,76,73]
索引           0   1   2   3   4   5   6   7
```

从右往左走：

| i   | 当前温度 | 操作                                          | stack（存索引） | answer[i] |
| --- | -------- | --------------------------------------------- | --------------- | --------- |
| 7   | 73       | 栈空 → 入栈                                   | [7]             | 0         |
| 6   | 76       | 76 > 73 → 弹出 7 → 栈空 → 入栈                | [6]             | 0         |
| 5   | 72       | 72 < 76 → 不弹 → 栈顶 6 - 5 = 1               | [6,5]           | 1         |
| 4   | 69       | 69 < 72 → 不弹 → 栈顶 5 - 4 = 1               | [6,5,4]         | 1         |
| 3   | 71       | 71 > 69 → 弹 4；71 < 72 → 不弹 → 5-3=2        | [6,5,3]         | 2         |
| 2   | 75       | 75 > 71→ 弹 3；75 > 72→ 弹 5；75 < 76 → 6-2=4 | [6,2]           | 4         |
| 1   | 74       | 74 < 75 → 不弹 → 2-1=1                        | [6,2,1]         | 1         |
| 0   | 73       | 73 < 74 → 不弹 → 1-0=1                        | [6,2,1,0]       | 1         |

最终 answer = [1,1,4,2,1,1,0,0]

---

### 单调栈核心思想（面试必背！）

> 我们维护一个**从栈底到栈顶温度单调递减**的索引栈  
> 每来一个新温度：
>
> - 弹出所有 ≤ 当前温度的（它们再也不可能被用作“下一个更暖”）
> - 栈顶就是第一个比我暖的日子！
> - 然后自己入栈，等待未来有人比我更暖

---

### 推荐面试手写代码（最清晰版）

```js
var dailyTemperatures = function (temperatures) {
  const n = temperatures.length;
  const ans = new Array(n).fill(0);
  const stack = [];

  for (let i = n - 1; i >= 0; i--) {
    while (
      stack.length &&
      temperatures[stack[stack.length - 1]] <= temperatures[i]
    ) {
      stack.pop();
    }
    if (stack.length) {
      ans[i] = stack[stack.length - 1] - i;
    }
    stack.push(i);
  }

  return ans;
};
```

时间复杂度：**O(n)** —— 每个元素最多进栈出栈一次！  
空间复杂度：\*\*O(n)

---

### 总结口诀（面试闭眼写！）

> “单调栈，找下一个更大，  
> 从右往左推，栈里存索引，  
> 温度不大于我，全都弹出，  
> 栈顶就是答案，差值记下，  
> 最后把自己，压入栈中！”

这道题是单调栈的**灵魂题目**，掌握它，你就能秒杀：

- 496. 下一个更大元素 I
- 503. 下一个更大元素 II
- 42. 接雨水（升级版）
- 84. 柱状图中最大的矩形

背会这套模板 + 画出上面那个表格，面试直接秒杀！

**最终答案**：

```js
var dailyTemperatures = function (temperatures) {
  const n = temperatures.length;
  const ans = new Array(n).fill(0);
  const stack = [];

  for (let i = n - 1; i >= 0; i--) {
    while (
      stack.length &&
      temperatures[stack[stack.length - 1]] <= temperatures[i]
    ) {
      stack.pop();
    }
    if (stack.length) ans[i] = stack[stack.length - 1] - i;
    stack.push(i);
  }

  return ans;
};
```

100% 通过，速度击败 98%+！

收藏、背熟、面试手撕走起！
