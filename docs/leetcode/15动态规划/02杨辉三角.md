# 题

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

## 示例 1:

输入: `numRows = 5`
输出: `[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]`

## 示例 2:

输入: `numRows = 1`
输出: `[[1]]`

# 解

这是 **LeetCode 118：杨辉三角**，也是一个非常经典、**非常适合练动态规划思维**的题目。

---

## 一、核心思路（动态规划视角）

### 状态定义

- `dp[i][j]`：表示 **第 i 行第 j 个数**（从 0 开始）

### 状态转移

- 每行的 **第一个和最后一个元素一定是 1**
- 其他位置：

```
dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
```

---

## 二、直接可用的 JavaScript 解法（推荐）

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
// 定义一个函数 generate，输入为正整数 numRows，表示需要生成的杨辉三角的行数
// 返回值：一个二维数组，每一行是一个数组，表示杨辉三角的第 i 行（从第 0 行开始）
var generate = function (numRows) {
  // 用于存储最终结果的数组，每一项都是一行杨辉三角
  const result = [];

  // 外层循环：逐行生成，从第 0 行到第 (numRows - 1) 行
  for (let i = 0; i < numRows; i++) {
    // 创建当前行：长度为 i + 1，所有元素先初始化为 1
    // 因为杨辉三角每行的首尾元素永远是 1
    const row = new Array(i + 1).fill(1);

    // 内层循环：计算当前行中间的元素（从第 1 个位置到倒数第 2 个位置）
    // 首尾已经是 1，无需计算
    for (let j = 1; j < i; j++) {
      // 杨辉三角的性质：
      // 当前行第 j 列的元素 = 上一行第 (j-1) 列 + 上一行第 j 列 的和
      row[j] = result[i - 1][j - 1] + result[i - 1][j];
    }

    // 将计算完成的当前行添加到结果中
    result.push(row);
  }

  // 返回完整的杨辉三角
  return result;
};
```

---

## 三、举个例子 🌰

输入：

```js
numRows = 5;
```

输出：

```js
[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]];
```

---

## 四、为什么这是动态规划？

虽然代码里没有显式写 `dp` 变量，但本质上：

```js
result[i][j] === dp[i][j];
```

满足 DP 的三要素：

1. ✅ **状态定义**：每个位置的值
2. ✅ **状态转移**：由上一行两个值相加
3. ✅ **子问题复用**：第 i 行依赖第 i-1 行

👉 和你刚才问的「爬楼梯没看到 dp」是 **同一个思想**

---

## 五、时间 & 空间复杂度

- **时间复杂度**：`O(numRows²)`
- **空间复杂度**：`O(numRows²)`（必须存所有行作为结果）

> ⚠️ 这里**不能像爬楼梯那样压缩到 O(1)**
> 因为题目要求返回 **整个三角形**

---

## 六、如果你想进一步进阶 🚀

我可以继续帮你：

- 改成 **只计算第 k 行（LeetCode 119）**
- 用 **一维数组** 实现状态压缩
- 从 **组合数学** 角度解释为什么是这样

你已经在用「DP 思维」看问题了，这是非常好的信号 👏
