# 题
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

## 示例 1：

输入：`n = 2`
输出：`2`
解释：有两种方法可以爬到楼顶。
`1. 1 阶 + 1 阶`
`2. 2 阶`
## 示例 2：

输入：`n = 3`
输出：`3`
解释：有三种方法可以爬到楼顶。
`1. 1 阶 + 1 阶 + 1 阶`
`2. 1 阶 + 2 阶`
`3. 2 阶 + 1 阶`

# 解

这是一个**非常好的问题**，说明你已经真正理解并开始“质疑”动态规划的形式了 👍
结论先给出：

> **动态规划不一定非要写成 `dp` 数组的形式**
> 你看到的解法是 **“动态规划 + 空间优化”** 版本。

下面一步步解释。

---

## 一、什么才算「动态规划」？

**动态规划的本质只有三点：**

1. ✅ **有状态定义**（状态表示什么）
2. ✅ **有状态转移方程**
3. ✅ **利用子问题结果，避免重复计算**

**是否写 `dp` 数组只是“表现形式”，不是本质。**

---

## 二、先看「你期待的 dp 写法」

这是最标准、最“教科书式”的 DP：

```js
// 定义一个函数 climbStairs，输入为正整数 n，表示楼梯的总阶数
// 返回值：爬到第 n 阶楼梯的不同方法数
var climbStairs = function(n) {
    // 基础情况：
    // 如果楼梯只有 1 阶，只有 1 种爬法
    // 如果楼梯只有 2 阶，有 2 种爬法（1+1 或 直接 2）
    // 因此当 n <= 2 时，直接返回 n 本身
    if (n <= 2) return n;

    // 创建一个长度为 n+1 的数组 dp，用于存储每个阶梯的方法数
    // dp[i] 表示爬到第 i 阶楼梯的方法数
    const dp = new Array(n + 1);

    // 初始化前两个状态
    dp[1] = 1;  // 爬到第 1 阶只有 1 种方法
    dp[2] = 2;  // 爬到第 2 阶有 2 种方法

    // 从第 3 阶开始递推计算
    // 根据题意：每次可以爬 1 阶或 2 阶
    // 所以爬到第 i 阶的方法数 = 爬到第 i-1 阶后爬 1 阶 + 爬到第 i-2 阶后爬 2 阶
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];  // 状态转移方程
    }

    // 返回爬到第 n 阶的方法数
    return dp[n];
};
```

这里非常直观：

* `dp[i]` = 爬到第 `i` 阶的方法数
* 转移方程：`dp[i] = dp[i-1] + dp[i-2]`

✅ **这是你脑海中“动态规划该有的样子”**

---

## 三、那为什么最终解法里「看不到 dp」？

再看优化后的版本：

```js
let prev1 = 1; // f(1)
let prev2 = 2; // f(2)
```

它其实等价于：

```js
prev1 === dp[i - 2]
prev2 === dp[i - 1]
```

也就是说：

| dp数组版本      | 空间优化版本    |
| ----------- | --------- |
| `dp[i - 2]` | `prev1`   |
| `dp[i - 1]` | `prev2`   |
| `dp[i]`     | `current` |

⚠️ **dp 并没有消失，而是被“压缩”成了几个变量**

---

## 四、为什么可以这样优化？

因为这个状态转移：

```
dp[i] = dp[i - 1] + dp[i - 2]
```

👉 **只依赖前两个状态**

所以：

* 不需要保存整个 `dp[0...n]`
* 只要保存「最近的两个结果」即可

这叫：

> **空间复杂度优化（Rolling Array / 状态压缩）**

---

## 五、重要结论（一定要记住）

### ❌ 错误认知

> 没有 `dp` 数组 ≠ 不是动态规划

### ✅ 正确认知

> **是否是动态规划，看“思想”，不看“变量名”**

只要满足：

* 有状态
* 有转移
* 利用子问题

➡️ 就是 DP

---

## 六、给你一个判断 DP 的小技巧 🧠

问自己三个问题：

1. **这个问题能不能拆成更小的同类问题？**
2. **结果是否可以复用？**
3. **是否存在明确的递推关系？**

如果答案是「是」——
👉 那它就是动态规划

---

## 七、总结一句话（面试可用）

> “`dp` 数组只是动态规划的一种实现方式，当状态只依赖有限的前几个值时，可以用变量进行空间优化，本质仍然是动态规划。”

---

如果你愿意，我可以帮你：

* 对比 **递归 / 记忆化 / dp / 空间优化 dp** 四种写法
* 教你 **如何一眼判断 DP 能不能压缩空间**
* 讲 **哪些 DP 绝对不能压缩**

继续问，我陪你把 DP 打透 💪
