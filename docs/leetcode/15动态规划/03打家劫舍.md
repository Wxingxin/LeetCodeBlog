# 题

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

## 示例 1：

输入：`[1,2,3,1]`

输出：`4`

解释：偷窃 `1` 号房屋 (金额 = `1`) ，然后偷窃 `3` 号房屋 (金额 = `3`)。
偷窃到的最高金额 `= 1 + 3 = 4`。

## 示例 2：

输入：`[2,7,9,3,1]`
输出：`12`
解释：偷窃 `1` 号房屋 (金额 = `2`), 偷窃 `3` 号房屋 (金额 = `9`)，接着偷窃 `5` 号房屋 (金额 = 1)。
偷窃到的最高金额 `= 2 + 9 + 1 = 12` 。

# 解

下面我就用 **打家劫舍 nums = [1,2,3,1]** 这个案例，把 **dp 数组解法**从“定义状态 → 写转移 → 初始化 → 填表过程”完整走一遍（非常细）。

---

## 1) 为什么要用 dp？

因为你在每一间房都会面临同样的选择：

- 偷这间（那相邻的就不能偷）
- 不偷这间（那就看前面最优）

而且 “到第 i 间为止的最优结果” 会被后面反复用到 → 适合 DP。

---

## 2) 状态定义（dp 是什么）

令：

> `dp[i]` 表示：**从第 0 间房到第 i 间房（包含 i），在不触发警报的前提下能偷到的最大金额**

注意：`dp[i]` 是“前 i 间的最优解”，不是“必须偷第 i 间”。

---

## 3) 状态转移（dp 怎么来）

站在第 `i` 间房，你只有两条路：

### A. 不偷第 i 间

那最大金额就是：

- `dp[i-1]`（前 i-1 间的最优）

### B. 偷第 i 间

因为相邻不能偷，所以第 i-1 间一定不能偷。
那最大金额就是：

- `dp[i-2] + nums[i]`

所以转移方程：

[
dp[i] = \max(dp[i-1], \ dp[i-2] + nums[i])
]

---

## 4) 初始化（边界条件）

如果数组是 `nums = [1,2,3,1]`

- `dp[0]`：只有第 0 间房可选，最多偷 `nums[0]`

  - `dp[0] = 1`

- `dp[1]`：有第 0、1 两间，但不能都偷，只能选更大的

  - `dp[1] = max(nums[0], nums[1]) = max(1,2) = 2`

---

## 5) 开始“填表”（一步一步算）

我们把 `nums` 和 `dp` 列出来：

- `nums` 下标： 0 1 2 3
- `nums` 金额： 1 2 3 1

我们要算 `dp[0..3]`

### i = 0

- `dp[0] = 1`
  解释：只有一间房，偷它就是 1

### i = 1

- `dp[1] = max(1,2) = 2`
  解释：两间相邻，只能选金额更大的那间（偷第 1 间）

---

### i = 2（关键！开始用公式）

按转移方程：

- 不偷第 2 间：`dp[1] = 2`
- 偷第 2 间：`dp[0] + nums[2] = 1 + 3 = 4`

取最大：

- `dp[2] = max(2,4) = 4`

解释：最优策略是偷第 0 间 + 第 2 间 → 1 + 3 = 4

---

### i = 3

- 不偷第 3 间：`dp[2] = 4`
- 偷第 3 间：`dp[1] + nums[3] = 2 + 1 = 3`

取最大：

- `dp[3] = max(4,3) = 4`

解释：偷第 3 间反而变少，所以保持之前最优（偷 0 和 2）。

---

## 6) 最终 dp 表

`dp = [1, 2, 4, 4]`

答案就是 `dp[n-1] = dp[3] = 4`

---

## 7) dp 数组写法（最直观）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
// 定义一个函数 rob，输入是一个非负整数数组 nums，表示一排房子的金钱数量
// 规则：不能抢相邻的房子（抢了 i 就不能抢 i-1 和 i+1）
// 返回值：能抢到的最大金钱总数
var rob = function (nums) {
  // 获取房子数量
  const n = nums.length;

  // 边界情况处理
  if (n === 0) return 0; // 没有房子，返回 0
  if (n === 1) return nums[0]; // 只有一个房子，直接抢它

  // 创建 dp 数组，dp[i] 表示抢前 i+1 个房子（索引 0 到 i）能得到的最大金额
  const dp = new Array(n).fill(0);

  // 初始化前两个状态
  dp[0] = nums[0]; // 只抢第一个房子
  dp[1] = Math.max(nums[0], nums[1]); // 前两个房子取金额较大的那一个

  // 从第 3 个房子（索引 2）开始递推
  for (let i = 2; i < n; i++) {
    // 状态转移方程：
    // dp[i] 有两种选择：
    // 1. 不抢当前房子：最大金额等于 dp[i-1]
    // 2. 抢当前房子：则不能抢前一个房子，最大金额等于 dp[i-2] + nums[i]
    // 取这两种选择的较大值
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
  }

  // 返回抢完所有房子的最大金额
  return dp[n - 1];
};
```

---

## 8) 一句话把这个 DP “说人话”

> 每走到一间房，我都问自己：
> “偷它？那就加上两间前的最优；不偷它？那就继承前一间的最优。取更大的。”

---

如果你愿意，我还可以把这个例子再拓展成：

- 如何从 dp 倒推“到底偷了哪几间房”
- 以及为什么空间优化版只需要两个变量（prev1/prev2）就够了
