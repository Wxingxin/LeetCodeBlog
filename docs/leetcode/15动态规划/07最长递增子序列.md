# 题

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

## 示例 1：

输入：`nums = [10,9,2,5,3,7,101,18]`
输出：`4`
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

## 示例 2：

输入：`nums = [0,1,0,3,2,3]`
输出：`4`

## 示例 3：

输入：`nums = [7,7,7,7,7,7,7]`
输出：`1`

# 解

下面我**只用 DP 解法（O(n²)）**，并且**把“代码 ⇄ dp 表 ⇄ 示例数据”三者一一对应起来**，让你能清楚看到：
👉 **每一行代码在“改哪一个 dp 值”，为什么这样改。**

我们用示例 1 来讲：

```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```

---

## 一、dp 的含义（这是理解代码的钥匙 🔑）

```js
dp[i];
```

表示：

> **以 nums[i] 结尾的最长「严格递增」子序列的长度**

⚠️ 注意：

- 是 **以 i 结尾**
- 不一定是全局最优，只是“到 i 为止的局部最优”

---

## 二、代码整体结构（先看骨架）

```js
// 定义一个函数 lengthOfLIS
// 参数：nums - 一个整数数组
// 返回值：数组中最长严格递增子序列的长度（子序列元素不必连续）
var lengthOfLIS = function (nums) {
  const n = nums.length; // 数组长度
  if (n === 0) return 0; // 可选：边界处理（原代码未写，但实际运行时 n>=1）

  // dp[i] 表示：以 nums[i] 结尾的最长递增子序列的长度
  // 初始化所有位置为 1，因为每个单个元素本身就是一个长度为 1 的递增子序列  ←①
  const dp = new Array(n).fill(1);

  let ans = 1; // 记录全局最长的递增子序列长度，至少为 1

  // 外层循环：遍历每个位置 i（从左到右）
  for (let i = 0; i < n; i++) {
    // ←②

    // 内层循环：检查 i 之前的所有位置 j（0 到 i-1）
    for (let j = 0; j < i; j++) {
      // ←③

      // 只有当前面的元素 nums[j] 严格小于当前元素 nums[i] 时，
      // 才有可能把 nums[i] 接在以 nums[j] 结尾的序列后面
      if (nums[j] < nums[i]) {
        // ←④

        // 更新 dp[i]：
        // 可能性1：不接任何前面的序列，仍为 1（初始值）
        // 可能性2：接在以 nums[j] 结尾的序列后面，长度变为 dp[j] + 1
        // 取所有可能中的最大值                                 ←⑤
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }

    // 更新全局答案：以当前 nums[i] 结尾的最长序列长度可能刷新了全局最大值  ←⑥
    ans = Math.max(ans, dp[i]);
  }

  // 返回整个数组中最长的严格递增子序列长度
  return ans;
};
```

下面我们**逐行 + 结合示例**解释。

---

## 三、① 初始化：为什么 dp 全是 1？

```js
const dp = new Array(n).fill(1);
```

含义：

> 每个数 **单独拿出来**，都可以构成一个长度为 1 的递增子序列

对应示例：

```
nums: 10  9  2  5  3  7  101  18
dp:    1  1  1  1  1  1   1    1
```

---

## 四、② 外层循环 i：当前“结尾”位置

```js
for (let i = 0; i < n; i++)
```

含义：

> 现在我要计算：**以 nums[i] 结尾的 LIS 最长是多少**

也就是：
👉 **我把 nums[i] 当成“最后一个数”**

---

## 五、③ 内层循环 j：尝试接在谁后面

```js
for (let j = 0; j < i; j++)
```

含义：

> 枚举所有在 i 之前的位置 j
> 看能不能把 nums[i] 接在 nums[j] 后面

---

## 六、④ 判断条件：能不能递增

```js
if (nums[j] < nums[i])
```

含义：

> 只有当 `nums[j] < nums[i]`
> 才能形成「严格递增」

例如：

- i = 3，nums[i] = 5
- j = 2，nums[j] = 2 ✅ 可以接
- j = 0，nums[j] = 10 ❌ 不行

---

## 七、⑤ 核心转移：dp[i] 从哪来？

```js
dp[i] = Math.max(dp[i], dp[j] + 1);
```

这是整题的灵魂 👇

含义翻译成人话：

> 如果我把 nums[i] 接在 nums[j] 后面
> 那么：
>
> - 以 j 结尾的 LIS 长度是 `dp[j]`
> - 接上 nums[i] 后长度变成 `dp[j] + 1`
> - 我选择所有可能方案里的最大值

---

## 八、结合示例：完整走一轮关键过程

### i = 2，nums[i] = 2

- 前面：10, 9 都比 2 大
- 没有 nums[j] < nums[i]

```js
dp[2] = 1;
```

---

### i = 3，nums[i] = 5

可接的位置：

| j   | nums[j] | dp[j] | 是否可接 |
| --- | ------- | ----- | -------- |
| 0   | 10      | 1     | ❌       |
| 1   | 9       | 1     | ❌       |
| 2   | 2       | 1     | ✅       |

```js
dp[3] = dp[2] + 1 = 2
```

代表子序列：

```
[2, 5]
```

---

### i = 5，nums[i] = 7

可接的位置：

- 2 → [2]
- 5 → [2,5]
- 3 → [2,3]

最优是接 `[2,3]`：

```js
dp[5] = 3;
```

代表：

```
[2,3,7]
```

---

### i = 6，nums[i] = 101

可以接在前面任何更小的数后面
最优是：

```
[2,3,7,101]
```

```js
dp[6] = 4;
```

---

## 九、⑥ 为什么要单独维护 ans？

```js
ans = Math.max(ans, dp[i]);
```

因为：

> LIS **不一定以最后一个元素结尾**

例如：

```
[1,2,3,0]
```

最长递增子序列是 `[1,2,3]`，结尾不是最后一个元素。

所以要在所有 `dp[i]` 中取最大。

---

## 十、最终 dp 表（示例 1）

```
nums: 10  9  2  5  3  7  101  18
dp:    1  1  1  2  2  3   4    4
```

答案 = max(dp) = **4**

---

## 十一、一句话总结（代码 ⇄ 思想）

> 外层 i：我当结尾
> 内层 j：我找前驱
> 条件判断：能不能递增
> dp 转移：接上去长度 +1
> 全局答案：所有结尾中取最大

---

如果你愿意，下一步我可以：

- 帮你 **画出 LIS 的“接龙过程图”**
- 或对比 **为什么这个 DP 能做，而子串问题就不行**
- 或继续讲 **如何从 dp 反推具体序列**

你现在这个问题，已经是 **真正理解 DP 的层级了** 👍
