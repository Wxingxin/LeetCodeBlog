# 题

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。

左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 "(()())"。

示例 1：

输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
示例 2：

输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
示例 3：

输入：s = ""
输出：0

# 解

这题（LeetCode 32）经典而且很“坑”，我用 **DP 解法**给你讲清楚：状态怎么定义、为什么这样转移、再给完整 JS 代码，并用例子手推一遍。

---

## DP 核心定义

令：

> `dp[i]` 表示：**以 `s[i]` 这个字符结尾的最长有效括号子串长度**

注意两个关键词：

- **必须连续**
- **必须以 i 结尾**（这点决定了转移方式）

显然：

- 如果 `s[i]` 是 `'('`，那不可能结尾形成有效括号 → `dp[i] = 0`
- 只有当 `s[i]` 是 `')'` 时才可能有值

---

## 状态转移（最关键）

当 `s[i] === ')'`，分两种情况：

### 情况 1：`...()` 直接配对

如果前一个字符是 `'('`，即 `s[i-1] === '('`
那么 `s[i-1..i]` 就是 `"()"`

此时：

- `dp[i] = dp[i-2] + 2`
- `dp[i-2]` 是为了把 `"()"` 前面那段有效括号拼上
- 注意 i-2 越界时当作 0

公式：

```
dp[i] = (i >= 2 ? dp[i-2] : 0) + 2
```

---

### 情况 2：`...))` 需要“跨越”去找匹配的 '('

如果 `s[i-1] === ')'`，比如 `"(...))"`
那么我们先看 `dp[i-1]`：它是以 i-1 结尾的最长有效长度。

设：

- `len = dp[i-1]`
- 那么有效段是 `s[i-len .. i-1]`
- 我们希望 `s[i-len-1]` 是 `'('` 来和 `s[i]` 这个 `')'` 配对

所以检查位置：

```
j = i - dp[i-1] - 1
```

如果 `j >= 0` 且 `s[j] === '('`，说明能闭合：

- 先加上当前配对的 `2`
- 再加上里面的 `dp[i-1]`
- 还要把 j 前面那段有效括号拼上：`dp[j-1]`

公式：

```
dp[i] = dp[i-1] + 2 + (j >= 1 ? dp[j-1] : 0)
```

---

## 完整 JS 代码（DP）

```js
/**
 * @param {string} s 只包含 '(' 和 ')' 的字符串
 * @return {number} 返回最长有效括号子串的长度
 */
var longestValidParentheses = function (s) {
  const n = s.length;
  // dp[i] 表示：以 s[i] 结尾的最长有效括号子串的长度
  // 初始化全为 0，因为单个字符不可能构成有效括号
  const dp = new Array(n).fill(0);

  let ans = 0; // 记录全局最长的有效括号长度

  // 从索引 1 开始遍历（因为需要看前面的字符）
  for (let i = 1; i < n; i++) {
    // 只有当前字符是 ')' 时，才有可能形成有效括号
    if (s[i] === ")") {
      // 情况1：形如 "...()" —— 当前 ) 和前一个 ( 直接匹配
      if (s[i - 1] === "(") {
        // 匹配成功，长度 +2
        // 再加上 i-2 位置之前已经有效的部分（如果存在）
        dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
      }

      // 情况2：形如 "...))" —— 当前 ) 可能与更前面的 ( 匹配
      // 例如：()(())   或   (()())
      else if (s[i - 1] === ")") {
        // 前一个也是 )，说明前面可能有连续的有效括号
        // 计算可能与当前 ) 匹配的那个 ( 的位置
        // i - dp[i-1] - 1：跳过前面的有效括号段，再往前一个位置
        const j = i - dp[i - 1] - 1;

        // 如果这个位置存在且确实是 '('，则可以匹配
        if (j >= 0 && s[j] === "(") {
          // 当前匹配成功：+2
          // 加上前面连续的有效段：dp[i-1]
          // 再加上这个 ( 前面可能已经有的有效段：dp[j-1]
          dp[i] = dp[i - 1] + 2 + (j >= 1 ? dp[j - 1] : 0);
        }
      }

      // 更新全局最大长度
      ans = Math.max(ans, dp[i]);
    }
    // 如果 s[i] 是 '('，dp[i] 保持为 0（无法以 ( 结尾形成有效括号）
  }

  return ans;
};
```

---

## 用示例 2 手推（`)()())`）

`s = ")()())"`
下标：0 1 2 3 4 5
字符：) ( ) ( ) )

`dp` 初始全 0，ans=0

- i=2，s[2]=')'，s[1]='(' → 情况 1
  dp[2] = dp[0] + 2 = 2
  ans=2

- i=4，s[4]=')'，s[3]='(' → 情况 1
  dp[4] = dp[2] + 2 = 4
  ans=4

- i=5，s[5]=')'，s[4]=')' → 情况 2
  j = 5 - dp[4] - 1 = 5 - 4 - 1 = 0
  s[0]=')' 不是 '(' → dp[5]=0
  ans 仍为 4

最终 ans=4 ✅（对应 "()()"）

---

## 为什么这个 DP 很妙？

因为“连续子串”要求非常强：
你不能随便匹配，需要确保**以 i 结尾**时，能把前面的有效段“拼接起来”，DP 才能稳定递推。

---

如果你也想掌握这题的另一个更常用解法（**栈 + 哨兵下标**，写起来更短且更直观），我也可以给你并对比两者优缺点。
