# 题

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

## 示例 1：

输入: `s = "leetcode", wordDict = ["leet", "code"]`
输出: `true`
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

## 示例 2：

输入: `s = "applepenapple", wordDict = ["apple", "pen"]`
输出: `true`
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
注意，你可以重复使用字典中的单词。

## 示例 3：

输入: `s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]`
输出: `false`

# 解

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
// 定义一个函数 wordBreak
// 参数：
//   s        - 字符串，需要判断是否能被拆分成字典中的单词
//   wordDict - 数组，包含所有允许使用的单词（无重复）
// 返回值：布尔值，true 表示可以拆分，false 表示不能
var wordBreak = function (s, wordDict) {
  // 将 wordDict 转为 Set，便于 O(1) 时间复杂度查找单词是否存在
  const dict = new Set(wordDict);
  const n = s.length; // 字符串长度

  // 计算字典中最长的单词长度，用于后续剪枝优化
  // 这样在检查子串时，不需要从 i 往前检查所有位置，只需检查最近的 maxLen 个位置
  let maxLen = 0;
  for (const w of wordDict) {
    maxLen = Math.max(maxLen, w.length);
  }

  // dp[i] 表示：字符串 s 的前 i 个字符（即 s[0...i-1]）能否被完美拆分成字典中的单词
  // dp[0] = true 表示空字符串可以被拆分（基础情况）
  const dp = new Array(n + 1).fill(false);
  dp[0] = true;

  // 外层循环：从长度 1 到长度 n 依次判断前缀能否拆分
  for (let i = 1; i <= n; i++) {
    // 内层循环：检查以 i 结尾的所有可能单词（起点 j）
    // j 从 Math.max(0, i - maxLen) 开始，避免检查过长的子串（剪枝优化）
    for (let j = Math.max(0, i - maxLen); j < i; j++) {
      // 条件：
      // 1. dp[j] 为 true：表示 s[0...j-1] 已经可以被拆分
      // 2. s.substring(j, i) 在字典中：表示 s[j...i-1] 是一个合法单词
      if (dp[j] && dict.has(s.substring(j, i))) {
        dp[i] = true;
        break; // 一旦找到一种可行的拆分方式，就可以停止内层循环
      }
    }
  }

  // dp[n] 表示整个字符串 s 是否能被拆分
  return dp[n];
};
```

下面用 **DP（动态规划）**把「单词拆分 Word Break」讲清楚：状态怎么定义、怎么转移、代码怎么写、并结合 3 个示例手推一遍你就会非常稳。

---

## 1) DP 状态定义

令：

> `dp[i]` 表示：**s 的前 i 个字符（即 s[0..i-1]）能否被字典拼出来**

- `dp[0] = true`：空字符串可以被“拼出来”（什么都不选）
- 我们最终要的是 `dp[n]`，其中 `n = s.length`

---

## 2) 状态转移（核心）

要让 `dp[i] = true`，必须存在一个切分点 `j`（0 ≤ j < i）满足：

1. `dp[j] == true`（前 j 个字符能拼出来）
2. `s[j..i-1]` 这个子串在字典里

即：

[
dp[i] = \exists j \in [0,i): dp[j] \land (s[j..i-1] \in dict)
]

直观理解：
**如果前半段能拼，且后半段刚好是一个字典单词，那么整体就能拼。**

---

## 3) 代码实现（JS，推荐写法）

优化点：

- `wordDict` 用 `Set` 加速查找 O(1)
- 用 `maxLen` 限制枚举范围（否则会多做很多无用 substring）

---

## 4) 结合示例 1 手推：s = "leetcode", dict = ["leet","code"]

n = 8
我们关注关键 i：

- `dp[0]=true`

### i=4

检查 j=0：

- dp[0]=true 且 s[0..3]="leet" 在 dict
  → `dp[4]=true`

### i=8

检查 j=4：

- dp[4]=true 且 s[4..7]="code" 在 dict
  → `dp[8]=true`

最终 `dp[8]=true` ✅

---

## 5) 示例 2：s="applepenapple", dict=["apple","pen"]

关键点：

- `dp[5]=true` 因为 "apple"
- `dp[8]=true` 因为 dp[5] + "pen"
- `dp[13]=true` 因为 dp[8] + "apple"

所以可以重复使用单词，DP 也自然支持（因为 dp 只看“能不能拼出前缀”）。

最终 true ✅

---

## 6) 示例 3：s="catsandog", dict=["cats","dog","sand","and","cat"]

你会出现一些“看起来快成功”的 dp：

- `dp[3]=true`（"cat"）
- `dp[4]=true`（"cats"）
- `dp[7]=true`（"cats"+"and" 或 "cat"+"sand"）

但最后要到 `dp[9]`（整个串）：

- 剩余会卡在 `"og"` 这段，字典里没有
- 所以 `dp[9]` 变不成 true

最终 false ✅

---

## 7) 你应该抓住的直觉

> dp[i] 是在问：**“到这里为止能不能被合法切分？”**
> 如果能，下一段只要切出一个字典单词，就能把 true 往后“传递”。

---

如果你愿意，我还可以再补两点实战技巧：

1. 这题的 **BFS 解法**（像最短路一样扩展下标，很多人觉得更直观）
2. 如何在 DP 为 true 时 **恢复具体切分方案**（输出 “leet code” 这种路径）
