# 题

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

## 示例 1：

输入：`nums = [1,5,11,5]`
输出：`true`
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

## 示例 2：

输入：`nums = [1,2,3,5]`
输出：`false`
解释：数组不能分割成两个元素和相等的子集。

# 解

下面用 **DP（0/1 背包）**给你把「分割等和子集」讲透：**思路 → dp 含义 → 为什么这么写 → 结合示例手推 → 带详细注释代码**。

---

## 1) 关键转化

要把数组分成两个和相等的子集：

- 设总和 `sum`
- 必须 `sum` 是偶数，否则不可能（直接 false）
- 目标变成：能否从 nums 中选一些数，使它们的和 **恰好等于** `target = sum / 2`

这就是典型 **0/1 背包的“能否装满”问题**（每个数只能用一次）。

---

## 2) DP 定义（最常用的一维写法）

令：

> `dp[j]` 表示：是否能选出一些数，使得和为 `j`

初始化：

- `dp[0] = true`（不选任何数就能凑出 0）

转移（处理一个数 `x`）：

- 如果之前能凑出 `j-x`，那么加上 `x` 就能凑出 `j`
- `dp[j] = dp[j] || dp[j-x]`

⚠️ 内层 `j` 必须 **从大到小** 遍历（0/1 背包关键点）

- 否则会把同一个数用多次（变成完全背包）

---

## 3) 代码（JS，详细注释版）

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function (nums) {
  // 1) 计算总和
  let sum = 0;
  for (const x of nums) sum += x;

  // 2) 总和为奇数，不可能平分
  if (sum % 2 !== 0) return false;

  const target = sum / 2;

  // 3) dp[j]：是否能凑出和为 j
  const dp = new Array(target + 1).fill(false);
  dp[0] = true; // 凑出 0 一定可行（什么都不选）

  // 4) 0/1 背包：每个数只能用一次
  for (const x of nums) {
    // 必须从 target 往下遍历，避免一个数被重复使用
    for (let j = target; j >= x; j--) {
      // 不选 x：dp[j] 保持原样
      // 选 x：如果 dp[j-x] 为真，则 dp[j] 可为真
      dp[j] = dp[j] || dp[j - x];
    }
    // 小优化：如果已经能凑出 target，可以提前结束
    if (dp[target]) return true;
  }

  return dp[target];
};
```

---

## 4) 结合案例 1 手推：nums = [1,5,11,5]

### 第一步：算 target

- sum = 1 + 5 + 11 + 5 = 22
- target = 11

我们关心最终 `dp[11]` 是否能变成 true。

初始化：

- `dp[0]=true`，其他全 false

---

### 处理 x = 1

从 j=11..1：

- dp[1] = dp[1] || dp[0] = true

此时能凑出的和：`{0,1}`

---

### 处理 x = 5

从 j=11..5：

- dp[5] = dp[5] || dp[0] = true
- dp[6] = dp[6] || dp[1] = true（1+5）

能凑出的和：`{0,1,5,6}`

---

### 处理 x = 11

从 j=11..11：

- dp[11] = dp[11] || dp[0] = true

✅ 直接凑出 target=11（选 [11]）
所以返回 true。

> 这也对应题目解释：[11] 和 [1,5,5] 两边都是 11。

---

## 5) 结合案例 2：nums = [1,2,3,5]

- sum = 1+2+3+5 = 11（奇数）
- 不能平分，直接返回 false ✅

---

## 6) 为什么 j 要倒序？（超重要）

假设正序遍历（错误）：

- 处理 x=5 时，先让 dp[5]=true（用了一次 5）
- 接着 j=10 时，dp[10] 会用 dp[5] 推出来
- 这相当于同一个 5 被用了两次（变成“硬币无限”那类问题）

倒序遍历能保证：

- 当前数 x 只会影响“更大的 j”
- 不会在同一轮里重复使用 x

---

如果你希望更直观，我也可以把案例 1 的 `dp` 每处理一个数后“变为 true 的下标集合”完整列出来，让你一眼看到 `{0}->{0,1}->{0,1,5,6}->...` 是怎么扩张到 11 的。
