#

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

## 示例 1：

输入：`n = 12`
输出：`3 `
解释：`12 = 4 + 4 + 4`

## 示例 2：

输入：`n = 13`
输出：`2`
解释：`13 = 4 + 9`

#

```js
/**
 * @param {number} n
 * @return {number}
 */
// 定义一个函数 numSquares，输入为正整数 n
// 问题：给定正整数 n，找到最少的完全平方数（1, 4, 9, 16, ...）的个数，它们的和等于 n
// 返回值：最少的完全平方数个数
var numSquares = function (n) {
  // 创建 dp 数组，dp[i] 表示组成数字 i 所需的最少完全平方数个数
  // 初始化为 Infinity，表示初始时认为无法组成（后面会更新为实际最小值）
  // 长度为 n+1，便于索引从 0 到 n
  const dp = new Array(n + 1).fill(Infinity);

  // 基础情况：组成 0 需要的平方数个数为 0（什么都不选）
  dp[0] = 0;

  // 外层循环：依次计算 dp[1] 到 dp[n]
  for (let i = 1; i <= n; i++) {
    // 内层循环：枚举所有可能的完全平方数 j*j（j 从 1 开始，只要 j*j <= i）
    for (let j = 1; j * j <= i; j++) {
      // 状态转移方程：
      // 用一个平方数 j*j 加上剩余的 (i - j*j)
      // 组成 i 所需的个数 = 组成 (i - j*j) 所需的个数 + 1
      // 在所有可能的 j 中取最小值
      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
    }
  }

  // 返回组成 n 所需的最少完全平方数个数
  return dp[n];
};
```

---

## 1) DP 的状态定义

令：

> `dp[i]` 表示：**凑出和为 i 的完全平方数的最少数量**

比如：

- `dp[0]=0`（凑 0 不需要任何数）
- `dp[12]=3` 表示凑 12 最少用 3 个平方数

---

## 2) 可选“物品”（完全平方数）

对 `n` 来说，可用的平方数是：

[
1^2, 2^2, 3^2, \dots, k^2 \ \ (k^2 \le n)
]

- 当 `n=12`，可用：`1,4,9`
- 当 `n=13`，可用：`1,4,9`

---

## 3) 状态转移方程（最关键）

要算 `dp[i]`，最后一步可以选一个平方数 `j*j`：

- 如果最后选了 `j*j`，那前面必须先凑出 `i - j*j`
- 所以候选值是：`dp[i - j*j] + 1`

对所有 `j*j <= i` 取最小：

[
dp[i] = \min\_{j^2 \le i}(dp[i - j^2] + 1)
]

---

## 4) 初始化（避免错误）

- `dp[0] = 0`
- 其它 `dp[i] = Infinity`（表示还没算出最优，先给一个极大值）

---

## 5) 结合案例手推：n = 12

我们从 `i=1` 算到 `12`（每次只用已经算好的更小的 dp 值）。

可用平方数：`1,4,9`

我把关键步骤列出来（每个 i 都尝试减去 1/4/9）：

### i = 1

- 用 1：`dp[1] = dp[0] + 1 = 1`
  ✅ dp[1]=1

### i = 2

- 用 1：`dp[2] = dp[1] + 1 = 2`
  ✅ dp[2]=2（1+1）

### i = 3

- 用 1：`dp[3] = dp[2] + 1 = 3`
  ✅ dp[3]=3（1+1+1）

### i = 4

- 用 1：候选 `dp[3]+1 = 4`
- 用 4：候选 `dp[0]+1 = 1` ← 更好
  ✅ dp[4]=1（4）

### i = 5

- 用 1：`dp[4]+1 = 2`
- 用 4：`dp[1]+1 = 2`
  ✅ dp[5]=2（4+1）

### i = 6

- 用 1：`dp[5]+1 = 3`
- 用 4：`dp[2]+1 = 3`
  ✅ dp[6]=3（4+1+1）

### i = 7

- 用 1：`dp[6]+1 = 4`
- 用 4：`dp[3]+1 = 4`
  ✅ dp[7]=4

### i = 8

- 用 1：`dp[7]+1 = 5`
- 用 4：`dp[4]+1 = 2` ← 更好（4+4）
  ✅ dp[8]=2

### i = 9

- 用 1：`dp[8]+1 = 3`
- 用 4：`dp[5]+1 = 3`
- 用 9：`dp[0]+1 = 1` ← 最好
  ✅ dp[9]=1（9）

### i = 10

- 用 1：`dp[9]+1 = 2` ←（9+1）
- 用 4：`dp[6]+1 = 4`
- 用 9：`dp[1]+1 = 2`
  ✅ dp[10]=2

### i = 11

- 用 1：`dp[10]+1 = 3`
- 用 4：`dp[7]+1 = 5`
- 用 9：`dp[2]+1 = 3`
  ✅ dp[11]=3

### i = 12（你关心的）

- 用 1：`dp[11]+1 = 4`
- 用 4：`dp[8]+1 = 2+1 = 3` ←（4+4+4）
- 用 9：`dp[3]+1 = 3+1 = 4`
  ✅ dp[12] = 3

所以答案：**12 = 4 + 4 + 4**，最少 **3** 个。

---

## 6) 结合案例手推：n = 13

我们只看最后一步（因为前面 dp[0..12] 已经有了）：

### i = 13

- 用 1：`dp[12]+1 = 3+1 = 4`
- 用 4：`dp[9]+1 = 1+1 = 2` ←（9+4）
- 用 9：`dp[4]+1 = 1+1 = 2`
  ✅ dp[13] = 2

答案：**13 = 9 + 4**，最少 **2** 个。

---

## 7) 对应 JS 代码（dp 版本）

---

如果你想更像“背包题”的写法（**先遍历平方数，再遍历容量**，更便于迁移到完全背包模板），我也可以给那版，并解释两种循环顺序的差别和适用场景。
