# 题

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

## 示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1

## 示例 2：

输入：coins = [2], amount = 3
输出：-1

## 示例 3：

输入：coins = [1], amount = 0
输出：0

#

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
// 定义一个函数 coinChange
// 参数：
//   coins  - 数组，表示可用的硬币面额（每个面额可以重复使用）
//   amount - 正整数，表示需要兑换的总金额
// 返回值：组成 amount 最少的硬币个数；如果无法凑出，返回 -1
var coinChange = function (coins, amount) {
  // dp[i] 表示凑出金额 i 所需的最少硬币数量
  // 初始化为 Infinity，表示初始时认为无法凑出
  // 长度为 amount + 1，方便从 0 到 amount 进行索引
  const dp = new Array(amount + 1).fill(Infinity);

  // 基础情况：凑出金额 0 需要 0 个硬币（什么都不选）
  dp[0] = 0;

  // 外层循环：依次计算凑出金额 1 到 amount 的最小硬币数
  for (let i = 1; i <= amount; i++) {
    // 内层循环：遍历每一种硬币面额
    for (const coin of coins) {
      // 只有当硬币面额 <= 当前金额 且 剩余金额(i - coin)可以被凑出时，才考虑使用这枚硬币
      if (coin <= i && dp[i - coin] !== Infinity) {
        // 状态转移方程：
        // 用当前这枚硬币：总个数 = 凑出 (i - coin) 的个数 + 1
        // 与之前已经计算出的 dp[i] 取最小值
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  // 如果 dp[amount] 仍然是 Infinity，说明无法凑出目标金额，返回 -1
  // 否则返回最少硬币数量
  return dp[amount] === Infinity ? -1 : dp[amount];
};
```

下面用 **DP（完全背包：最小硬币数）**，结合你的 3 个例子，把“状态怎么定义、怎么转移、怎么初始化、怎么一步步算出来”讲清楚。

---

## 1) DP 定义（dp 是什么）

令：

> `dp[i]` 表示：**凑出金额 i 所需的最少硬币数**

目标：求 `dp[amount]`

---

## 2) 初始化（非常关键）

- `dp[0] = 0`：凑 0 元不需要硬币
- 其余 `dp[i] = Infinity`：表示目前还凑不出来（或最少数未知）

为什么用 Infinity？
因为我们要做 `min`，Infinity 方便比较。

---

## 3) 状态转移方程

要凑 `i`，最后一枚硬币可以是 `coin`（前提 `coin <= i`）：

- 如果最后用了一枚 `coin`
- 那前面必须凑出 `i - coin`
- 所以候选值：`dp[i - coin] + 1`

取所有硬币的最小值：

[
dp[i] = \min(dp[i],\ dp[i-coin] + 1)
]

---

## 4) 为什么这是“完全背包”？

因为每种硬币数量无限，所以每个 `coin` 可以重复使用。
常见写法（推荐）是：

- 外层遍历金额 `i = 1..amount`
- 内层遍历硬币 `coin in coins`

这样 `dp[i]` 使用的是更小金额的最优结果 `dp[i-coin]`，天然支持无限次使用。

---

## 5) 用例 1 手推：coins = [1,2,5], amount = 11

初始化：

- `dp[0]=0`
- `dp[1..11]=∞`

我们从小到大算（我列关键点，避免刷屏）：

### i = 1

- 用 1：`dp[1] = dp[0]+1 = 1`
  结果：`dp[1]=1`

### i = 2

- 用 1：`dp[1]+1 = 2`
- 用 2：`dp[0]+1 = 1` ← 更好
  结果：`dp[2]=1`（2）

### i = 3

- 用 1：`dp[2]+1 = 2`
- 用 2：`dp[1]+1 = 2`
  结果：`dp[3]=2`（2+1）

### i = 4

- 用 2：`dp[2]+1 = 2`（2+2）最好
  结果：`dp[4]=2`

### i = 5

- 用 5：`dp[0]+1 = 1` ← 最好
  结果：`dp[5]=1`（5）

### i = 6

- 用 5：`dp[1]+1 = 2`（5+1）最好
  结果：`dp[6]=2`

### i = 10

- 用 5：`dp[5]+1 = 2`（5+5）
  结果：`dp[10]=2`

### i = 11（最终）

- 用 1：`dp[10]+1 = 3`
- 用 2：`dp[9]+1`（dp[9]=3）→ 4
- 用 5：`dp[6]+1 = 2+1 = 3`
  结果：`dp[11]=3`

所以答案：`3`（11 = 5 + 5 + 1）

---

## 6) 用例 2：coins = [2], amount = 3

初始化：`dp[0]=0`, 其他 = ∞

- i=1：2 > 1，没法用 → `dp[1]=∞`
- i=2：用 2：`dp[0]+1=1` → `dp[2]=1`
- i=3：用 2：看 `dp[1]`，但 `dp[1]=∞`，所以 `dp[3]` 仍然是 ∞

最后 `dp[3]=∞` 表示凑不出 → 返回 `-1` ✅

---

## 7) 用例 3：coins = [1], amount = 0

直接命中初始化：

- `dp[0]=0`
  返回 0 ✅

---

## 8) JS 代码实现（DP）

---

如果你想再深入一点，我可以把 **dp 表完整打印出来（0..11）**，或者讲清楚为什么“零钱兑换（最少硬币）”和“完全平方数（最少平方数）”本质上是同一个 DP 模板。
