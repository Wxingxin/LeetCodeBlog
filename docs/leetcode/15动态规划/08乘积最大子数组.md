# 题

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

请注意，一个只包含一个元素的数组的乘积是这个元素的值。

## 示例 1:

输入: `nums = [2,3,-2,4]`
输出: `6`
解释: 子数组 [2,3] 有最大乘积 6。

## 示例 2:

输入: `nums = [-2,0,-1]`
输出: `0`
解释: 结果不能为 2, 因为 `[-2,-1]` 不是子数组。

# 解

很好，这一题**非常适合用“代码逐行注释 + 案例对照”来彻底吃透 DP**。
下面我会做三件事：

1. **给出完整 JS 代码（逐行中文注释）**
2. **结合示例 `[2,3,-2,4]`，按代码执行顺序一步步跑**
3. **总结为什么一定要同时维护 `curMax` 和 `curMin`**

---

## 一、完整代码（逐行注释版）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function (nums) {
  // curMax：以当前元素结尾的“最大乘积子数组”
  // curMin：以当前元素结尾的“最小乘积子数组”
  // 为什么要最小？因为负数 × 负数 可能变成最大
  let curMax = nums[0];
  let curMin = nums[0];

  // ans：全局最大乘积（不一定以最后一个元素结尾）
  let ans = nums[0];

  // 从第二个元素开始遍历
  for (let i = 1; i < nums.length; i++) {
    const x = nums[i];

    // 先保存上一轮的最大 / 最小
    // 因为下面更新 curMax 后，curMin 还需要用“旧的 curMax”
    const prevMax = curMax;
    const prevMin = curMin;

    /*
         以 nums[i] 结尾的子数组，只有三种可能：
         1）单独从 nums[i] 开始
         2）接在“之前最大乘积子数组”后面
         3）接在“之前最小乘积子数组”后面（关键：负负得正）
        */
    curMax = Math.max(x, prevMax * x, prevMin * x);

    curMin = Math.min(x, prevMax * x, prevMin * x);

    // 更新全局答案
    ans = Math.max(ans, curMax);
  }

  return ans;
};
```

---

## 二、结合案例逐行跑：[2, 3, -2, 4]

### 初始化（i = 0）

```js
curMax = 2;
curMin = 2;
ans = 2;
```

含义：

- 以 2 结尾的最大 / 最小乘积子数组就是 `[2]`

---

### i = 1，x = 3

```js
prevMax = 2;
prevMin = 2;
```

计算：

```js
curMax = max(
  3,        // 单独选 3
  2 * 3,    // 接在最大后面
  2 * 3     // 接在最小后面
) = 6

curMin = min(3, 6, 6) = 3
```

```js
ans = max(2, 6) = 6
```

当前状态：

| 变量   | 值  |
| ------ | --- |
| curMax | 6   |
| curMin | 3   |
| ans    | 6   |

对应子数组：

- 最大：[2, 3]
- 最小：[3]

---

### i = 2，x = -2（最关键的一步 ⚠️）

```js
prevMax = 6;
prevMin = 3;
```

计算：

```js
curMax = max(
  -2,          // 单独选 -2
  6 * -2,      // -12
  3 * -2       // -6
) = -2

curMin = min(-2, -12, -6) = -12
```

```js
ans = max(6, -2) = 6
```

当前状态：

| 变量   | 值  |
| ------ | --- |
| curMax | -2  |
| curMin | -12 |
| ans    | 6   |

含义：

- 最大子数组退化成 `[-2]`
- 但最小子数组变成 `[2,3,-2]`（乘积 -12）

👉 **这个最小值会在下一个负数时“翻身”**

---

### i = 3，x = 4

```js
prevMax = -2;
prevMin = -12;
```

计算：

```js
curMax = max(
  4,            // 单独选 4
  -2 * 4,       // -8
  -12 * 4       // -48
) = 4

curMin = min(4, -8, -48) = -48
```

```js
ans = max(6, 4) = 6
```

最终结果：

```js
return 6;
```

---

## 三、为什么一定要同时维护最大和最小？

看这个例子：

```
[-2, 3, -4]
```

如果你**只维护最大**：

- 到 3：最大是 3
- 到 -4：3 × -4 = -12（你会错过 -2 × 3 × -4 = 24）

但如果你维护最小：

- -2 × 3 = -6（最小）
- -6 × -4 = 24（翻成最大）

👉 **负数是“翻转器”**

- 最大 × 负数 → 可能变最小
- 最小 × 负数 → 可能变最大

---

## 四、一句话总结（记忆版）

> 以当前位置结尾的最大乘积，
> 可能来自：
>
> - 自己
> - 上一个最大 × 当前
> - 上一个最小 × 当前

这就是这道题 DP 的全部精髓。

---

如果你愿意，我也可以：

- 给你 **dp 数组版本**（maxDp / minDp）
- 对比 **最大子数组和（Kadane）** 为什么不够用
- 帮你总结一套「**看到乘积就要想到 max+min DP**」的通用模板
