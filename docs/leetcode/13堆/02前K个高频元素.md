# 题
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

## 示例 1：

输入：nums = `[1,1,1,2,2,3]`, k = 2

输出：`[1,2]`

## 示例 2：

输入：nums = `[1]`, k = 1

输出：`=[1]`

## 示例 3：

输入：nums = `[1,2,1,2,1,2,3,1,3,2]`, k = 2

输出：[1,2]

太棒了！我们就用你给的这个例子：

```js
nums = [1,2,1,2,1,2,3,1,3,2],  k = 2
```

来**手把手、一行一行、一步一步**完整模拟你写的「小顶堆解法」的执行过程，让你彻底看懂堆是怎么维护前 k 高频元素的！

---

### 最终答案：`[1,2]`（或 `[2,1]` 都对）

---

### Step 1：统计频率（用 Map）

遍历 nums 数组：

| 遍历到的数 | 当前 Map 状态                              |
|------------|---------------------------------------------|
| 1          | {1 → 1}                                     |
| 2          | {1 → 1, 2 → 1}                              |
| 1          | {1 → 2, 2 → 1}                              |
| 2          | {1 → 2, 2 → 2}                              |
| 1          | {1 → 3, 2 → 2}                              |
| 2          | {1 → 3, 2 → 3}                              |
| 3          | {1 → 3, 2 → 3, 3 → 1}                       |
| 1          | {1 → 4, 2 → 3, 3 → 1}                       |
| 3          | {1 → 4, 2 → 3, 3 → 2}                       |
| 2          | {1 → 4, 2 → 4, 3 → 2}                       |

最终频率 Map：

```js
{
  1: 4,
  2: 4,
  3: 2
}
```

---

### Step 2：构建大小为 k 的小顶堆（关键！）

我们维护一个**小顶堆**，堆里最多只有 k=2 个元素，  
堆顶永远是当前堆里**频率最小**的那个。

我们用 `[num, freq]` 形式存入堆，比较规则是按 freq 升序（小顶堆）

| 插入的元素     | 操作前堆大小 | 操作                            | 操作后堆内容（堆顶在最左）       | 堆顶频率 |
|----------------|--------------|----------------------------------|------------------------------------|----------|
| [1, 4]         | 0            | 入堆                            | [[1,4]]                            | 4        |
| [2, 4]         | 1            | 入堆                            | [[1,4], [2,4]]                     | 4        |
| [3, 2]         | 2            | 入堆 → 现在大小=3 > k=2 → 弹出堆顶 | 先变[[1,4],[2,4],[3,2]] → 弹出 [1,4] 或 [2,4]（谁小弹谁，但都一样大）<br>→ 剩 [[2,4], [3,2]] → 调整后堆顶是 [3,2] | 2        |

关键来了！

当插入 [3,2] 时，堆变成 3 个元素，超过 k=2，  
所以必须弹出**当前频率最小的**，也就是频率为 2 的那个 → **弹出 [3,2]**

但注意：1 和 2 的频率都是 4，谁在堆顶无所谓，我们随便弹一个都行。

实际执行中可能会弹出 [1,4] 或 [2,4]，但最终都会把 [3,2] 挤出去！

最终堆里剩下：

```js
[[1,4], [2,4]]
```

或
[[2,4], [1,4]]
```

堆顶是其中一个频率为 4 的

---

### Step 3：从堆中取出结果

```js
while (minHeap.size() > 0) {
    result.push(minHeap.dequeue()[0]);
}
```

弹出顺序可能是：

- 先弹 [1,4] → result = [1]
- 再弹 [2,4] → result = [1,2]

或者反过来 → [2,1]

都正确！

---

### 完整执行流程图（超级清晰版）

```
初始堆：[]

插入 [1,4] → 堆：[[1,4]]

插入 [2,4] → 堆：[[1,4], [2,4]]     ← 现在有 2 个

插入 [3,2] → 堆：[[1,4], [2,4], [3,2]] （临时有3个）
        ↓ 大小 > k，弹出频率最小的 → 弹出 [3,2]！（因为 2 < 4）
        ↓ 堆调整后 → [[1,4], [2,4]]

最终堆只有 [1,4] 和 [2,4]
→ 取出数字 → [1,2]
```

完美！3 被成功“踢出去”了，因为它的频率最低！

---

### 为什么这个方法是对的？

- 我们始终维护一个“频率最高的前 k 个候选人”的集合
- 每当来了一个新数字，如果它频率比堆顶（即当前前 k 个里最小的）还高，就把堆顶踢掉，把新的放进来
- 最终堆里剩下的，就是频率最高的那 k 个！

这就是经典的 **“小顶堆维护前 k 大”** 技巧！

---

### 总结：这个例子为什么输出 [1,2]

| 数字 | 频率 | 是否进入最终堆？ | 原因                             |
|------|------|-------------------|----------------------------------|
| 1    | 4    | 是                | 频率最高，并列第一                |
| 2    | 4    | 是                | 频率最高，并列第一                |
| 3    | 2    | 否                | 频率只有2，被小顶堆在第3步插入时弹出 |

最终只保留了频率 ≥ 堆顶频率的元素，而堆顶频率正好是第 k 高的！

---

**结论：你的代码完全正确！**  
在 LeetCode 上能轻松通过所有测试用例，包括大数据、频率并列等极端情况。

如果你还想看我用**桶排序**再手把手模拟一遍这个例子（更快、更简单），随时说！