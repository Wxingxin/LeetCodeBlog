# 题目

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

### 示例 1：

输入：`nums = [-1,0,1,2,-1,-4]`

输出：`[[-1,-1,2],[-1,0,1]]`

解释：

`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 `

`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 `

`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 `

不同的三元组是 `[-1,0,1]` 和 `[-1,-1,2] `

注意，输出的顺序和三元组的顺序并不重要。

### 示例 2：

输入：`nums = [0,1,1]`

输出：`[]`

解释：唯一可能的三元组和不为 `0` 。

### 示例 3：

输入：`nums = [0,0,0]`
输出：`[[0,0,0]]`
解释：唯一可能的三元组和为 `0` 

# 解

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  nums.sort((a, b) => a - b); // 先排序
  const n = nums.length;
  const result = [];

  for (let i = 0; i < n - 2; i++) {
    // 跳过重复的 nums[i]
    if (i > 0 && nums[i] === nums[i - 1]) continue;

    // 优化：如果当前数已经大于 0，后面的更大，不可能凑出 0
    if (nums[i] > 0) break;

    let left = i + 1;
    let right = n - 1;

    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];

      if (sum === 0) {
        result.push([nums[i], nums[left], nums[right]]);

        // 跳过重复的 left
        while (left < right && nums[left] === nums[left + 1]) left++;
        // 跳过重复的 right
        while (left < right && nums[right] === nums[right - 1]) right--;

        left++;
        right--;
      } else if (sum < 0) {
        left++;
      } else {
        right--;
      }
    }
  }

  return result;
};
```

太棒了！下面我用 **最细致的方式**，结合真实案例，一步一步给你彻底讲透这道题和这段 JS 代码的每一个细节！

---

### 题目回顾
给定数组 `nums`，找出所有满足以下条件的 **三元组**：
- `nums[i] + nums[j] + nums[k] == 0`
- `i ≠ j ≠ k`（三个索引不能相同）
- 不能有重复的三元组（比如不能出现两次 `[-1, 0, 1]`）

---

### 示例带入讲解（强烈建议你跟着这个例子走一遍）

```js
nums = [-1, 0, 1, 2, -1, -4]
```

#### 第一步：排序（最关键！）
```js
nums.sort((a, b) => a - b);
// 排序后变成：
nums = [-4, -1, -1, 0, 1, 2]
```
**为什么一定要排序？**
- 方便去重（相同元素会挨在一起）
- 方便用双指针（小的在左，大的在右）

---

### 完整代码逐行详细解释（结合上面这个例子）

```js
var threeSum = function(nums) {
    nums.sort((a, b) => a - b);        // 第1步：排序 → [-4,-1,-1,0,1,2]
    const n = nums.length;             // n = 6
    const result = [];                 // 最终答案
```

#### 外层循环：固定第一个数 nums[i]
```js
    for (let i = 0; i < n - 2; i++) {   // i 最多到 n-3，因为后面还要留两个位置
```

##### 情况1：i = 0，nums[i] = -4
```js
        if (i > 0 && nums[i] === nums[i - 1]) continue;  // i=0，跳过
        if (nums[i] > 0) break;                          // -4 ≤ 0，继续

        let left = i + 1;   // left = 1 → nums[1] = -1
        let right = n - 1;  // right = 5 → nums[5] = 2
```

现在开始双指针找 `nums[left] + nums[right] = -nums[i] = 4`

| left | nums[left] | right | nums[right] | sum = -4 + left + right | 结果 |
|------|------------|-------|-------------|----------------------------|------|
| 1    | -1         | 5     | 2           | -4 + -1 + 2 = -3 < 0       | left++ |
| 2    | -1         | 5     | 2           | -4 + -1 + 2 = -3 < 0       | left++ |
| 3    | 0          | 5     | 2           | -4 + 0 + 2 = -2 < 0        | left++ |
| 4    | 1          | 5     | 2           | -4 + 1 + 2 = -1 < 0        | left++ |
| 5    | 2          | 5     | 2           | left == right，退出循环     | 无解 |

→ 所以当 i=0（-4）时，没有三元组

##### 情况2：i = 1，nums[i] = -1
```js
        if (i > 0 && nums[i] === nums[i-1])  → -1 === -4？不等，继续
        if (nums[i] > 0) break;              → -1 ≤ 0，继续

        left = 2, right = 5
        目标：找两个数和为 -(-1) = 1
```

| left | nums[left] | right | nums[right] | sum = -1 + left + right | 操作 |
|------|------------|-------|-------------|----------------------------|------|
| 2    | -1         | 5     | 2           | -1 + -1 + 2 = 0 成功！     | 加入答案 |
| → 发现 [-1, -1, 2]，加入 result → `[[-1,-1,2]]`

然后跳过重复：
```js
while (left < right && nums[left] === nums[left+1]) left++;  
// nums[2]=-1, nums[3]=0，不等，不跳

while (left < right && nums[right] === nums[right-1]) right--; 
// right=5，right-1=4 → nums[5]=2, nums[4]=1，不等

left++;    → left = 3
right--;   → right = 4
```

继续：
| left | nums[left] | right | nums[right] | sum |
|------|------------|-------|-------------|-----|
| 3    | 0          | 4     | 1           | -1 + 0 + 1 = 0 又成功！ |

→ 加入 `[-1, 0, 1]`，result 变成：
```js
[[-1,-1,2], [-1,0,1]]
```

再跳过重复 → left++ → 4, right-- → 3 → left >= right，退出内层 while

##### 情况3：i = 2，nums[i] = -1
```js
if (i > 0 && nums[i] === nums[i-1]) 
→ nums[2] = -1, nums[1] = -1，相等！continue 跳过
```
**这就是去重的关键！** 不跳的话又会找到 `[-1,-1,2]` 和 `[-1,0,1]`，重复了！

##### 情况4：i = 3，nums[i] = 0
```js
if (nums[i] > 0) break;  → 0 等于 0，不大于，不 break
```

目标：找两个数和为 0
→ left=4 (1), right=5 (2) → 1+2=3 > 0 → right--
→ right=4，left=4，left not < right，退出

没有三元组

##### 情况5：i = 4，nums[i] = 1
```js
if (nums[i] > 0) break;  → 1 > 0，执行 break！直接结束整个 for 循环
```
**为什么可以 break？**
因为数组已经排序了，nums[i]=1 > 0，后面更大的数加起来肯定大于 0，不可能等于 0！

---

### 最终结果
```js
result = [
    [-1, -1, 2],
    [-1,  0, 1]
]
```

完美！没有重复，且全部找到！

---

### 总结：这三行去重代码太重要了！（背下来！）

```js
if (i > 0 && nums[i] === nums[i - 1]) continue;        // 跳过重复的第一个数

while (left < right && nums[left] === nums[left + 1]) left++;   // 跳过重复的第二个数
while (left < right && nums[right] === nums[right - 1]) right--; // 跳过重复的第三个数
```

---

### 所有测试用例验证（JS）

```js
console.log(threeSum([-1,0,1,2,-1,-4]));     // [[-1,-1,2],[-1,0,1]]
console.log(threeSum([0,0,0,0]));             // [[0,0,0]]
console.log(threeSum([0,1,1]));               // []
console.log(threeSum([-2,0,1,1,2]));          // [[-2,0,2],[-2,1,1]]
```
