# 题目

给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。

## 示例 1:

输入: `s = "abcabcbb"`

输出: `3`

解释: 因为无重复字符的最长子串是 `"abc"`，所以其长度为 `3`。注意 `"bca"` 和 `"cab"` 也是正确答案。

## 示例 2:

输入: `s = "bbbbb"`

输出: `1`

解释: 因为无重复字符的最长子串是 `"b"`，所以其长度为 `1`。

## 示例 3:

输入: `s = "pwwkew"`

输出: `3`

解释: 因为无重复字符的最长子串是 `"wke"`，所以其长度为 `3`。

请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

# 解

### 推荐写法：滑动窗口 + Map（最优解！）

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  // Map 用来记录：字符 → 该字符「最后一次」出现的下标
  const map = new Map();

  // 记录当前找到的最长无重复子串长度
  let maxLen = 0;

  // 滑动窗口左边界（起始下标）
  let left = 0;

  // right 是滑动窗口的右边界，不断向右扩展
  for (let right = 0; right < s.length; right++) {
    const char = s[right];

    // 如果当前字符之前出现过，并且在当前窗口范围内
    if (map.has(char)) {
      // 将左边界移动到：
      // 上一次该字符出现位置的「下一个位置」
      // 用 Math.max 是为了防止 left 回退
      left = Math.max(left, map.get(char) + 1);
    }

    // 更新当前字符的最新出现位置
    map.set(char, right);

    // 当前窗口长度 = right - left + 1
    maxLen = Math.max(maxLen, right - left + 1);
  }

  // 返回最长无重复子串的长度
  return maxLen;
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(min(m, n))，m 是字符集大小（最坏 128）

---

### 结合经典例子详细解释（手把手走一遍）

```js
s = "abcabcbb";
```

| right | char | map 内容                                  | left | 当前窗口 | 长度 | maxLen |
| ----- | ---- | ----------------------------------------- | ---- | -------- | ---- | ------ |
| 0     | a    | {a→0}                                     | 0    | "a"      | 1    | 1      |
| 1     | b    | {a→0, b→1}                                | 0    | "ab"     | 2    | 2      |
| 2     | c    | {a→0, b→1, c→2}                           | 0    | "abc"    | 3    | 3      |
| 3     | a    | 有 a！上次在位置 0 → left = 0+1=1         | 1    | "bca"    | 3    | 3      |
|       |      | 更新 map: {a→3, b→1, c→2}                 |      |          |      |        |
| 4     | b    | 有 b！上次在位置 1 → left = max(1, 1+1)=2 | 2    | "cab"    | 3    | 3      |
|       |      | 更新 map: {a→3, b→4, c→2}                 |      |          |      |        |
| 5     | c    | 有 c！上次在位置 2 → left = max(2, 2+1)=3 | 3    | "abc"    | 3    | 3      |
| 6     | b    | 有 b！上次在位置 4 → left = max(3, 4+1)=5 | 5    | "cb"     | 2    | 3      |
| 7     | b    | 有 b！上次在位置 6 → left = max(5, 6+1)=7 | 7    | "b"      | 1    | 3      |

最终答案：**3**

---

### 再来一个经典例子：`s = "pwwkew"`

| right | char | 关键操作                                | left | 当前窗口 | maxLen |
| ----- | ---- | --------------------------------------- | ---- | -------- | ------ |
| 0     | p    |                                         | 0    | p        | 1      |
| 1     | w    |                                         | 0    | pw       | 2      |
| 2     | w    | 重复！w 上次在 1 → left = 2             | 2    | w        | 2      |
| 3     | k    |                                         | 2    | wk       | 2      |
| 4     | e    |                                         | 2    | wke      | 3      |
| 5     | w    | 重复！w 上次在 2 → left = max(2, 2+1)=3 | 3    | kew      | 3      |

答案：**3**（"wke" 或 "kew"）

---

### 为什么用 Map 而不是对象？

```js
// 用 Map 更好，因为：
const map = new Map();
map.set("a", 1);
map.has("a"); // true
map.get("a"); // 1
map.delete("a");

// 对象容易出问题：如果字符串有 "hasOwnProperty" 这种 key 就炸了
```

---

### 更简洁的写法（大佬写法）

```javascript
var lengthOfLongestSubstring = function (s) {
  let left = 0,
    maxLen = 0;
  const lastSeen = new Map();

  for (let right = 0; right < s.length; right++) {
    if (lastSeen.has(s[right])) {
      left = Math.max(left, lastSeen.get(s[right]) + 1);
    }
    lastSeen.set(s[right], right);
    maxLen = Math.max(maxLen, right - left + 1);
  }
  return maxLen;
};
```

---

### 测试用例全过

```javascript
console.log(lengthOfLongestSubstring("abcabcbb")); // 3 "abc"
console.log(lengthOfLongestSubstring("bbbbb")); // 1 "b"
console.log(lengthOfLongestSubstring("pwwkew")); // 3 "wke"
console.log(lengthOfLongestSubstring("")); // 0
console.log(lengthOfLongestSubstring("dvdf")); // 3 "vdf"
```

---

### 核心思想总结（背下来！）

> 用一个哈希表记录每个字符最后出现的位置  
> 用 left 表示当前窗口左边界  
> 当遇到重复字符时，把 left 跳到「上一次出现位置的下一位」  
> 每次更新窗口长度，取最大值
