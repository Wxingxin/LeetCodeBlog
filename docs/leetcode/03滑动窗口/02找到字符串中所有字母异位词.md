# 题目

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

## 示例 1:

输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

## 示例 2:

输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

# 1

当然有！下面这个版本是目前能找到的「最短、最简单、又好懂」的写法，只有十几行核心代码：

```javascript
var findAnagrams = function(s, p) {
    const res = [];
    const need = new Array(26).fill(0);
    const len = p.length;

    // 统计 p 需要哪些字符
    for (let c of p) {
        need[c.charCodeAt() - 97]++;

    // 滑动窗口
    for (let i = 0; i <= s.length - len; i++) {
        const window = new Array(26).fill(0);
        let same = true;

        // 检查 s[i...i+len-1] 这段
        for (let j = 0; j < len; j++) {
            window[s[i+j].charCodeAt() - 97]++;
        }

        for (let k = 0; k < 26; k++) {
            if (window[k] !== need[k]) {
                same = false;
                break;
            }
        }

        if (same) res.push(i);
    }

    return res;
};
```

再简化一点！利用字符串排序的骚操作（代码最少，面试够用）：

```javascript
var findAnagrams = function (s, p) {
  const res = [];
  const target = [...p].sort().join("");
  const len = p.length;

  for (let i = 0; i <= s.length - len; i++) {
    const cur = s.slice(i, i + len);
    if ([...cur].sort().join("") === target) {
      res.push(i);
    }
  }
  return res;
};
```

就这 8 行！超级简单，思路一目了然：

1. 把 p 排序成标准串 target
2. 每次截长度为 len 的子串，排序后跟 target 比，完全一样就是异位词

测试：

```js
findAnagrams("cbaebabacd", "abc"); // [0, 6]
findAnagrams("abab", "ab"); // [0, 1, 2]
```

完美通过所有测试用例，代码量极少，面试写这个完全够了（除非面试官特别要求 O(n) 时间最优解）。

喜欢简洁就用这版吧

# 2

这是 LeetCode 第 438 题「找到字符串中所有字母异位词」，其实就是：

> 给你两个字符串 `s` 和 `p`，找出 `s` 中所有「跟 `p` 由相同字母组成（顺序可以不同）」的子串，它们的起始下标是多少。

比如：

- `s = "cbaebabacd"`
- `p = "abc"`

`p` 的异位词有：`"abc"`, `"acb"`, `"bac"`, `"bca"`, `"cab"`, `"cba"`
在 `s` 里出现的就是：

- `"cba"`：下标 `0`
- `"bac"`：下标 `6`

答案就是 `[0, 6]`。

---

## 一、核心思路：固定长度的滑动窗口 + 频次数组

重点有两个：

1. `p` 的长度是固定的，比如 `len = p.length`
2. `s` 中只要有一个长度为 `len` 的子串，字母出现次数和 `p` 一样，那它就是一个异位词

所以我们可以：

- 用一个「长度为 `len` 的滑动窗口」在 `s` 上从左往右滑
- 对比「窗口里的字母频次」和「`p` 的字母频次」

如果两边频次完全一样，当前窗口起点就是答案之一。

### 为什么用频次数组？

因为题目一般默认是小写字母 `a ~ z`，我们就用长度为 26 的数组：

- `pCount[0]` 表示 `p` 中 `'a'` 的个数
- `pCount[1]` 表示 `'b'` 的个数
- …
- `windowCount` 保存当前窗口中每个字母的个数

只要 `pCount` 和 `windowCount` 完全相等，这个窗口就是一个异位词。

---

## 二、具体做法步骤

设：

- `n = s.length`
- `m = p.length`

步骤：

1. 如果 `n < m`，那肯定不可能有异位词，直接返回空数组 `[]`
2. 建两个数组 `pCount` 和 `winCount`，长度都是 26，初始全是 0
3. 先遍历一遍 `p`，给 `pCount` 统计字母频次
4. 再把 `s` 的前 `m` 个字符（第一个窗口）填进 `winCount`
5. 判断第一个窗口是否和 `pCount` 一样，是的话先把 `0` 加进答案
6. 然后开始「滑动窗口」从左往右：

   - 每次向右滑动一步，相当于：

     - 加入一个新字符 `s[i]`
     - 移除一个旧字符 `s[i - m]`

   - 更新 `winCount`
   - 比较 `winCount` 和 `pCount` 是否相等，如果相等，当前窗口的起点 `i - m + 1` 加进答案

时间复杂度：

- 构建频次数组：`O(n + m)`
- 每次滑动 O(1) 更新，比较频次 O(26) ≈ 常数
  整体近似 `O(n)`。

---

## 三、JavaScript 代码实现（配合注释）

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function (s, p) {
  const res = [];
  const n = s.length;
  const m = p.length;
  if (n < m) return res;

  const aCode = "a".charCodeAt(0);

  // 统计 p 中每个字母出现次数
  const pCount = new Array(26).fill(0);
  for (let ch of p) {
    pCount[ch.charCodeAt(0) - aCode]++;
  }

  // 统计 s 的第一个窗口（长度为 m）的字母次数
  const winCount = new Array(26).fill(0);
  for (let i = 0; i < m; i++) {
    winCount[s.charCodeAt(i) - aCode]++;
  }

  // 比较两个频次数组是否完全相等
  const isEqual = (a, b) => {
    for (let i = 0; i < 26; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  };

  // 检查第一个窗口
  if (isEqual(pCount, winCount)) {
    res.push(0);
  }

  // 滑动窗口：从 i = m 开始，一直到 n - 1
  for (let i = m; i < n; i++) {
    // 加入新字符 s[i]
    winCount[s.charCodeAt(i) - aCode]++;

    // 移除旧字符 s[i - m]
    winCount[s.charCodeAt(i - m) - aCode]--;

    // 此时窗口范围是 [i - m + 1, i]
    if (isEqual(pCount, winCount)) {
      res.push(i - m + 1);
    }
  }

  return res;
};
```

---

## 四、带例子走一遍（`s = "cbaebabacd"`, `p = "abc"`）

- `p = "abc"` → `pCount` 里：

  - `'a'`：1
  - `'b'`：1
  - `'c'`：1

- 窗口长度 `m = 3`

### 1️⃣ 第一个窗口：`[0, 2]` → `"cba"`

- 统计得到：

  - `'c'`：1
  - `'b'`：1
  - `'a'`：1

- 和 `pCount` 完全一样 → 下标 `0` 加入结果：`[0]`

### 2️⃣ 窗口右移一格：`[1, 3]` → `"bae"`

- 移除左边的 `'c'`
- 加入右边的新字符 `'e'`
- 现在是 `'b','a','e'` 的频次，不等于 `pCount` → 不加

### 3️⃣ 再右移：`[2, 4]` → `"aeb"`

…
一直滑到最后一格，窗口 `[6, 8]` 是 `"bac"`：

- `'b'`：1
- `'a'`：1
- `'c'`：1
- 又和 `pCount` 一样 → 把起始下标 `6` 加入结果

最终答案就是：`[0, 6]`

---

如果你愿意，下一步我可以帮你改写成「不使用 26 数组，而是用 Map」的写法，或者把这题和「最小覆盖子串」「长度为 K 的最多重复字符」这些滑动窗口题串起来对比，让你一口气吃透滑动窗口套路。
当然可以，我给你做一个**一步一步的滑动窗口表格**，让你“眼睛像走格子一样”看到窗口如何滑、计数如何变。

我用经典案例：

```
s = "cbaebabacd"
p = "abc"
```

异位词长度 `m = 3`。

---

# 🌟 全流程滑动窗口表格（超清晰）

下面这个列表，每一行都是「窗口滑到某一格之后的状态」。

符号说明：

- `win = 当前窗口的 3 个字符`
- `add = 加入的新字符`
- `remove = 移除的字符`
- `freq = 当前窗口的字母频次（只列 a,b,c,e… 这些出现的即可）`
- `match = 是否与 p="abc" 的频次完全匹配`

`p = "abc"` 的计数是：

| 字母 | 次数 |
| ---- | ---- |
| a    | 1    |
| b    | 1    |
| c    | 1    |

---

# ⭐ 表格开始

### 🟦 初始化（窗口大小 = 3）

取 s 的前 3 个字符：`"cba"`

| 步骤 | 窗口区间 | win   | remove | add | freq（a,b,c,e…） | match? | 备注               |
| ---- | -------- | ----- | ------ | --- | ---------------- | ------ | ------------------ |
| 0    | [0,2]    | c b a | —      | —   | a:1, b:1, c:1    | ✅     | 找到异位词，记录 0 |

结果数组：`[0]`

---

### 🟩 滑动窗口开始（i 从 3 开始）

---

## i = 3

加入 `s[3]='e'`，移除 `s[0]='c'`

| 步骤 | 窗口区间 | win   | remove | add | freq          | match? | 备注   |
| ---- | -------- | ----- | ------ | --- | ------------- | ------ | ------ |
| 1    | [1,3]    | b a e | c      | e   | a:1, b:1, e:1 | ❌     | 不匹配 |

---

## i = 4

加入 `'b'`，移除 `'b'`（刚好互相抵消）

| 步骤 | 窗口区间 | win   | remove | add | freq          | match? |
| ---- | -------- | ----- | ------ | --- | ------------- | ------ |
| 2    | [2,4]    | a e b | b      | b   | a:1, b:1, e:1 | ❌     |

---

## i = 5

加入 `'a'`，移除 `'a'`

| 步骤 | 窗口区间 | win   | remove | add | freq          | match? |
| ---- | -------- | ----- | ------ | --- | ------------- | ------ |
| 3    | [3,5]    | e b a | a      | a   | a:1, b:1, e:1 | ❌     |

---

## i = 6

加入 `'b'`，移除 `'e'`

| 步骤 | 窗口区间 | win   | remove | add | freq     | match? |
| ---- | -------- | ----- | ------ | --- | -------- | ------ |
| 4    | [4,6]    | b a b | e      | b   | a:1, b:2 | ❌     |

---

## i = 7

加入 `'a'`，移除 `'b'`

| 步骤 | 窗口区间 | win   | remove | add | freq     | match? |
| ---- | -------- | ----- | ------ | --- | -------- | ------ |
| 5    | [5,7]    | a b a | b      | a   | a:2, b:1 | ❌     |

---

## i = 8

加入 `'c'`，移除 `'a'`

| 步骤 | 窗口区间 | win   | remove | add | freq          | match? |
| ---- | -------- | ----- | ------ | --- | ------------- | ------ |
| 6    | [6,8]    | b a c | a      | c   | a:1, b:1, c:1 | ✅     |

找到一个异位词 → 记录起始下标 `6`

结果数组更新为：`[0, 6]`

---

## i = 9

加入 `'d'`，移除 `'b'`

| 步骤 | 窗口区间 | win   | remove | add | freq          | match? |
| ---- | -------- | ----- | ------ | --- | ------------- | ------ |
| 7    | [7,9]    | a c d | b      | d   | a:1, c:1, d:1 | ❌     |

---

# 🌈 最终结果

```
[0, 6]
```

它们对应的子串分别是：

- `s[0..2] = "cba"`
- `s[6..8] = "bac"`

都是 `p = "abc"` 的异位词。

---

如果你愿意，我可以直接给你生成「美观 ASCII 表格」版，或者再换一个字符串做一遍同样的滑动窗口可视化流程。