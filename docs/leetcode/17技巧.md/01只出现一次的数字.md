s# 题
给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间

## 示例 1 ：

输入：nums = `[2,2,1]`

输出：1

## 示例 2 ：

输入：nums = `[4,1,2,1,2]`

输出：4

## 示例 3 ：

输入：nums = `[1]`

输出：1
# 解

这是一个经典的 **“只出现一次的数字”** 问题（LeetCode 136）。
关键点在于：**线性时间 O(n) + 常量空间 O(1)**。

---

## 一、核心思路（位运算：异或 XOR）

### 1️⃣ 异或的三个重要性质

* `a ^ a = 0`（相同的数异或为 0）
* `a ^ 0 = a`
* 异或 **满足交换律和结合律**

---

### 2️⃣ 为什么能用异或？

数组中：

* 每个数字 **出现两次** → 两两异或后变成 `0`
* **只出现一次的数字** → 最终会被保留下来

---

## 二、结合案例讲解

### 示例 1

```js
nums = [4, 1, 2, 1, 2]
```

计算过程：

```text
result = 0
0 ^ 4 = 4
4 ^ 1 = 5
5 ^ 2 = 7
7 ^ 1 = 6
6 ^ 2 = 4
```

最终结果：

```text
只出现一次的数字 = 4
```

👉 所有成对的数字都“抵消”掉了，只剩下唯一的那个。

---

### 示例 2

```js
nums = [2, 2, 3]
```

```text
0 ^ 2 = 2
2 ^ 2 = 0
0 ^ 3 = 3
```

结果是 `3`

---

## 三、代码实现（含详细注释）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
function singleNumber(nums) {
  // 用于存储异或结果
  let result = 0;

  // 遍历数组中的每一个元素
  for (let i = 0; i < nums.length; i++) {
    /**
     * 异或运算：
     * - 相同的数字会抵消（变成 0）
     * - 0 ^ x = x
     */
    result ^= nums[i];
  }

  // 最终剩下的就是只出现一次的数字
  return result;
}
```

---

## 四、复杂度分析

| 项目    | 复杂度              |
| ----- | ---------------- |
| 时间复杂度 | **O(n)**（遍历一次数组） |
| 空间复杂度 | **O(1)**（只用一个变量） |

✔️ 完全满足题目要求

---

## 五、总结一句话

> **成对的数字通过异或会互相抵消，最终留下的就是只出现一次的那个数。**

如果你愿意，我也可以：

* 用 **位运算图示**再讲一遍
* 或对比 **哈希表解法**为什么不满足空间要求
* 或用 **面试答题模板**帮你整理这道题 👍
# 

很好，这一行确实是**新手最容易卡住的地方** 👍
我不用位运算，**先用“看得懂”的代码帮你理解，再告诉你为什么必须用它**。

---

## 一、先用“普通思路”写一个你能看懂的版本（❌不满足题目要求）

### 思路：用对象统计次数

```js
function singleNumber(nums) {
  const map = {};

  // 统计每个数字出现的次数
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    if (map[num] === undefined) {
      map[num] = 1;
    } else {
      map[num]++;
    }
  }

  // 找出只出现一次的数字
  for (let key in map) {
    if (map[key] === 1) {
      return Number(key);
    }
  }
}
```

### 这个版本你应该能看懂：

* 用 `map` 记录次数
* 谁的次数是 `1`，就返回谁

❗ **但问题是：**

* 用了额外空间 `map`
* 空间复杂度是 `O(n)`
* ❌ **不满足题目要求**

---

## 二、为什么一定要用 `result ^= nums[i]`？

因为题目 **明确要求**：

> 线性时间 + 常量空间

也就是说：

* ❌ 不能用数组
* ❌ 不能用对象
* ❌ 不能记录每个数的次数

只能用 **一个变量**。

---

## 三、把 `result ^= nums[i]` 拆成“人话”

我们一步一步来。

### 1️⃣ 把 `^=` 当成普通写法

```js
result = result ^ nums[i];
```

---

### 2️⃣ 异或你只需要记住 3 句话（够用了）

| 表达式     | 结果  | 解释      |
| ------- | --- | ------- |
| `a ^ a` | `0` | 相同的数会消失 |
| `a ^ 0` | `a` | 0 不影响结果 |
| 顺序无关    |     | 谁先算都一样  |

---

### 3️⃣ 用“记账”的方式理解

假设：

```js
nums = [1, 2, 1]
```

执行过程：

```js
result = 0

result = 0 ^ 1  // = 1
result = 1 ^ 2  // = 3
result = 3 ^ 1  // = 2
```

为什么？

* 第一个 `1`：记账
* 第二个 `1`：把之前的 `1` 抵消掉
* 剩下的就是 `2`

👉 **出现两次的会被抹掉，只出现一次的会留下**

---

## 四、如果“完全不用 ^=”，还能不能做？（❌不能）

你可能会想：

```js
result += nums[i];
result -= nums[i];
```

❌ 不行，因为：

* 不知道什么时候加、什么时候减
* 顺序会影响结果
* 没有“自动抵消”的能力

👉 **只有异或有这个特性**

---

## 五、最终推荐你记住的版本（面试可用）

```js
function singleNumber(nums) {
  let result = 0;

  for (let i = 0; i < nums.length; i++) {
    // 相同的数字会互相抵消
    result = result ^ nums[i];
  }

  return result;
}
```

---

## 六、一句话帮你“记住它”

> **“成对出现的数，异或之后会消失，只剩下那个孤单的数。”**

---

如果你愿意，我可以：

* 用 **纸上推演图**再讲一遍
* 用 **二进制角度**解释为什么 `a ^ a = 0`
* 或给你一份 **面试答题背诵版解释**
