# 题

- 将两个**升序**链表合并为一个新的**升序**链表并返回。
- 新链表是通过**拼接**给定的两个链表的**所有节点**组成的。

## 示例 1：

![](./img/aa.png)

输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

## 示例 2：

输入：l1 = [], l2 = []
输出：[]

## 示例 3：

输入：l1 = [], l2 = [0]
输出：[0]

# 解

这段代码是 LeetCode 21. 合并两个有序链表（Merge Two Sorted Lists）的经典解法，使用的是「虚拟头结点 + 尾插法」。下面我结合具体案例，手把手详细讲解它的执行过程。

### 原函数（稍作格式化，便于理解）

```javascript
var mergeTwoLists = function (list1, list2) {
  let dummy = new ListNode(-1); // 虚拟头结点
  let current = dummy; // 当前指向新链表的尾部

  while (list1 && list2) {
    // 只要两个链表都还有节点
    if (list1.val <= list2.val) {
      current.next = list1; // 把 list1 当前节点接上
      list1 = list1.next; // list1 向前走一步
    } else {
      current.next = list2; // 把 list2 当前节点接上
      list2 = list2.next; // list2 向前走一步
    }
    current = current.next; // 新链表尾部向前移动
  }

  // 其中一个链表已经用完，直接把另一个剩下的部分接上
  current.next = list1 ? list1 : list2;

  return dummy.next; // 返回虚拟头结点的下一个节点（真正的头）
};
```

### 核心思想

- 用一个「虚拟头结点」（dummy）避免处理头结点的特殊情况
- 用 current 指针始终指向当前新链表的最后一个节点，方便尾插
- 每次从 list1 和 list2 中挑选值较小的节点接到新链表后面
- 最后把没用完的那条链表直接接在新链表末尾

### 详细案例演示

假设有两个有序链表：

```
list1: 1 → 3 → 5 → 7
list2: 2 → 4 → 6
```

我们一步步看执行过程：

| 步骤                      | list1 当前                    | list2 当前 | 比较结果                       | current.next 指向谁 | 新链表（dummy 后面的部分） | current 移动到 |
| ------------------------- | ----------------------------- | ---------- | ------------------------------ | ------------------- | -------------------------- | -------------- |
| 初始化                    | 1                             | 2          | -                              | -                   | (empty)                    | dummy (-1)     |
| 1                         | 1                             | 2          | 1 ≤ 2                          | list1 (1)           | -1 → 1                     | 1              |
|                           | → 3                           | 2          |                                |                     |                            |                |
| 2                         | 3                             | 2          | 3 > 2                          | list2 (2)           | -1 → 1 → 2                 | 2              |
|                           | 3                             | → 4        |                                |                     |                            |                |
| 3                         | 3                             | 4          | 3 ≤ 4                          | list1 (3)           | -1 → 1 → 2 → 3             | 3              |
|                           | → 5                           | 4          |                                |                     |                            |                |
| 4                         | 5                             | 4          | 5 > 4                          | list2 (4)           | -1 → 1 → 2 → 3 → 4         | 4              |
|                           | 5                             | → 6        |                                |                     |                            |                |
| 5                         | 5                             | 6          | 5 ≤ 6                          | list1 (5)           | -1 → 1 → 2 → 3 → 4 → 5     | 5              |
|                           | → 7                           | 6          |                                |                     |                            |                |
| 6                         | 7                             | 6          | 7 > 6                          | list2 (6)           | -1 → 1 → 2 → 3 → 4 → 5 → 6 | 6              |
|                           | 7                             | → null     |                                |                     |                            |                |
| 循环结束（list2 为 null） |                               |            |                                |                     |                            |                |
| 最后一步                  | current.next = list1 (剩余 7) | →          | -1 → 1 → 2 → 3 → 4 → 5 → 6 → 7 |                     |
| 返回 dummy.next           | → 1 → 2 → 3 → 4 → 5 → 6 → 7   | 完美合并！ |

### 再来一个特殊案例：其中一个链表为空

```
list1: 1 → 2 → 4
list2: (empty)
```

执行过程：

- while 循环一开始 list2 就是 null，条件不满足，直接跳出
- 执行 `current.next = list1 ? list1 : list2` → 接上 list1
- 返回 1→2→4（原样返回）

如果 list1 为空，list2 有值，也会直接接上 list2。

### 为什么一定要用 dummy 虚拟头结点？

如果不用 dummy，直接让 current = null，开始拼接：

```js
if (!list1) return list2;
if (!list2) return list1;
let head = list1.val <= list2.val ? list1 : list2;
let current = head;
// ...后面逻辑会非常麻烦，需要单独处理头结点
```

用了 dummy 之后，代码统一、简洁、无特殊情况，属于「优雅解法」。

### 时间复杂度 & 空间复杂度

- 时间：O(m + n) 每个节点最多被访问一次
- 空间：O(1) 只用了几个指针（不算返回的新链表本身）

### 总结：这行代码的精髓

```js
current.next = list1 ? list1 : list2;
```

这一句处理了所有剩余节点的情况，比写两个 if 更简洁优雅。

这就是为什么这 10 来行代码能成为「合并两个有序链表」的标准答案，值得背下来并真正理解其执行流程！