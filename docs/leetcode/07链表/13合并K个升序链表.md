# 合并 K 个升序链表

给你一个链表数组，每个链表都已经按 **升序排列**。

请你将所有链表 **合并** 到一个 **升序** 链表中，返回 **合并** 后的 **链表**。

## 示例 1：

输入：`lists = [[1,4,5],[1,3,4],[2,6]]`

输出：`[1,1,2,3,4,4,5,6]`

解释：链表数组如下：

```js
[
1->4->5,
1->3->4,
2->6
]
```

将它们合并到一个有序链表中得到。

`1->1->2->3->4->4->5->6`

## 示例 2：

输入：`lists = []`

输出：`[]`

## 示例 3：

输入：`lists = [[]]`

输出：`[]`

# 解

## ideas

0）先把题意翻译成操作

你有 `k` 个**已经升序**的链表（每个链表内部有序），要输出一个**总的升序链表**。

关键：每个链表都排好序了，所以你不能乱拼，要“有序地取最小”。

---

1）先想最简单的做法（能做出来就行）

**顺序合并：**

- 先把 `lists[0]` 和 `lists[1]` 合成一个
- 再把结果和 `lists[2]` 合
- 再和 `lists[3]` 合……
  直到合完

这一步你会发现：核心子问题就是——**怎么合并两个升序链表**（LeetCode 21 模板）。

✅ 两个链表怎么合？

- 两个指针 `a`、`b` 指向两个链表头
- 谁小接谁，指针往后走
- 最后把剩下的一条直接接上

这个你代码里的 `mergeTwoLists(a,b)` 就是在做这件事。

---

2）发现顺序合并的问题（为什么要优化）

顺序合并的问题是：**越往后合，并入的“总链表”越来越长**，导致重复遍历很严重。

举个直觉例子：

- 第一次合并处理了 2 条链表的节点
- 第二次合并要处理 “(前两条合并后的超长链表) + 第 3 条”
- 第三次更长……

所以整体会偏慢（最坏接近 `O(k*n)` 的感觉）。

---

3）优化思路：既然都要两两合并，为什么不“均匀”一点？

这里就自然想到**分治**（像归并排序）：

不要按顺序一直往一个大链表里塞，而是：

- 先把链表分成两半
- 左半边先合成一个
- 右半边先合成一个
- 最后把左右两个结果再合起来

这样每次合并的两条链表长度更接近，整体更均匀。

---

4）把“分治”写成递归函数：mergeRange(l, r)

你代码里的 `mergeRange(l, r)` 就是在做：

> 把 `lists[l..r]` 这一段链表，合并成一条有序链表返回。

递归三步走：

# （1）递归终止条件（base case）

如果区间只有一个链表：

```js
if (l === r) return lists[l];
```

这很重要：递归必须能停。

# （2）把区间一分为二

```js
mid = (l + r) >> 1;
```

# （3）分别递归合并左右区间，再合并两条结果

```js
left = mergeRange(l, mid);
right = mergeRange(mid + 1, r);
return mergeTwoLists(left, right);
```

---

5）用一个具体例子走一遍（最关键）

假设 `lists = [L0, L1, L2, L3]`

调用：`mergeRange(0,3)`

1. `mergeRange(0,3)` 拆成：

   - `mergeRange(0,1)`
   - `mergeRange(2,3)`

2. `mergeRange(0,1)` 再拆：

   - `mergeRange(0,0)` → 返回 `L0`
   - `mergeRange(1,1)` → 返回 `L1`
   - 然后合并 → 得到 `M01`

3. `mergeRange(2,3)` 同理：

   - 得到 `M23`

4. 最后：

   - `mergeTwoLists(M01, M23)` → 得到最终结果 `M0123`

你可以把它看成一棵树：

```
          merge(0,3)
         /          \
   merge(0,1)     merge(2,3)
    /    \          /    \
   L0    L1        L2     L3
```

每个内部节点就是一次 `mergeTwoLists`。

---

6）为什么复杂度是 O(n log k)（直觉版）

- 所有节点总数是 `n`
- 每一层合并：所有节点都会被“走一遍”（因为合并要比较并串起来）
  → 每层大概 `O(n)`
- 一共有多少层？

  - 每次链表数量减半：k → k/2 → k/4 → …
  - 层数就是 `log2(k)`

所以总时间：

```
O(n) * O(log k) = O(n log k)
```

---

7）这份代码的“关键正确性点”

- `mergeRange(l,r)` 保证返回的一定是**升序链表**

  - 因为它只做两件事：
    1）递归得到两个升序结果 left/right
    2）用 `mergeTwoLists` 合并两个升序链表 → 结果仍升序

- `mergeTwoLists` 是经典证明：每步选择最小头节点，保持整体有序。

## code

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
```

```js
var mergeKLists = function (lists) {
  // 1️⃣ 边界处理
  // lists 可能是 null、undefined 或空数组
  if (!lists || lists.length === 0) return null;

  /**
   * 2️⃣ 分治函数：合并 lists[l..r] 范围内的链表
   * 思想：把多个链表不断两两合并
   */
  function mergeRange(l, r) {
    // 递归终止条件：
    // 当区间中只有一个链表，直接返回它
    if (l === r) return lists[l];

    // 取中点，防止溢出用位运算
    const mid = (l + r) >> 1;

    // 递归合并左半部分
    const left = mergeRange(l, mid);

    // 递归合并右半部分
    const right = mergeRange(mid + 1, r);

    // 合并左右两个已经排好序的链表
    return mergeTwoLists(left, right);
  }

  /**
   * 3️⃣ 合并两个有序链表（LeetCode 21 经典题）
   */
  function mergeTwoLists(a, b) {
    // 哑节点，方便统一处理头节点
    const dummy = new ListNode(0);
    let cur = dummy;

    // 当两个链表都不为空时，逐个比较
    while (a !== null && b !== null) {
      if (a.val <= b.val) {
        cur.next = a;
        a = a.next;
      } else {
        cur.next = b;
        b = b.next;
      }
      cur = cur.next;
    }

    // 4️⃣ 把剩余的链表直接接上
    // 此时 a 或 b 其中一个一定为 null
    cur.next = a !== null ? a : b;

    // 返回真正的头节点
    return dummy.next;
  }

  // 5️⃣ 从 0 到 lists.length - 1 开始分治合并
  return mergeRange(0, lists.length - 1);
};
```

**时间复杂度：O(N log K)**（N 总节点数，K 是链表个数）  
**空间复杂度：O(K)**

这是 **面试中最推荐的写法**！清晰、高效、易扩展！

---

### 手推案例（经典！一定要跟上！）

输入：

```js
lists = [
  1 → 4 → 5,
  1 → 3 → 4,
  2 → 6
]
```

目标输出：`1 → 1 → 2 → 3 → 4 → 4 → 5 → 6`

#### 步骤演示：

| 步骤 | 堆中节点（按 val） | 弹出 | 当前结果链表    | 入堆新节点         |
| ---- | ------------------ | ---- | --------------- | ------------------ |
| 初始 | [1,1,2]            |      |                 |                    |
| 1    | [1,1,2] → 弹出 1   | 1    | 1               | 入 4（第一个链表） |
| 2    | [1,2,4] → 弹出 1   | 1    | 1 → 1           | 入 3（第二个链表） |
| 3    | [2,3,4] → 弹出 2   | 2    | 1 → 1 → 2       | 入 6               |
| 4    | [3,4,6] → 弹出 3   | 3    | 1→1→2→3         | 入 4（第二个）     |
| 5    | [4,4,6] → 弹出 4   | 4    | 1→1→2→3→4       | 入 5               |
| 6    | [4,5,6] → 弹出 4   | 4    | 1→1→2→3→4→4     | 无                 |
| 7    | [5,6] → 弹出 5     | 5    | 1→1→2→3→4→4→5   | 无                 |
| 8    | [6] → 弹出 6       | 6    | 1→1→2→3→4→4→5→6 | 无                 |

完美！

---

### 4 种解法对比（面试必背！）

| 解法                     | 时间复杂度     | 空间复杂度 | 推荐指数 | 说明         |
| ------------------------ | -------------- | ---------- | -------- | ------------ |
| 1. 两两合并（递归/迭代） | O(N × K)       | O(1)       | 3 stars  | 简单但慢     |
| 2. 优先队列（最小堆）    | **O(N log K)** | O(K)       | 5 stars  | 面试最佳！   |
| 3. 分治合并（两两配对）  | **O(N log K)** | O(log K)   | 5 stars  | 优雅，推荐   |
| 4. 收集所有节点排序      | O(N log N)     | O(N)       | 2 stars  | 取巧，不推荐 |

---

### 解法 3：分治合并（超级优雅！代码最短）

```javascript
var mergeKLists = function (lists) {
  if (!lists.length) return null;

  const mergeTwo = (l1, l2) => {
    let dummy = new ListNode(0);
    let tail = dummy;
    while (l1 && l2) {
      if (l1.val < l2.val) {
        tail.next = l1;
        l1 = l1.next;
      } else {
        tail.next = l2;
        l2 = l2.next;
      }
      tail = tail.next;
    }
    tail.next = l1 || l2;
    return dummy.next;
  };

  const divideAndConquer = (lists, start, end) => {
    if (start === end) return lists[start];
    if (start > end) return null;
    const mid = (start + end) >> 1;
    return mergeTwo(
      divideAndConquer(lists, start, mid),
      divideAndConquer(lists, mid + 1, end)
    );
  };

  return divideAndConquer(lists, 0, lists.length - 1);
};
```

这版代码最短、最优雅，**强烈推荐背下来**！

---

### 面试黄金话术（背会直接加分！）

> 面试官：合并 K 个有序链表怎么做？  
> 我：有两种最优解，我都能手写：
>
> 1. **优先队列（最小堆）**：每次从 K 个链表头选最小值，时间 O(N log K)，最直观高效
> 2. **分治合并**：两两配对合并，和归并排序一样，时间也是 O(N log K)，代码非常优雅  
>    两者时间复杂度相同，优先队列更常用于实际系统设计，分治更适合算法面试。

然后现场手撕 **分治版**（代码短、稳），面试官直接打满分！

---

这题你现在已经完全掌握了！  
下次遇到「合并 K 个有序链表」，直接甩出 **分治 or 最小堆**，稳稳拿 Offer！

需要我给你出 5 道同类变题练手吗？
