# 题

- 给你一个链表数组，每个链表都已经按升序排列。

- 请你将所有链表合并到一个升序链表中，返回合并后的链表。

## 示例 1：

输入：lists = `[[1,4,5],[1,3,4],[2,6]]`
输出：`[1,1,2,3,4,4,5,6]`
解释：链表数组如下：
[
1->4->5,
1->3->4,
2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

## 示例 2：

输入：lists = []
输出：[]

## 示例 3：

输入：lists = [[]]
输出：[]

# 解
**LeetCode 23. 合并 K 个升序链表**（Hard）—— 大厂面试必考 Top 3 链表题！

下面给你 **4 种解法**，从易懂到最优**，重点结合 **真实案例手推 + 动图级细节**，让你彻底掌握！

---

### 最终推荐解法：**优先队列（最小堆）** —— 面试最加分写法！

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */

class MinHeap {
    constructor() {
        this.heap = [];
    }
    push(node) {
        this.heap.push(node);
        this._siftUp(this.heap.length - 1);
    }
    pop() {
        if (this.heap.length === 1) return this.heap.pop();
        const root = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._siftDown(0);
        return root;
    }
    peek() { return this.heap[0]; }
    size() { return this.heap.length; }

    _siftUp(i) {
        while (i > 0) {
            {
            const parent = (i - 1) >> 1;
            if (this.heap[i].val < this.heap[parent].val) {
                [this.heap[i], this.heap[parent]] = [this.heap[parent], this.heap[i]];
                i = parent;
            } else break;
        }
    }
    _siftDown(i) {
        const n = this.heap.length;
        while (true) {
            let smallest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < n && this.heap[left].val < this.heap[smallest].val) {
                smallest = left;
            }
            if (right < n && this.heap[right].val < this.heap[smallest].val) {
                smallest = right;
            }
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}

var mergeKLists = function(lists) {
    const dummy = new ListNode(0);
    let curr = dummy;
    const heap = new MinHeap();

    // 1. 把所有链表的头节点入堆
    for (const head of lists) {
        if (head) heap.push(head);
    }

    2. 不断弹出最小节点，接在结果链表上
    while (heap.size() > 0) {
        const node = heap.pop();     // 当前全局最小的节点
        curr.next = node;
        curr = curr.next;

        if (node.next) {
            heap.push(node.next);    // 把这个链表的下一个节点加入竞争
        }
    }

    return dummy.next;
};
```

**时间复杂度：O(N log K)**（N 总节点数，K 是链表个数）  
**空间复杂度：O(K)**

这是 **面试中最推荐的写法**！清晰、高效、易扩展！

---

### 手推案例（经典！一定要跟上！）

输入：
```js
lists = [
  1 → 4 → 5,
  1 → 3 → 4,
  2 → 6
]
```

目标输出：`1 → 1 → 2 → 3 → 4 → 4 → 5 → 6`

#### 步骤演示：

| 步骤 | 堆中节点（按 val） | 弹出 | 当前结果链表         | 入堆新节点      |
|------|-------------------|------|---------------------|-----------------|
| 初始 | [1,1,2]           |      |                     |                 |
| 1    | [1,1,2] → 弹出 1  | 1    | 1                   | 入 4（第一个链表）|
| 2    | [1,2,4] → 弹出 1  | 1    | 1 → 1               | 入 3（第二个链表）|
| 3    | [2,3,4] → 弹出 2  | 2    | 1 → 1 → 2           | 入 6            |
| 4    | [3,4,6] → 弹出 3  | 3    | 1→1→2→3             | 入 4（第二个）  |
| 5    | [4,4,6] → 弹出 4  | 4    | 1→1→2→3→4           | 入 5            |
| 6    | [4,5,6] → 弹出 4  | 4    | 1→1→2→3→4→4         | 无              |
| 7    | [5,6] → 弹出 5    | 5    | 1→1→2→3→4→4→5       | 无              |
| 8    | [6] → 弹出 6      | 6    | 1→1→2→3→4→4→5→6     | 无              |

完美！

---

### 4 种解法对比（面试必背！）

| 解法                     | 时间复杂度         | 空间复杂度 | 推荐指数 | 说明 |
|--------------------------|--------------------|------------|----------|------|
| 1. 两两合并（递归/迭代） | O(N × K)           | O(1)       | 3 stars  | 简单但慢 |
| 2. 优先队列（最小堆）     | **O(N log K)**     | O(K)       | 5 stars  | 面试最佳！ |
| 3. 分治合并（两两配对）  | **O(N log K)**     | O(log K)   | 5 stars  | 优雅，推荐 |
| 4. 收集所有节点排序      | O(N log N)         | O(N)       | 2 stars  | 取巧，不推荐 |

---

### 解法3：分治合并（超级优雅！代码最短）

```javascript
var mergeKLists = function(lists) {
    if (!lists.length) return null;
    
    const mergeTwo = (l1, l2) => {
        let dummy = new ListNode(0);
        let tail = dummy;
        while (l1 && l2) {
            if (l1.val < l2.val) {
                tail.next = l1; l1 = l1.next;
            } else {
                tail.next = l2; l2 = l2.next;
            }
            tail = tail.next;
        }
        tail.next = l1 || l2;
        return dummy.next;
    };

    const divideAndConquer = (lists, start, end) => {
        if (start === end) return lists[start];
        if (start > end) return null;
        const mid = (start + end) >> 1;
        return mergeTwo(
            divideAndConquer(lists, start, mid),
            divideAndConquer(lists, mid + 1, end)
        );
    };

    return divideAndConquer(lists, 0, lists.length - 1);
};
```

这版代码最短、最优雅，**强烈推荐背下来**！

---

### 面试黄金话术（背会直接加分！）

> 面试官：合并 K 个有序链表怎么做？  
> 我：有两种最优解，我都能手写：  
> 1. **优先队列（最小堆）**：每次从 K 个链表头选最小值，时间 O(N log K)，最直观高效  
> 2. **分治合并**：两两配对合并，和归并排序一样，时间也是 O(N log K)，代码非常优雅  
> 两者时间复杂度相同，优先队列更常用于实际系统设计，分治更适合算法面试。

然后现场手撕 **分治版**（代码短、稳），面试官直接打满分！

---

这题你现在已经完全掌握了！  
下次遇到「合并 K 个有序链表」，直接甩出 **分治 or 最小堆**，稳稳拿 Offer！

需要我给你出 5 道同类变题练手吗？