# 题


- 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

 

## 示例 1：
![](./img/aaaa.png)


输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
## 示例 2：

输入：head = [1], n = 1
输出：[]
## 示例 3：

输入：head = [1,2], n = 1
输出：[1]

# 解
### 最优解：快慢指针（双指针）—— 面试必背！

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    // 创建虚拟头节点，防止删除的是头节点（比如只有一个节点或删头）
    const dummy = new ListNode(0);
    dummy.next = head;
    
    let fast = dummy;
    let slow = dummy;

    // 快指针先走 n+1 步（为什么是 n+1？后面解释）
    for (let i = 0; i < n + 1; i++) {
        fast = fast.next;
    }

    // 快慢指针一起走，直到 fast 走到 null
    // 此时 slow 就停在「倒数第 n 个节点的前一个节点」
    while (fast !== null) {
        fast = fast.next;
        slow = slow.next;
    }

    // 删除倒数第 n 个节点
    slow.next = slow.next.next;

    return dummy.next;  // 返回新头（可能变了）
};
```

### 经典案例手把手图解

```
示例：head = [1,2,3,4,5], n = 2
要删除倒数第2个节点 → 删除 4
```

| 步骤 | dummy → 1 → 2 → 3 → 4 → 5 → null |
|------|----------------------------------|
| 初始 | slow 和 fast 都在 dummy     | slow/fast<br>↓<br>dummy |
| 快指针先走 n+1 = 3 步               | fast 走到 3<br>fast → 3 |
| 快慢一起走                          | fast 到 null 时停止 |
| 最终状态                            | fast: null<br>slow: 3<br>↓<br>     3 → 4 → 5 |
| 执行 slow.next = slow.next.next     | 3 → 5（4 被跳过删除） |

结果：`[1,2,3,5]` 完美！

### 为什么快指针要先走 n+1 步？（核心！）

因为我们要找到 **倒数第 n 个节点的前一个节点**，才能删除。

- 总长度未知，但我们让 fast 先走 n+1 步
- 当 fast 到末尾（null）时，slow正好在「倒数第 n 个的前一个」
- 相当于 slow 和 fast 之间始终隔着 n 个节点

### 为什么一定要用 dummy 虚拟头节点？

因为可能删除的是第一个节点！

```
例子：head = [1], n = 1  → 删除唯一一个节点 → 返回 []
例子：head = [1,2], n = 2 → 删除 1 → 返回 [2]
```

如果不用 dummy，slow 无法指向头节点的前面，删除头就很麻烦。

用了 dummy：
```js
dummy → 1 → null
slow 在 dummy，执行 slow.next = slow.next.next → dummy → null
return dummy.next → null  完美！
```

### 终极记忆口诀（30秒写完！）

```
dummy做头防删首，
fast先冲n加1步，
一起走到fast空了，
slow就在倒数n前面，
slow.next跳过一个，
return dummy.next完事！
```

### 所有边界案例都能过！

| head         | n   | 结果           | 是否正确 |
|--------------|-----|----------------|----------|
| [1,2,3,4,5]  | 2   | [1,2,3,5]      | Yes      |
| [1]          | 1   | []             | Yes      |
| [1,2]        | 2   | [2]            | Yes      |
| [1,2]        | 1   | [1]            | Yes      |

### 最终推荐代码（最简洁版）

```js
var removeNthFromEnd = function(head, n) {
    const dummy = new ListNode(0, head);
    let fast = dummy;
    let slow = dummy;

    while (n-- > 0) fast = fast.next;  // 先走 n 步也行，但要 +1 更保险
    while (fast.next !== null) {       // 改成 fast.next 更清晰
        fast = fast.next;
        slow = slow.next;
    }

    slow.next = slow.next.next;
    return dummy.next;
};
```

这道题 + 合并两个有序链表 + 两数相加 + 环形链表入口  
这四道题背熟，链表题基本无敌了！

要不要我现在给你出 5 道进阶链表题（中等-困难）练手？比如：
- 反转链表 II
- 排序链表
- 链表随机节点
- 复制带随机指针的链表

随时说，我继续带你冲！