# 题

给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

## 示例 1：

![](./img/a.png)

输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

## 示例 2：

![](./img/b.png)

输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。

## 示例 3：

![](./img/c.png)

输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。

# 💯💯💯

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  // 1. 边界处理：空链表或只有一个节点，肯定无环
  if (!head || !head.next) return null;

  // 2. 初始化快慢指针，都从头节点开始
  let slow = head;
  let fast = head;

  // 3. 第一阶段：快慢指针找环内第一次相遇点
  while (fast && fast.next) {
    slow = slow.next; // 慢指针走 1 步
    fast = fast.next.next; // 快指针走 2 步

    // 相遇了！说明有环
    if (slow === fast) {
      // 4. 第二阶段：找入环点
      let p1 = head; // 从头开始的指针
      let p2 = slow; // 从相遇点开始的指针（这里用 slow 也行）

      // 两个指针都每次走 1 步，再次相遇的节点就是入环第一个节点
      while (p1 !== p2) {
        p1 = p1.next;
        p2 = p2.next;
      }

      return p1; // 或者 return p2，都一样
    }
  }

  // 5. 如果 fast 走到 null，说明没环
  return null;
};
```

### 图解过程（推荐你手画一下）

下面我用 **最清楚的逻辑 + 图示案例** 来详细解释你给出的这段“链表找环起点（Floyd 判圈算法）”代码。

---

# ⭐ 代码核心目标

给定一个单向链表，如果存在环，返回 **环的起点节点**；如果没有环，返回 `null`。

---

# 📌 整段算法分成两个阶段

1. **用快慢指针判断是否有环，并找到相遇点（第一次相遇）**
2. **根据数学性质，从头节点和相遇点同时出发，找到入环节点**

下面用一个具体案例来讲。

---

# 📚 案例讲解（最经典的示例）

假设链表如下图所示：

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20240909143926/1.webp?utm_source=chatgpt.com)

![Image](https://www.interviewbit.com/blog/wp-content/uploads/2021/12/Image-3.gif?utm_source=chatgpt.com)

链表结构为：

```
A → B → C → D → E → F
          ↑         ↓
          └─────────┘
```

其中 **C 是入环点**，从 C → D → E → F → C...

我们来模拟代码。

---

# 🧩 第 1 步：边界处理

```js
if (!head || !head.next) return null;
```

如果链表是空或只有一个节点，一定无环。

---

# 🧩 第 2 步：初始化快慢指针

```js
let slow = head;
let fast = head;
```

两个都从节点 A 出发。

---

# 🧱 第 3 步：快慢指针第一次相遇（判断是否有环）

快指针每次走 2 步，慢指针每次走 1 步。

模拟过程如下：

| 步数 | 慢指针 slow | 快指针 fast    |
| ---- | ----------- | -------------- |
| 1    | B           | C              |
| 2    | C           | E              |
| 3    | D           | C              |
| 4    | E           | E ←‼️ 相遇了！ |

当 slow == fast 时（两者都在 E），确定 **有环**。

---

# 🎯 关键数学结论（为什么相遇后可以找入口）

设：

- **a** = 从头节点到入环点的距离（A→B→C：2 步）
- **b** = 从入环点到第一次相遇点的距离（C→D→E：2 步）
- **c** = 环剩余部分长度（E→F→C：2 步）

数学推导得：

> 当快慢指针第一次相遇时
> **从相遇点出发的指针 + 从头节点出发的指针，每次走 1 步，最终会在“入环点”相遇。**

这是 Floyd 算法的核心。

---

# 🧩 第 4 步：寻找入环点

相遇后，代码执行：

```js
let p1 = head; // 从 A 出发
let p2 = slow; // 从第一次相遇点 E 出发
```

现在两个指针都每次走 1 步。

模拟过程：

| 步数 | p1（从头） | p2（从 E）     |
| ---- | ---------- | -------------- |
| 1    | A→B        | E→F            |
| 2    | B→C        | F→C ←‼️ 相遇！ |

它们在 **C** 相遇，这就是入环点。

---

# 🏁 最终返回：

```js
return p1; // 或 return p2
```

返回节点 C。

---

# 🎉 最终完整理解

这个算法之所以有效，是因为：

1. **第一次相遇证明链表存在环**
2. **相遇点与头节点同时出发（每次走一步），会在入环点相遇**

   - 这是快慢指针位移差产生的数学规律，不是巧合。

---

# ✨ 最终总结（用一句话）

> **快慢指针第一次相遇后，把其中一个放回链表头，两者一起每次走一步，会在入环点相遇，这就是环入口。**

---

如果你愿意，我还能再帮你：

✅ 画一个更详细的动画图解
✅ 提供几个不同形状的链表案例
✅ 解释此算法的数学原理（一步步推导公式）
✅ 给出时间复杂度和空间复杂度分析

要继续深入吗？

#

下面我用 **一个清晰的列表（List）** 来把整个算法执行过程逐步列出来，并继续使用案例链表：

```
A → B → C → D → E → F
          ↑         ↓
          └─────────┘
```

其中 **C 是入环点**。

---

# 📋 **完整过程列表（逐步列出每一步）**

---

## **阶段一：找到相遇点（判断是否有环）**

### **初始化**

- slow = A
- fast = A

---

### **第 1 次循环（slow 走 1 步，fast 走 2 步）**

- slow → B
- fast → C
  （未相遇）

---

### **第 2 次循环**

- slow → C
- fast → E
  （未相遇）

---

### **第 3 次循环**

- slow → D
- fast → C
  （未相遇）

---

### **第 4 次循环**

- slow → E
- fast → E
  ⚠️ **相遇了！说明存在环。相遇点在 E。**

---

## **阶段二：寻找入环点**

相遇后，创建两个指针：

- p1 = head（从 A 出发）
- p2 = slow（从相遇点 E 出发）

两个指针每次都走 **1 步**。

---

### **第 1 步**

- p1：A → B
- p2：E → F
  （未相遇）

---

### **第 2 步**

- p1：B → C
- p2：F → C
  ‼️ **二者都到达 C，表示找到入环点 C！**

---

# 🎉 **最终结果**

返回节点 **C**（环的入口）。

---

# 🔍 如你需要，我还可以提供：

- 同样步骤的 **图表版**（表格形式）
- **动画版**解释步骤
- **更复杂的链表示例**
- **推导为什么 p1 和 p2 会在入环点相遇的数学证明**

需要我继续扩展吗？