# 题

给你单链表的头节点 head ，请你**反转链表**，并返回**反转后的**链表。

## 示例 1：

![](./img/b1.png)

输入：`head = [1,2,3,4,5]`

输出：`[5,4,3,2,1]`

## 示例 2：

![](./img/b2.png)

输入：`head = [1,2]`

输出：`[2,1]`

## 示例 3：

输入：`head = []`

输出：`[]`

# 解

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = val;
 *     this.next = next || null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {Node}
 */
var reverseList = function (head) {
  let prev = null;
  let cur = head;

  while (cur !== null) {
    let next = cur.next; // 先保存下一个节点
    cur.next = prev; // 反转指针
    prev = cur; // prev 和 cur 都往前走一步
    cur = next;
  }

  return prev; // 最后 cur 为 null，prev 指向新头节点
};
```

太好了！我们就用你这版代码（**面试中最标准、最稳、最推荐的迭代写法**），结合一个具体例子，**手把手、一步一步、画图推演**，让你彻底明白为什么这几行代码能完美反转链表！

### 测试用例（经典例子）

```
原始链表：1 → 2 → 3 → 4 → 5 → null
目标：    5 → 4 → 3 → 2 → 1 → null
```

我们现在把每一次 while 循环都画出来看！

| 轮次     | prev | cur  | next（临时保存） | 执行 cur.next = prev 后 | prev 和 cur 移动后 | 当前链表真实样子（重点！）               |
| -------- | ---- | ---- | ---------------- | ----------------------- | ------------------ | ---------------------------------------- |
| 初始     | null | 1    | -                | -                       | -                  | 1→2→3→4→5→null                           |
| 第 1 轮  | null | 1    | 2                | 1→null                  | prev=1, cur=2      | 1→null 　　 2→3→4→5→null（1 被摘下来了） |
| 第 2 轮  | 1    | 2    | 3                | 2→1                     | prev=2, cur=3      | 2→1→null 　 3→4→5→null                   |
| 第 3 轮  | 2    | 3    | 4                | 3→2                     | prev=3, cur=4      | 3→2→1→null 　 4→5→null                   |
| 第 4 轮  | 3    | 4    | 5                | 4→3                     | prev=4, cur=5      | 4→3→2→1→null 　 5→null                   |
| 第 5 轮  | 4    | 5    | null             | 5→4                     | prev=5, cur=null   | 5→4→3→2→1→null 　（全部连好了！）        |
| 循环结束 | 5    | null | -                | -                       | -                  | 返回 prev → 5→4→3→2→1→null               |

完美！5 变成了新头节点。

### 再来一张超级清晰的动图式表格（建议保存！）

| 步骤 | 操作前的链表 | 保存 next | 反转当前指针 | 移动 prev 和 cur | 操作后的链表        |
| ---- | ------------ | --------- | ------------ | ---------------- | ------------------- |
| 1    | 1→2→3→4→5    | next=2    | 1→null       | prev=1, cur=2    | 1→null 　　 2→3→4→5 |
| 2    | 1←2→3→4→5    | next=3    | 2→1          | prev=2, cur=3    | 2→1→null 　 3→4→5   |
| 3    | 2←3→4→5      | next=4    | 3→2          | prev=3, cur=4    | 3→2→1→null 　 4→5   |
| 4    | 3←4→5        | next=5    | 4→3          | prev=4, cur=5    | 4→3→2→1→null 　 5   |
| 5    | 4←5          | next=null | 5→4          | prev=5, cur=null | 5→4→3→2→1→null      |

## 初始


## 1️⃣ `let prev = null; let cur = head;` 是不是“初始状态”？

### ✅ 是的，**这就是 while 循环开始前的初始状态**

```js
let prev = null;
let cur = head;
```

含义分别是：

* `prev = null`
  👉 表示**已经反转好的链表部分为空**

* `cur = head`
  👉 表示**当前要处理的节点，从原链表头节点开始**

此时**还没有做任何反转操作**，链表结构完全没变：

```
prev = null
cur  = head ──► 1 → 2 → 3 → 4 → 5 → null
```

---

## 2️⃣ 初始的 `cur` 为什么“是 1”？不是指向一个对象吗？

这个问题是**所有人学链表都会卡的点**，你现在问出来，说明理解在升级 👍
我们一定要区分这三件事：

### 🔹① `cur` 指向的是对象（这是本质）

```js
cur = head;
```

**本质上**：

```js
cur ──► { val: 1, next: {...} }
```

也就是说：

```js
typeof cur === 'object'
```

---

### 🔹② 那为什么我们老说“cur 是 1”？

这是为了**表达方便**。

当我说：

> “初始的 cur 是 1”

**真实含义是**：

> 👉 `cur` 指向的那个节点的 `val === 1`

也就是：

```js
cur.val === 1
```

而不是：

```js
cur === 1   // ❌ 不是
```

---

### 🔹③ 用一句话区分（非常重要）

| 表达         | 真正含义                     |
| ---------- | ------------------------ |
| `cur 是 1`  | `cur.val === 1`          |
| `cur 指向 1` | `cur` 指向 `val = 1` 的节点对象 |
| `cur 是对象`  | `{ val: 1, next: ... }`  |

👉 **永远记住：链表操作的是“节点对象”，不是值**

---

## 用代码验证你现在的理解（强烈推荐）

你可以在脑中或调试器里这样想：

```js
console.log(cur);      // { val: 1, next: {...} }
console.log(cur.val); // 1
console.log(cur.next.val); // 2
```

---

### 把两个问题合在一起的一句话总结（面试级）

> 1️⃣ `prev = null; cur = head;` 是反转链表的初始状态
> 2️⃣ `cur` 指向的是头节点对象，只是这个对象里的 `val` 恰好是 1，所以我们口头上说“cur 是 1”

