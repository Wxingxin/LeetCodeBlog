# 题

- 给你两个 **非空** 的链表，表示两个**非负**的整数。
- 它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

- 请你将两个数相加，并以相同形式返回一个表示和的**链表**。

- 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

## 示例 1：

输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.

## 示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]

## 示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]

# 解

### 题目核心理解（超级重要！）

```
输入：l1 = 2→4→3
      l2 = 5→6→4

含义：342 + 465 = 807

输出：7→0→8
     （逆序存储，所以结果是 7→0→8）
```

### 推荐写法（面试最优解：原地修改 + 虚拟头节点）

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
  const dummy = new ListNode(0); // 虚拟头节点
  let current = dummy;
  let carry = 0; // 进位，初始为 0

  // 只要有一个链表没遍历完，或者还有进位，就继续
  while (l1 !== null || l2 !== null || carry !== 0) {
    // 取出当前位的值（如果链表已经结束，用 0 补位）
    const x = l1 ? l1.val : 0;
    const y = l2 ? l2.val : 0;

    const sum = x + y + carry; // 当前位 + 进位
    carry = Math.floor(sum / 10); // 更新进位（只可能是 0 或 1）
    const digit = sum % 10; // 当前位要写入的结果

    // 创建新节点（或直接改 next）
    current.next = new ListNode(digit);
    current = current.next;

    // 指针前进
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
  }

  return dummy.next;
};
```

### 结合经典案例手把手执行（最经典例子）

```
l1 = 2 → 4 → 3
l2 = 5 → 6 → 4
```

| 步骤 | l1.val | l2.val | carry(进位) | sum | carry 更新 | digit | 新链表状态        |
| ---- | ------ | ------ | ----------- | --- | ---------- | ----- | ----------------- |
| 初始 | -      | -      | 0           | -   | -          | -     | dummy → null      |
| 1    | 2      | 5      | 0           | 7   | 0          | 7     | dummy → 7         |
| 2    | 4      | 6      | 0           | 10  | 1          | 0     | dummy → 7 → 0     |
| 3    | 3      | 4      | 1           | 8   | 0          | 8     | dummy → 7 → 0 → 8 |
| 4    | null   | null   | 0           | 0   | 0          | -     | 循环结束          |

返回：`7 → 0 → 8` → 代表 807 完美！

### 再来一个有进位到最高位的例子（容易出错！）

```
l1 = 9 → 9 → 9
l2 = 1
→ 999 + 1 = 1000
```

执行过程：

| 步骤 | x   | y   | carry | sum | 新 carry | digit | 新链表          |
| ---- | --- | --- | ----- | --- | -------- | ----- | --------------- |
| 1    | 9   | 1   | 0     | 10  | 1        | 0     | → 0             |
| 2    | 9   | 0   | 1     | 10  | 1        | 0     | → 0 → 0         |
| 3    | 9   | 0   | 1     | 10  | 1        | 0     | → 0 → 0 → 0     |
| 4    | 0   | 0   | 1     | 1   | 0        | 1     | → 0 → 0 → 0 → 1 |

结果：`0 → 0 → 0 → 1` → 1000 正确！

**关键点：while 条件里加了 `|| carry !== 0`，才能处理最高位进位！**

### 终极记忆口诀（背下来，面试 30 秒写完）

```
dummy做头，carry记进位，
while l1或l2或carry还有，
x y 取值（没了就补0），
sum = x + y + carry，
digit是个位，carry是十位，
current.next接新节点，
两个指针一起往前走，
最后返回dummy.next！
```

### 为什么这道题几乎所有面试都考？

因为它完美考察了：

- 链表遍历
- 边界处理（不同长度、进位）
- 代码细节（补 0、进位判断）
- 模拟真实算法思维（竖式加法）

### 总结：直接背这个版本，稳过！

```js
var addTwoNumbers = function (l1, l2) {
  const dummy = new ListNode();
  let cur = dummy;
  let carry = 0;

  while (l1 || l2 || carry) {
    const x = l1 ? l1.val : 0;
    const y = l2 ? l2.val : 0;
    const sum = x + y + carry;

    carry = sum >= 10 ? 1 : 0;
    cur.next = new ListNode(sum % 10);
    cur = cur.next;

    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
  }

  return dummy.next;
};
```

这段代码我敢说：**99%的面试官看完都会点头**。

需要我再给你出 5 道进阶题吗？比如：

- 445. 两数相加 II（正序存储！）
- 445 不用反转链表的解法
- 大数相加（字符串版）

随时说，我接着带你飞！