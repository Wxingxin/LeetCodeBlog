# 回文链表

给你一个单链表的头节点 `head` ，

请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

## 示例 1：

![](./img/c1.png)

**输入**：`head = [1,2,2,1]`

**输出**：`true`

## 示例 2：

![](./img/c2.png)

**输入**：`head = [1,2]`

**输出**：`false`

# 解

## 思路

## 二、解题思路总结（适合面试讲）

1️⃣ 核心思路

> **将链表转成数组，再判断数组是否是回文。**

因为：

- 链表只能从前往后遍历
- 数组可以通过下标从两端同时访问

---

2️⃣ 具体步骤

1. **遍历链表**

   - 从 `head` 开始
   - 把每个节点的 `val` 依次存入数组 `arr`

2. **使用双指针判断回文**

   - 左指针 `left` 指向数组开头
   - 右指针 `right` 指向数组末尾
   - 依次比较 `arr[left]` 和 `arr[right]`

3. **返回结果**

   - 只要有一对不相等，立即返回 `false`
   - 全部匹配，返回 `true`

## code

```js
/**
 * 判断一个单链表是否是回文链表
 * 思路：把链表的值存入数组，再用双指针判断数组是否回文
 * @param {ListNode} head
 * @return {boolean}
 */
```

```js
var isPalindrome = function (head) {
  // 用数组按顺序保存链表中所有节点的值
  let arr = [];

  // 遍历链表
  while (head) {
    arr.push(head.val); // 把当前节点的值存入数组
    head = head.next; // 指针后移，访问下一个节点
  }

  // 左右双指针，用于判断数组是否是回文
  let left = 0;
  let right = arr.length - 1;

  // 当左指针在右指针左侧时，继续比较
  while (left < right) {
    // 如果左右两端的值不相等，说明不是回文
    if (arr[left] !== arr[right]) return false;

    left++; // 左指针右移
    right--; // 右指针左移
  }

  // 所有对应位置都相等，是回文链表
  return true;
};
```

### 案例 1：回文链表（偶数长度）

```
链表：1 → 2 → 2 → 1 → null
```

| 步骤                                           | head 当前节点 | arr 内容  | left | right | 比较                        | 结果            |
| ---------------------------------------------- | ------------- | --------- | ---- | ----- | --------------------------- | --------------- |
| 初始                                           | 1             | []        | -    | -     | -                           | -               |
| 1                                              | →2            | [1]       | -    | -     | -                           | -               |
| 2                                              | →2            | [1,2]     | -    | -     | -                           | -               |
| 3                                              | →1            | [1,2,2]   | -    | -     | -                           | -               |
| 4                                              | →null（退出） | [1,2,2,1] | 0    | 3     | -                           | 进入双指针      |
| 第 1 轮比较                                    | -             | [1,2,2,1] | 0    | 3     | arr[0]=1 vs arr[3]=1 → 相等 | left→1, right→2 |
| 第 2 轮比较                                    | -             | [1,2,2,1] | 1    | 2     | arr[1]=2 vs arr[2]=2 → 相等 | left→2, right→1 |
| 现在 left=2, right=1 → left >= right，退出循环 |               |           |      |       |                             |
| 最终返回 true                                  |

完美！正确判断为回文

### 案例 2：回文链表（奇数长度）

```
链表：1 → 2 → 3 → 2 → 1 → null
```

| 步骤                                                 | head 当前节点 | arr 内容    | left | right | 比较                            |
| ---------------------------------------------------- | ------------- | ----------- | ---- | ----- | ------------------------------- |
| 遍历完                                               | null          | [1,2,3,2,1] | 0    | 4     |                                 |
| 第 1 轮                                              | -             | [1,2,3,2,1] | 0    | 4     | 1 vs 1 → 相等 → left=1, right=3 |
| 第 2 轮                                              | -             | [1,2,3,2,1] | 1    | 3     | 2 vs 2 → 相等 → left=2, right=2 |
| 现在 left === right，循环结束（中间的 3 不用比自己） |               |             |      |       |                                 |
| 返回 true                                            |

太棒了！奇数长度也完美处理，中间的 3 自动被跳过

### 案例 3：不是回文

```
链表：1 → 2 → 3 → null
```

| 步骤    | arr 内容 | left | right | 比较              | 结果           |
| ------- | -------- | ---- | ----- | ----------------- | -------------- |
| 遍历完  | [1,2,3]  | 0    | 2     |                   |                |
| 第 1 轮 | [1,2,3]  | 0    | 2     | 1 vs 3 → 不相等！ | 立即返回 false |

秒判！

### 案例 4：边界情况（面试官最爱问！）

| 链表           | arr   | left/right 移动               | 结果  | 说明           |
| -------------- | ----- | ----------------------------- | ----- | -------------- |
| null（空链表） | []    | left=0, right=-1 → 不进入循环 | true  | 空链表是回文   |
| 单个节点：5    | [5]   | left=0, right=0 → 不进入循环  | true  | 单个节点是回文 |
| 两个相同：1→1  | [1,1] | 比一次 1vs1 → 相等            | true  |                |
| 两个不同：1→2  | [1,2] | 比一次 1vs2 → 不相等          | false |                |

全部正确！

### 这版代码的灵魂（面试金句）

> “我先把所有值丢进数组，变成经典的‘双指针判断回文串’问题，代码不到 10 行，逻辑清晰无死角，绝对不会错！”

### 和 O(1) 空间解法对比（面试官一定会问）

| 解法           | 时间 | 空间 | 代码行数  | 理解难度 | 面试推荐场景                   |
| -------------- | ---- | ---- | --------- | -------- | ------------------------------ |
| 你这版（数组） | O(n) | O(n) | 8 行      | 1 星     | 前期保底、先写对、再优化       |
| 快慢指针+反转  | O(n) | O(1) | 25 行左右 | 3 星     | 面试官问“能优化空间吗？”时升级 |

### 面试实战建议（超实用！）

面试时你可以这样说（稳赢）：

> “我先写一个最直观、最不容易出错的版本，用数组存值 + 双指针，逻辑绝对正确，代码 8 行搞定。  
> 然后我再给您优化成 O(1) 空间的版本，用快慢指针找中点 + 反转后半段，您看需要吗？”

—— 既显得你思路清晰，又显得你有进阶能力，面试官听了直点头！

### 最终总结

你这段代码虽然不是最优空间，但绝对是：

- 最容易写对  
  最容易讲明白  
  最适合面试初期保底  
  最能体现“算法思维清晰”的版本！

背下来！遇到回文链表，先写这个，永远不会翻车！

```js
// 背会这8行，面试回文链表永远不慌！
var isPalindrome = function (head) {
  let arr = [];
  while (head) {
    arr.push(head.val);
    head = head.next;
  }
  let l = 0,
    r = arr.length - 1;
  while (l < r) {
    if (arr[l] !== arr[r]) return false;
    l++;
    r--;
  }
  return true;
};
```
