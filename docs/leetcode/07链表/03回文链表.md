# 题

- 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

## 示例 1：
![](./img/c1.png)

输入：head = [1,2,2,1]
输出：true

## 示例 2：
![](./img/c2.png)

输入：head = [1,2]
输出：false
# 解
太好了！你这版代码是 **最直观、最好理解、最适合初学者** 的写法 —— **用数组存值 + 双指针判断回文**！

虽然空间复杂度是 O(n)，不是最优解，但它 **100% 正确、代码最短、思路最清晰**，在面试中完全可以先写这个“保底解”，再优化！

我们就用你这段代码，结合两个经典案例，手把手、一步一步详细推演，保证你和面试官都能看懂每一行在干嘛！

```js
var isPalindrome = function(head) {
    let arr = []
    while(head){
        arr.push(head.val)
        head = head.next
    }
    let left = 0
    let right = arr.length - 1
    while(left < right){
        if(arr[left] !== arr[right]) return false
        left++
        right--
    }
    return true
};
```

### 案例 1：回文链表（偶数长度）
```
链表：1 → 2 → 2 → 1 → null
```

| 步骤 | head 当前节点 | arr 内容         | left | right | 比较               | 结果     |
|------|----------------|------------------|------|-------|---------------------|----------|
| 初始 | 1              | []               | -    | -     | -                   | -        |
| 1    | →2             | [1]              | -    | -     | -                   | -        |
| 2    | →2             | [1,2]            | -    | -     | -                   | -        |
| 3    | →1             | [1,2,2]          | -    | -     | -                   | -        |
| 4    | →null（退出）  | [1,2,2,1]        | 0    | 3     | -                   | 进入双指针 |
| 第1轮比较 | -           | [1,2,2,1]        | 0    | 3     | arr[0]=1 vs arr[3]=1 → 相等 | left→1, right→2 |
| 第2轮比较 | -           | [1,2,2,1]        | 1    | 2     | arr[1]=2 vs arr[2]=2 → 相等 | left→2, right→1 |
| 现在 left=2, right=1 → left >= right，退出循环 | | | | | |
| 最终返回 true |

完美！正确判断为回文

### 案例 2：回文链表（奇数长度）
```
链表：1 → 2 → 3 → 2 → 1 → null
```

| 步骤 | head 当前节点 | arr 内容            | left | right | 比较                  |
|------|----------------|---------------------|------|-------|------------------------|
| 遍历完 | null           | [1,2,3,2,1]         | 0    | 4     |                        |
| 第1轮 | -              | [1,2,3,2,1]         | 0    | 4     | 1 vs 1 → 相等 → left=1, right=3 |
| 第2轮 | -              | [1,2,3,2,1]         | 1    | 3     | 2 vs 2 → 相等 → left=2, right=2 |
| 现在 left === right，循环结束（中间的3不用比自己） | | | | | |
| 返回 true |

太棒了！奇数长度也完美处理，中间的3自动被跳过

### 案例 3：不是回文
```
链表：1 → 2 → 3 → null
```

| 步骤 | arr 内容       | left | right | 比较               | 结果         |
|------|----------------|------|-------|---------------------|--------------|
| 遍历完 | [1,2,3]      | 0    | 2     |                     |              |
| 第1轮 | [1,2,3]        | 0    | 2     | 1 vs 3 → 不相等！   | 立即返回 false |

秒判！

### 案例 4：边界情况（面试官最爱问！）

| 链表              | arr     | left/right 移动 | 结果 | 说明                     |
|-------------------|---------|------------------|------|---------------------------|
| null（空链表）    | []      | left=0, right=-1 → 不进入循环 | true | 空链表是回文             |
| 单个节点：5       | [5]     | left=0, right=0 → 不进入循环 | true | 单个节点是回文           |
| 两个相同：1→1     | [1,1]   | 比一次 1vs1 → 相等     | true |                          |
| 两个不同：1→2     | [1,2]   | 比一次 1vs2 → 不相等   | false|                          |

全部正确！

### 这版代码的灵魂（面试金句）

> “我先把所有值丢进数组，变成经典的‘双指针判断回文串’问题，代码不到10行，逻辑清晰无死角，绝对不会错！”

### 和 O(1) 空间解法对比（面试官一定会问）

| 解法            | 时间 | 空间 | 代码行数 | 理解难度 | 面试推荐场景                   |
|-----------------|------|------|----------|----------|---------------------------------|
| 你这版（数组）  | O(n) | O(n) | 8行      | 1星      | 前期保底、先写对、再优化       |
| 快慢指针+反转   | O(n) | O(1) | 25行左右 | 3星      | 面试官问“能优化空间吗？”时升级 |

### 面试实战建议（超实用！）

面试时你可以这样说（稳赢）：

> “我先写一个最直观、最不容易出错的版本，用数组存值 + 双指针，逻辑绝对正确，代码8行搞定。  
> 然后我再给您优化成 O(1) 空间的版本，用快慢指针找中点 + 反转后半段，您看需要吗？”

—— 既显得你思路清晰，又显得你有进阶能力，面试官听了直点头！

### 最终总结

你这段代码虽然不是最优空间，但绝对是：

- 最容易写对  
 最容易讲明白  
 最适合面试初期保底  
 最能体现“算法思维清晰”的版本！

背下来！遇到回文链表，先写这个，永远不会翻车！

```js
// 背会这8行，面试回文链表永远不慌！
var isPalindrome = function(head) {
    let arr = [];
    while (head) {
        arr.push(head.val);
        head = head.next;
    }
    let l = 0, r = arr.length - 1;
    while (l < r) {
        if (arr[l] !== arr[r]) return false;
        l++; r--;
    }
    return true;
};
```