给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

 

示例 1:
![](./img/aa.png)

输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
示例 2:

输入: preorder = [-1], inorder = [-1]
输出: [-1]

# 

直接拿你这段代码，带着例子
`preorder = [3,9,20,15,7]`
`inorder  = [9,3,15,20,7]`
一步一步跑一遍 👇

---

## 1⃣ 前置准备：indexMap

```js
const indexMap = new Map();
for (let i = 0; i < inorder.length; i++) {
    indexMap.set(inorder[i], i);
}
```

遍历 `inorder = [9,3,15,20,7]`，得到：

```txt
值 -> 中序下标
9  -> 0
3  -> 1
15 -> 2
20 -> 3
7  -> 4
```

也就是：

```js
indexMap.get(3)  === 1
indexMap.get(9)  === 0
indexMap.get(15) === 2
indexMap.get(20) === 3
indexMap.get(7)  === 4
```

这个表用来：**O(1) 找到某个值在中序遍历中的位置**。

---

## 2⃣ 第一次递归：整棵树

调用：

```js
build(0, 4, 0, 4)
```

* `preL = 0, preR = 4`，表示先序用的是 `preorder[0..4]` → `[3,9,20,15,7]`
* `inL  = 0, inR  = 4`，表示中序用的是 `inorder[0..4]` → `[9,3,15,20,7]`

### 2.1 确定根节点

```js
const rootVal = preorder[preL]; // preorder[0] = 3
const root = new TreeNode(3);
```

所以当前子树（整个树）的根是 `3`。

### 2.2 在中序中找 3 的位置

```js
const k = indexMap.get(rootVal); // indexMap.get(3) = 1
```

中序数组：[9, 3, 15, 20, 7]
索引：    [0, 1,  2,  3,  4]

`3` 在中序里的位置是 `1`，所以：

* 中序左边 `[0..0]` → `[9]` 是左子树
* 中序右边 `[2..4]` → `[15,20,7]` 是右子树

左子树的节点数：

```js
const leftSize = k - inL; // 1 - 0 = 1
```

### 2.3 划分左右子树的先序区间

左子树有 `1` 个节点，所以在先序中：

* 根是 `preL = 0` 位置（已经用掉）
* 左子树先序区间是 `[preL + 1 .. preL + leftSize]`

  * `[1 .. 1]` → `[9]`
* 右子树先序区间是 `[preL + leftSize + 1 .. preR]`

  * `[2 .. 4]` → `[20,15,7]`

所以接下来：

```js
root.left  = build(1, 1, 0, 0); // 左子树
root.right = build(2, 4, 2, 4); // 右子树
```

当前结果树只是：

```txt
  3
 / \
?   ?
```

---

## 3⃣ 构建左子树：build(1,1,0,0)

先序 `[1..1]` → `[9]`
中序 `[0..0]` → `[9]`

```js
const rootVal = preorder[1]; // 9
const root = new TreeNode(9);

const k = indexMap.get(9);  // 0
const leftSize = k - inL;   // 0 - 0 = 0
```

* 左子树节点数 = 0
* 中序：左子树区间 `[inL .. k-1] = [0 .. -1]`（空）
* 中序：右子树区间 `[k+1 .. inR] = [1 .. 0]`（空）
* 先序：左子树 `[preL+1 .. preL+leftSize] = [2 .. 1]`（空）
* 先序：右子树 `[preL+leftSize+1 .. preR] = [2 .. 1]`（空）

所以：

```js
root.left  = build(2, 1, 0, -1); // 返回 null
root.right = build(2, 1, 1,  0); // 返回 null
```

得到左子树就是单节点 `9`：

```txt
9
```

回到上一层，整棵树现在长这样：

```txt
   3
  /
 9
```

---

## 4⃣ 构建右子树：build(2,4,2,4)

先序 `[2..4]` → `[20,15,7]`
中序 `[2..4]` → `[15,20,7]`

```js
const rootVal = preorder[2]; // 20
const root = new TreeNode(20);

const k = indexMap.get(20); // 3
const leftSize = k - inL;   // 3 - 2 = 1
```

所以以 `20` 为根：

* 中序左子树 `[inL .. k-1] = [2 .. 2]` → `[15]`
* 中序右子树 `[k+1 .. inR] = [4 .. 4]` → `[7]`

左子树节点数 `leftSize = 1`，于是：

* 左子树先序 `[preL+1 .. preL+leftSize] = [3 .. 3]` → `[15]`
* 右子树先序 `[preL+leftSize+1 .. preR] = [4 .. 4]` → `[7]`

接下来调用：

```js
root.left  = build(3, 3, 2, 2); // 构建 20 的左子树
root.right = build(4, 4, 4, 4); // 构建 20 的右子树
```

此时右子树结构：

```txt
  20
 /  \
?    ?
```

---

## 5⃣ 构建 20 的左子树：build(3,3,2,2)

先序 `[3..3]` → `[15]`
中序 `[2..2]` → `[15]`

```js
const rootVal = preorder[3]; // 15
const root = new TreeNode(15);

const k = indexMap.get(15); // 2
const leftSize = k - inL;   // 2 - 2 = 0
```

左右子树区间都为空，递归都会直接返回 `null`：

```js
root.left  = build(4, 3, 2, 1); // null
root.right = build(4, 3, 3, 2); // null
```

得到：

```txt
15
```

---

## 6⃣ 构建 20 的右子树：build(4,4,4,4)

先序 `[4..4]` → `[7]`
中序 `[4..4]` → `[7]`

同样是叶子节点：

```js
const rootVal = preorder[4]; // 7
const root = new TreeNode(7);

const k = indexMap.get(7); // 4
const leftSize = k - inL;  // 4 - 4 = 0

root.left  = build(5, 4, 4, 3); // null
root.right = build(5, 4, 5, 4); // null
```

得到：

```txt
7
```

---

## 7⃣ 回溯组装整棵树

从下往上拼回去：

1. `build(3,3,2,2)` 返回节点 `15`
2. `build(4,4,4,4)` 返回节点 `7`
3. 以 `20` 为根：

```txt
  20
 /  \
15   7
```

4. 左子树 `9`，右子树是上面的 `20`：

整棵树：

```txt
      3
     / \
    9   20
       /  \
      15   7
```

这棵树的：

* 先序遍历：`[3, 9, 20, 15, 7]` ✅（对应 `preorder`）
* 中序遍历：`[9, 3, 15, 20, 7]` ✅（对应 `inorder`）

完全符合题意。

---

## 🔁 小结一下这段代码的核心点

1. **preorder[preL] 永远是当前子树的根**。
2. 在 `inorder` 中找到这个根的位置 `k`，根据下标划分出左/右子树的中序区间。
3. 用 `leftSize = k - inL` 得到左子树节点数量，再在先序中切出左/右子树对应的区间。
4. 递归构造左右子树，返回根节点。

如果你愿意，我也可以把这个过程改写成带「全局指针 preIndex」的另一种写法，再用同样的例子帮你对比两种写法的区别。
