# 💰💰💰

给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

### 示例 1：

输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]

![](./img/a.png)

### 示例 2：

输入：root = [1]
输出：[[1]]

### 示例 3：

输入：root = []
输出：[]

# 💯💯💯

好，我用 **JS 代码 + 经典案例演示** 帮你把这个 `levelOrder` 写完整。

---

## 一、题目：二叉树的层序遍历（LeetCode 102 经典）

**要求：**
给定一个二叉树，返回它的**层序遍历**结果（从上到下，从左到右一层一层地输出）。

---

## 二、核心思路（BFS 层序遍历）

用一个队列 `queue` 来做 **广度优先遍历（BFS）**：

1. 如果根节点 `root` 为空，直接返回 `[]`。
2. 把 `root` 放进队列。
3. 当队列不为空时：

   - 记录当前层的节点个数 `levelSize = queue.length`
   - 循环 `levelSize` 次，把当前层的所有节点依次出队：

     - 记录它们的 `val` 到 `level` 数组中
     - 如果有左子节点/右子节点，就分别入队

   - 当前层处理结束后，把 `level` 推入结果数组 `result`

---

## 三、完整 JS 代码实现

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
  if (!root) return []; // 空树，返回空数组

  const result = [];
  const queue = [root]; // 初始化队列，先把根节点放进去

  while (queue.length > 0) {
    const levelSize = queue.length; // 当前层的节点数量
    const level = []; // 用来记录当前层的所有节点值

    for (let i = 0; i < levelSize; i++) {
      // 从队列头部取出一个节点
      const node = queue.shift();
      level.push(node.val);

      // 把下一层的节点加入队列
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }

    // 当前层结束，加入结果
    result.push(level);
  }

  return result;
};
```

---

## 四、经典案例演示
好，我们就拿你这段层序遍历代码，配合这个例子：

```js
root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

来**完整地走一遍“数据在 result、queue、level 之间是怎么传递的”**。

---

## 1. 先把树的结构搞清楚

`[3,9,20,null,null,15,7]` 这类数组是按层序构建的二叉树，对应的是：

```text
        3
      /   \
     9     20
          /  \
         15   7
```

* 第 0 层：`3`
* 第 1 层：`9, 20`
* 第 2 层：`15, 7`

你的 `levelOrder` 要返回的是每一层的节点值：

```js
[
  [3],       // 第一层
  [9, 20],   // 第二层
  [15, 7]    // 第三层
]
```

---

## 2. 代码再看一眼

```javascript
var levelOrder = function (root) {
  if (!root) return []; // 1. 处理空树

  const result = [];
  const queue = [root]; // 2. 队列初始只有根节点

  while (queue.length > 0) {
    const levelSize = queue.length; // 3. 当前层的节点数量
    const level = [];               // 4. 当前层的结果数组

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();   // 5. 取出当前层的一个节点
      level.push(node.val);         // 6. 记录它的值

      if (node.left) queue.push(node.left);   // 7. 把下一层的子节点入队
      if (node.right) queue.push(node.right);
    }

    result.push(level);             // 8. 一层处理完，放进总结果
  }

  return result;
};
```

**关键点：**

* `queue`：保存当前还没处理的节点（按层，从左到右）
* `levelSize`：这一轮 while 中，**当前层有多少个节点**（非常关键）
* `level`：当前这一层的节点值列表，处理完一层就 push 到 `result`

---

## 3. 带着例子一步一步执行

### 初始化阶段

```js
if (!root) return [];
```

* `root` 不为 `null`，跳过

```js
const result = [];
const queue = [root];
```

此时：

* `result = []`
* `queue = [3]`（用节点的值来表示，实际里面是 TreeNode 对象）

---

### 第 1 轮 while 循环（处理第 1 层：节点 3）

条件：

```js
while (queue.length > 0) { ... }
```

此时 `queue.length = 1`，进入循环。

```js
const levelSize = queue.length; // levelSize = 1
const level = [];               // level = []
```

* 这一层有多少节点？`levelSize = 1`（就一个根节点 3）
* `level` 用来收集这一层的节点值

#### for 循环 - 遍历这一层的所有节点

```js
for (let i = 0; i < levelSize; i++) {
```

也就是：

```js
for (let i = 0; i < 1; i++) {
```

只会跑一次：`i = 0`。

---

#### 第 1 层，第 1 个节点（3）

```js
const node = queue.shift();
```

* `queue.shift()`：从队头取出一个节点
* 之前 `queue = [3]`
* 现在：

  * `node = 3`
  * `queue = []`

```js
level.push(node.val); // level.push(3)
```

* `level = [3]`

然后把 3 的左右孩子放进队列：

```js
if (node.left) queue.push(node.left);   // 有左孩子 9
if (node.right) queue.push(node.right); // 有右孩子 20
```

* 操作后 `queue = [9, 20]`

> 这一点很关键：
> **虽然我们现在还在处理“第 1 层”，但已经开始把“第 2 层”的节点存进 queue 里，等下一轮 while 来处理。**

##### 第 1 层处理完后：

for 循环结束（因为只执行了一次 i = 0），此时：

* `level = [3]`
* `queue = [9, 20]`（下一层的节点已经排好了）

```js
result.push(level);
```

* `result = [[3]]`

第 1 轮 while 结束。

---

### 第 2 轮 while 循环（处理第 2 层：节点 9 和 20）

当前状态：

* `queue = [9, 20]`
* `result = [[3]]`

进入 while：

```js
const levelSize = queue.length; // levelSize = 2
const level = [];               // level = []
```

这表示：

* 当前这一层有 `2` 个节点 → 也就是第 2 层的 `9` 和 `20`
* `level` 要记录它们的值

#### for 循环：这一层有两个节点，i 会是 0 和 1

```js
for (let i = 0; i < 2; i++) {
```

---

#### 第 2 层，第 1 个节点：9（i = 0）

```js
const node = queue.shift();
```

* `queue` 原来是 `[9, 20]`
* 现在：

  * `node = 9`
  * `queue = [20]`

```js
level.push(node.val); // level.push(9)
```

* `level = [9]`

9 的孩子：

```js
if (node.left) queue.push(node.left);   // 9.left = null -> 不加
if (node.right) queue.push(node.right); // 9.right = null -> 不加
```

此时：

* `queue = [20]`
* `level = [9]`

---

#### 第 2 层，第 2 个节点：20（i = 1）

第二次执行 for 循环体：

```js
const node = queue.shift();
```

* `queue` 原来 `[20]`
* 现在：

  * `node = 20`
  * `queue = []`

```js
level.push(node.val); // level.push(20)
```

* `level = [9, 20]`

20 的孩子（这是第 3 层的节点）：

```js
if (node.left) queue.push(node.left);   // 有左孩子 15
if (node.right) queue.push(node.right); // 有右孩子 7
```

* `queue = [15, 7]`

> 再次注意：我们现在处理的是**第 2 层**，
> 但已经把**第 3 层**的节点加入到了 queue 里。

for 循环这时结束（i 只有 0,1 两次），一整层处理完。

```js
result.push(level); // result.push([9, 20])
```

* `result = [[3], [9, 20]]`

第 2 轮 while 结束。

---

### 第 3 轮 while 循环（处理第 3 层：节点 15 和 7）

现在状态：

* `queue = [15, 7]`
* `result = [[3], [9, 20]]`

进 while：

```js
const levelSize = queue.length; // 2
const level = [];               // []
```

表示：

* 当前这一层有 2 个节点：15 和 7

---

#### 第 3 层，第 1 个节点：15（i = 0）

```js
const node = queue.shift();
// node = 15
// queue = [7]
```

```js
level.push(node.val); // level = [15]
```

15 没子节点：

```js
if (node.left) ...  // null
if (node.right) ... // null
```

* `queue = [7]`

---

#### 第 3 层，第 2 个节点：7（i = 1）

```js
const node = queue.shift();
// node = 7
// queue = []
```

```js
level.push(node.val); // level = [15, 7]
```

7 也没有子节点：

```js
if (node.left) ...
if (node.right) ...
// 都是 null
```

* `queue = []`

for 循环结束，一整层处理完。

```js
result.push(level); // result.push([15, 7])
```

* `result = [[3], [9, 20], [15, 7]]`

第 3 轮 while 结束。

---

### 第 4 轮 while？不会再进去了

此刻：

* `queue = []`
* `while (queue.length > 0)` 条件不满足

跳出 while，返回结果：

```js
return result;
// [[3], [9, 20], [15, 7]]
```

✅ 跟题目要求完全一致。

---

## 4. 数据流转总结（queue / level / result）

你可以这样理解整个过程：

1. **`queue`**：

   * 是“待处理节点”的队列
   * 当前 while 这一轮里，queue 中一开始的那些元素，是“当前层”的节点
   * 在 for 中，我们不断 `shift()` 出这些当前层的节点，同时 `push()` 进下一层的子节点

2. **`levelSize`**：

   * 非常关键！
   * 它在每一轮 while 的**一开始**就记录了“当前层有多少节点”
   * for 只循环 `levelSize` 次 → 确保这一轮只处理当前层，不会把下一层误认为当前层

3. **`level`**：

   * 当前层节点值的临时数组
   * 每次 while 开始时重置为 `[]`
   * 每处理一个节点，就 `level.push(node.val)`
   * 一层结束后：`result.push(level)`

4. **`result`**：

   * 大集合，里面装着每一层的小数组 `level`
   * 最终返回 `[[3], [9, 20], [15, 7]]`

---

如果你愿意，下一步我可以帮你把这个层序代码改成：

* 只输出每层的最后一个元素（就变成“右视图”了）
* 或者改成自底向上（变成“自底向上的层序遍历”）

这些都是同一套 BFS + queue 思路的“小变形”。
