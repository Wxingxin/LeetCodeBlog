# 题

- 给定一个二叉树 root ，返回其最大深度。

- 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。

## 示例 1：

![](./img/aa.png)

输入：root = [3,9,20,null,null,15,7]
输出：3

## 示例 2：

输入：root = [1,null,2]
输出：2

# 解 递归 DFS

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
  // 终止条件：空节点返回 0（这是天才设计！）
  if (root === null) {
    return 0;
  }

  // 递归求左右子树的最大深度
  const leftDepth = maxDepth(root.left);
  const rightDepth = maxDepth(root.right);

  // 当前子树深度 = 左右子树最大值 + 1
  return Math.max(leftDepth, rightDepth) + 1;
};
```

这 10 行代码，就是 LeetCode 上 99.9% 的 JavaScript 提交都会用的写法！

### 真实案例：一步步带你模拟执行过程

我们用下面这棵树来演示：

```javascript
    3
   / \
  9  20
    /  \
   15   7
```

手动构建这棵树（方便你本地测试）：

```javascript
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

// 构建示例树
const root = new TreeNode(3);
root.left = new TreeNode(9);
root.right = new TreeNode(20);
root.right.left = new TreeNode(15);
root.right.right = new TreeNode(7);
```

现在调用：`maxDepth(root)` → 期望返回 3

### 递归调用过程完整拆解（带调用栈）

```
调用栈模拟（从上到下表示后调的）：

1. maxDepth(3)                                 ← 当前在根节点
   ├── maxDepth(9)                             ← 左子树
   │   ├── maxDepth(null)  → 返回 0
   │   └── maxDepth(null)  → 返回 0
   │       → 返回 Math.max(0,0) + 1 = 1         ← 节点9深度为1
   │
   └── maxDepth(20)                            ← 右子树
       ├── maxDepth(15)                        ← 20的左孩子
       │   ├── maxDepth(null) → 0
       │   └── maxDepth(null) → 0
       │       → 返回 1                         ← 节点15深度为1
       │
       └── maxDepth(7)                         ← 20的右孩子
           ├── maxDepth(null) → 0
           └── maxDepth(null) → 0
               → 返回 1                         ← 节点7深度为1

       → 节点20: Math.max(1, 1) + 1 = 2         ← 右子树深度为2

→ 根节点3: Math.max(1, 2) + 1 = 3                ← 整棵树最大深度 = 3
```

### 为什么 `if (root === null) return 0` 是关键？

因为叶子节点的左右孩子都是 `null`：

```javascript
maxDepth(15的左孩子) → null → 返回 0
maxDepth(15的右孩子) → null → 返回 0
→ 15 的深度 = max(0,0) + 1 = 1   完全正确！
```

这就是为什么我们必须把空节点深度定义为 0 —— 它让叶子节点的深度自然变成 1，层层向上合成正确答案！

### 完整的可运行代码（直接复制到浏览器控制台测试）

```javascript
// 1. 定义节点类
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

// 2. 核心算法
var maxDepth = function (root) {
  if (root === null) return 0;

  const leftDepth = maxDepth(root.left);
  const rightDepth = maxDepth(root.right);

  return Math.max(leftDepth, rightDepth) + 1;
};

// 3. 构造测试用例
const root = new TreeNode(3);
root.left = new TreeNode(9);
root.right = new TreeNode(20);
root.right.left = new TreeNode(15);
root.right.right = new TreeNode(7);

// 4. 测试
console.log(maxDepth(root)); // 输出: 3
```

打开浏览器 F12 → Console → 粘贴运行 → 看到 `3` 就成功了！

### 面试时如何优雅讲解这道题（30 秒拿下）

> “求二叉树最大深度本质是后序遍历的典型应用。
>
> 我用递归分治的思想：  
> 一个节点的深度 = 它左右子树深度的较大值 + 1  
> 终止条件是遇到空节点返回 0（这样叶子节点深度自然就是 1）
>
> 时间复杂度 O(n)，空间复杂度 O(h)，h 是树高，最坏 O(n)。
>
> 这段代码几乎是所有树递归问题的模板，比如求直径、判断平衡树等，都可以基于它扩展。”

### 总结：JS 版 vs Python 版对比

| 语言       | 代码行数 | 关键差异                                 |
| ---------- | -------- | ---------------------------------------- |
| Python     | 6 行     | `if not root`                            |
| JavaScript | 10 行    | 要显式写 `root === null` 和 `Math.max()` |

但**思想完全一致**！记住这套模板，你用任何语言都能秒杀这题！

现在你已经完全掌握了用 JavaScript 写二叉树最大深度的最优雅方式，面试时写出来绝对让面试官眼前一亮！

下面给你一个 **最清晰、最接近真实执行过程的“图形化递归调用树”**，就像调用流程图一样，把 `maxDepth` 从根节点一路递归展开。

树结构：

```
      3
     / \
    9   20
        / \
       15  7
```

---

# 🌳 **图形化递归调用树（流程图版）**

> 每个框就是一次函数调用
> 箭头表示递归进入子树
> 返回值写在箭头旁边或节点下面
> 非常接近真实的执行顺序

---

## **① 从根节点开始：maxDepth(3)**

```
┌────────────────┐
│ maxDepth(3)    │
└───────┬────────┘
        │
        │ 计算 leftDepth = maxDepth(9)
        ▼
```

---

## **② 进入左子树：maxDepth(9)**

```
          ┌────────────────┐
          │ maxDepth(3)    │
          └───────┬────────┘
                  │
                  ▼
          ┌────────────────┐
          │ maxDepth(9)    │
          └───┬─────┬──────┘
              │     │
   left = ▼   │     │   ▼ right
        ┌────────┐   ┌────────┐
        │null → 0│   │null → 0│
        └────────┘   └────────┘
```

节点 9 返回：

```
maxDepth(9) = max(0, 0) + 1 = 1
```

将结果带回：

```
leftDepth = 1
```

---

## **③ 进入右子树：maxDepth(20)**

```
                ┌────────────────┐
                │ maxDepth(3)    │
                └───────┬────────┘
                        │
                        ▼
                ┌────────────────┐
                │ maxDepth(20)   │
                └───────┬────────┘
                        │
    ┌────────────────────┴────────────────────┐
    ▼                                         ▼
maxDepth(15)                             maxDepth(7)
```

---

## **④ 展开 maxDepth(15)**

```
        ┌────────────────────────────┐
        │        maxDepth(20)        │
        └──────────┬─────────────────┘
                   ▼
            ┌────────────────┐
            │ maxDepth(15)   │
            └───┬─────┬──────┘
                │     │
      left = ▼  │     │  ▼ right
           ┌────────┐   ┌────────┐
           │null → 0│   │null → 0│
           └────────┘   └────────┘
```

返回：

```
maxDepth(15) = 1
```

---

## **⑤ 展开 maxDepth(7)**

```
        ┌────────────────────────────┐
        │        maxDepth(20)        │
        └──────────┬─────────────────┘
                   ▼
            ┌────────────────┐
            │ maxDepth(7)    │
            └───┬─────┬──────┘
                │     │
      left = ▼  │     │  ▼ right
           ┌────────┐   ┌────────┐
           │null → 0│   │null → 0│
           └────────┘   └────────┘
```

返回：

```
maxDepth(7) = 1
```

---

## **⑥ 汇总节点 20 的左右子树深度**

节点 20：

```
leftDepth = maxDepth(15) = 1
rightDepth = maxDepth(7) = 1

maxDepth(20) = max(1, 1) + 1 = 2
```

---

## ⭐ 最终回到根节点 3

整棵树：

```
leftDepth  = maxDepth(9)  = 1
rightDepth = maxDepth(20) = 2

maxDepth(3) = max(1, 2) + 1 = 3
```

---

# 🌟 最终流程图（汇总版，一图看懂）

```
                                maxDepth(3)
                                /         \
                               /           \
                      maxDepth(9)        maxDepth(20)
                      /       \          /          \
                     0         0   maxDepth(15)   maxDepth(7)
                                      /    \        /     \
                                     0      0      0       0

       maxDepth(9)=1         maxDepth(15)=1     maxDepth(7)=1

                      maxDepth(20)=max(1,1)+1 = 2

            maxDepth(3)=max(1,2)+1 = 3   ← 最终答案
```

