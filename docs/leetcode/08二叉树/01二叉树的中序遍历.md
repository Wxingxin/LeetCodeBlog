# 题

- 给定一个二叉树的根节点 root ，返回 它的 **中序** 遍历 。

## 示例 1：

![](./img/a1.png)

输入：`root = [1,null,2,3]`

输出：`[1,3,2]`

## 示例 2：

输入：`root = []`

输出：`[]`

## 示例 3：

输入：`root = [1]`

输出：`[1]`

# 解

太好了！这段代码就是 **二叉树中序遍历的经典迭代写法**，被无数大厂面试官和 LeetCode 高赞答案奉为“标准模板”。  
我们来结合一个具体的树，一步一步手撕执行过程，彻底讲透它为什么是对的、每一行在干什么。

### 示例树（经典案例）

```
       1
      / \
     2   3
    / \
   4   5
```

中序遍历结果应该是：`[4, 2, 5, 1, 3]`

我们就用这棵树来完整模拟代码执行过程。

```javascript
var inorderTraversal = function (root) {
  const res = [];
  const stack = [];
  let curr = root; // curr 初始指向根节点 1

  while (curr || stack.length > 0) {
    // 第一部分：一直向左走，把所有左孩子压入栈
    while (curr) {
      stack.push(curr);
      curr = curr.left;
    }

    // 第二部分：弹出栈顶，访问它
    curr = stack.pop();
    res.push(curr.val);

    // 第三部分：转向右子树
    curr = curr.right;
  }

  return res;
};
```

### 完整执行过程（一步一步看）

| 步骤 | curr 当前指向                     | 内层 while (curr) 执行 | stack 内容（从底到顶） | 操作                 | res 内容    | 说明            |
| ---- | --------------------------------- | ---------------------- | ---------------------- | -------------------- | ----------- | --------------- |
| 1    | 1                                 | 推入 1 → curr = 2      | [1]                    |                      | []          | 开始向左走      |
| 2    | 2                                 | 推入 2 → curr = 4      | [1,2]                  |                      | []          | 继续向左        |
| 3    | 4                                 | 推入 4 → curr = null   | [1,2,4]                |                      | []          | 4 没有左孩子    |
| 4    | null                              | 内层 while 结束        | [1,2,4]                |                      | []          | 左子树走到底    |
| 5    | null                              |                        | [1,2]                  | 弹出 4 → res.push(4) | [4]         | 访问最左节点 4  |
| 6    | null → 现在 curr = 4.right = null |                        | [1,2]                  |                      | [4]         | 4 没有右子树    |
| 7    | null                              | 内层 while 不执行      | [1]                    | 弹出 2 → res.push(2) | [4,2]       | 访问节点 2      |
| 8    | curr = 2.right = 5                |                        | [1]                    |                      | [4,2]       | 转向 2 的右子树 |
| 9    | 5                                 | 推入 5 → curr = null   | [1,5]                  |                      | [4,2]       | 5 没有左孩子    |
| 10   | null                              | 内层 while 结束        | [1]                    | 弹出 5 → res.push(5) | [4,2,5]     | 访问 5          |
| 11   | curr = 5.right = null             |                        | [1]                    |                      | [4,2,5]     | 5 没有右子树    |
| 12   | null                              |                        | []                     | 弹出 1 → res.push(1) | [4,2,5,1]   | 访问根 1        |
| 13   | curr = 1.right = 3                |                        | []                     |                      | [4,2,5,1]   | 转向右子树 3    |
| 14   | 3                                 | 推入 3 → curr = null   | [3]                    |                      | [4,2,5,1]   | 3 没有左孩子    |
| 15   | null                              |                        | []                     | 弹出 3 → res.push(3) | [4,2,5,1,3] | 访问 3          |
| 16   | curr = 3.right = null             |                        | []                     |                      | [4,2,5,1,3] | 结束            |

最终 res = [4, 2, 5, 1, 3] 完全正确！

### 为什么这个模板这么经典？核心思想三句话记住就行：

```text
1. 能向左就向左走，边走边把节点扔进栈（记录“回头路”）
2. 走到不能左了（curr == null），就弹出栈顶节点访问它（左子树已处理完）
3. 访问完后去它的右子树继续重复上面过程
```

这其实就是在模拟递归的调用栈！

### 终极记忆模板（背下来，面试直接写）

```javascript
var inorderTraversal = function (root) {
  const res = [];
  const stack = [];
  let curr = root;

  while (curr || stack.length) {
    while (curr) {
      stack.push(curr);
      curr = curr.left;
    }
    curr = stack.pop();
    res.push(curr.val);
    curr = curr.right;
  }
  return res;
};
```
