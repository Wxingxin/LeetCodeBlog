# 题

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

示例 1：
![](./img3/a1.png)


输入：`root = [1,2,5,3,4,null,6]`
输出：`[1,null,2,null,3,null,4,null,5,null,6]`
示例 2：

输入：`root = []`
输出：`[]`
示例 3：

输入：`root = [0]`
输出：`[0]`

# 解

下面我在你给出的经典 Morris 思路版本基础上，**结合图示讲解 + 示例输入输出 + 代码执行过程追踪**，让你能彻底理解这段代码为何能把二叉树原地展开成先序遍历的链表。

---

# 🌳 一、题目回顾（Flatten Binary Tree to Linked List）

要求：

- 把二叉树原地展开成链表
- 按照 **先序遍历（根 → 左 → 右）**
- 展开的链表使用 `right` 指针连接
- 所有 `left` 必须置为 `null`

---

# 🧠 二、解题核心思想（Morris + 原地改指针）

对于每个节点 `cur`：

1. 若没有左子树 → 右移
2. 若有左子树：

   - 找到左子树的 **最右节点 pre**
   - 把 `cur.right` 接到 `pre.right`
   - 把左子树移到右边：`cur.right = cur.left`
   - 左子置空 `cur.left = null`

3. 然后 `cur = cur.right`

这样就把整棵树“摊平”为链表。

---

# 📌 三、经典示例（带图理解）

给定二叉树：

```
        1
       / \
      2   5
     / \   \
    3   4   6
```

正确的 flatten 结果链表（右指针）：

```
1 → 2 → 3 → 4 → 5 → 6
```

---

# 🔍 四、代码执行过程（逐步模拟）

### **第 1 步：cur = 1**

`1.left = 2`（存在左子树）

左子树最右节点是：`4`

```
 2
/ \
3  4   ← pre
```

修改指针：

```
pre.right = 5         // 原 1.right
1.right = 2           // 左子树挪到右边
1.left = null
```

树变成：

```
1
 \
  2
 / \
3   4
     \
      5
       \
        6
```

---

### **第 2 步：cur = 2**

`2.left = 3`

左子树最右节点是 `3`

修改指针：

```
3.right = 4
2.right = 3
2.left = null
```

树变为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

---

### **第 3 步：cur = 3**

左子树为空 → 继续右移

---

### **最终结果**

```
1 → 2 → 3 → 4 → 5 → 6
```

完全符合先序遍历顺序。

---

# ✅ 五、经典代码（你的版本，非常标准）

```js
var flatten = function (root) {
  let cur = root;

  while (cur !== null) {
    if (cur.left !== null) {
      // 1. 找到左子树的最右结点（前驱）
      let pre = cur.left;
      while (pre.right !== null) {
        pre = pre.right;
      }
      // 2. 把当前结点的右子树接到这个最右结点的右边
      pre.right = cur.right;
      // 3. 把左子树整体挪到右子树位置，左子指针置空
      cur.right = cur.left;
      cur.left = null;
    }
    // 4. 向右移动
    cur = cur.right;
  }
};
```

---

# 🎯 六、优点总结

| 方法                   | 空间复杂度  | 说明                     |
| ---------------------- | ----------- | ------------------------ |
| 栈模拟先序遍历         | O(n)        | 需要额外栈               |
| 递归                   | O(n)        | 递归栈                   |
| **Morris（本题代码）** | ⭐ **O(1)** | 只修改指针，不占额外空间 |

所以你实现的是 **最优解法**。

---

如果你愿意，我还能给你：

✅ 对比递归写法
✅ 对比栈写法
✅ 动态可视化模拟图
✅ LeetCode 题目扩展讲解

需要哪部分？
