# 划分字母区间

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s `。

返回一个表示每个字符串片段的长度的列表。

## 示例 1：

输入：`s = "ababcbacadefegdehijhklij"`

输出：`[9,7,8]`

解释：

划分结果为 `"ababcbaca"、"defegde"、"hijhklij" `。

每个字母最多出现在一个片段中。

像 `"ababcbacadefegde"`, `"hijhklij"` 这样的划分是错误的，因为划分的片段数较少。

## 示例 2：

输入：`s = "eccbbbbdec"`

输出：`[10]`

# Problem Solving

## ideas

1️⃣ 题目本质

> 将字符串划分成尽可能多的片段，使得
> **每个字母最多只出现在一个片段中**

---

2️⃣ 关键观察（最重要）

- 一个字符 **必须完整地落在同一个分区**
- 所以：

  - 如果某个字符在位置 `i` 出现
  - 它的分区 **至少要延伸到它最后一次出现的位置**

👉 因此，每个分区的右边界 =
**分区内所有字符“最后出现位置”的最大值**

---

3️⃣ 贪心策略（怎么想出来的）

**先算好“每个字符能走多远”**，然后：

- 从左到右遍历字符串
- 用 `end` 维护当前分区的最远边界
- 当遍历指针 `i === end`：

  - 说明当前分区内的字符已经全部“收齐”
  - 可以放心切一刀

---

4️⃣ 为什么这是贪心？

- **能切就立刻切**
- 提前切分不会影响后续合法性
- 且能保证分区数量最多

## code

```js
/**
 * @param {string} s   // 只包含小写字母的字符串
 * @return {number[]}  // 每个分区的长度
 */
```

```js
var partitionLabels = function (s) {
  // last[i] 表示字符 ('a' + i) 在字符串中最后一次出现的位置
  const last = new Array(26).fill(-1);

  // 1️⃣ 预处理：记录每个字符的最后出现位置
  for (let i = 0; i < s.length; i++) {
    last[s.charCodeAt(i) - 97] = i;// charCodeAt(i) - 97 将 'a'~'z' 映射为 0~25
  }

  const res = []; // 存放结果：每个分区的长度
  let start = 0; // 当前分区起始位置
  let end = 0; // 当前分区最远边界

  // 2️⃣ 贪心遍历字符串，动态确定分区
  for (let i = 0; i < s.length; i++) {
    // 更新当前分区的最远结束位置
    // 必须包含当前字符最后一次出现的位置
    end = Math.max(end, last[s.charCodeAt(i) - 97]);

    // 如果遍历位置到达分区最远边界
    // 说明当前分区内的字符不会再出现在后面
    if (i === end) {
      // 当前分区长度
      res.push(end - start + 1);
      // 开始下一个分区
      start = i + 1;
    }
  }

  return res;
};
```

## 结合示例一步一步讲（s = "ababcbacadefegdehijhklij"）

### 1）先统计每个字母的最后出现位置（last）

例如：

- `a` 最后在 index 8
- `b` 最后在 index 5
- `c` 最后在 index 7
- `d` 最后在 index 14
- `e` 最后在 index 15
- `f` 最后在 index 11
- `g` 最后在 index 13
- `h` 最后在 index 19
- `i` 最后在 index 22
- `j` 最后在 index 23
- `k` 最后在 index 20
- `l` 最后在 index 21
  （这些值来自对字符串扫一遍得到）

### 2）再扫一遍切片段（贪心）

维护：

- `start`：当前片段起点
- `end`：当前片段必须到达的最远位置（由片段中所有字符的 last 决定）

从 i=0 开始：

- i=0 是 `a`，`end = last[a]=8`
- i=1 是 `b`，`end = max(8, last[b]=5)=8`
- i=2 是 `a`，end 还是 8
- i=3 是 `b`，end 还是 8
- i=4 是 `c`，`end = max(8, last[c]=7)=8`
- ... 一直走到 i=8
  当 **i==end==8**：说明片段内的 a/b/c 都不会再出现在后面了
  ✅ 切第一段：长度 `8-0+1=9` → `"ababcbaca"`

继续第二段从 start=9：

- i=9 是 `d`，end=last[d]=14
- i=10 是 `e`，end=max(14,15)=15
- i=11 是 `f`，end=max(15,11)=15
- i=12 是 `e`，end=15
- i=13 是 `g`，end=max(15,13)=15
- i=14 是 `d`，end=15
- i=15 是 `e`，i==end
  ✅ 切第二段：长度 `15-9+1=7` → `"defegde"`

第三段从 start=16：

- 扫到 i=23 时 end 也会被推到 23
  ✅ 切第三段：长度 `23-16+1=8` → `"hijhklij"`

最终得到 `[9,7,8]`

---

### 一句话口诀

> **先算 last，扫一遍用 end 扩张；i 到 end 就切。**

如果你想，我也能用一个更短的例子（比如 `"eccbbbbdec"`）再走一遍，让你看清 `end` 为什么会被不断“拉长”。
