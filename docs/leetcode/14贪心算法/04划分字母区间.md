#  题
给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

返回一个表示每个字符串片段的长度的列表。

 

## 示例 1：
输入：`s = "ababcbacadefegdehijhklij"`
输出：`[9,7,8]`
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
## 示例 2：

输入：`s = "eccbbbbdec"`
输出：`[10]`
# 题

这题（LeetCode 763 划分字母区间）是经典 **贪心**：
先知道每个字符在字符串中**最后一次出现的位置**，再从左到右扫，维护当前片段必须覆盖到的最远位置 `end`。当扫到 `i === end`，说明这个片段里出现过的所有字母都“结束”了，就可以切一刀。

---

## 结合示例一步一步讲（s = "ababcbacadefegdehijhklij"）

### 1）先统计每个字母的最后出现位置（last）

例如：

* `a` 最后在 index 8
* `b` 最后在 index 5
* `c` 最后在 index 7
* `d` 最后在 index 14
* `e` 最后在 index 15
* `f` 最后在 index 11
* `g` 最后在 index 13
* `h` 最后在 index 19
* `i` 最后在 index 22
* `j` 最后在 index 23
* `k` 最后在 index 20
* `l` 最后在 index 21
  （这些值来自对字符串扫一遍得到）

### 2）再扫一遍切片段（贪心）

维护：

* `start`：当前片段起点
* `end`：当前片段必须到达的最远位置（由片段中所有字符的 last 决定）

从 i=0 开始：

* i=0 是 `a`，`end = last[a]=8`
* i=1 是 `b`，`end = max(8, last[b]=5)=8`
* i=2 是 `a`，end 还是 8
* i=3 是 `b`，end 还是 8
* i=4 是 `c`，`end = max(8, last[c]=7)=8`
* ... 一直走到 i=8
  当 **i==end==8**：说明片段内的 a/b/c 都不会再出现在后面了
  ✅ 切第一段：长度 `8-0+1=9` → `"ababcbaca"`

继续第二段从 start=9：

* i=9 是 `d`，end=last[d]=14
* i=10 是 `e`，end=max(14,15)=15
* i=11 是 `f`，end=max(15,11)=15
* i=12 是 `e`，end=15
* i=13 是 `g`，end=max(15,13)=15
* i=14 是 `d`，end=15
* i=15 是 `e`，i==end
  ✅ 切第二段：长度 `15-9+1=7` → `"defegde"`

第三段从 start=16：

* 扫到 i=23 时 end 也会被推到 23
  ✅ 切第三段：长度 `23-16+1=8` → `"hijhklij"`

最终得到 `[9,7,8]`

---

## JS 代码（可直接提交）

```js
/**
 * @param {string} s
 * @return {number[]}
 */
var partitionLabels = function(s) {
  const last = new Array(26).fill(-1);

  // 1) 记录每个字符最后出现位置
  for (let i = 0; i < s.length; i++) {
    last[s.charCodeAt(i) - 97] = i;
  }

  const res = [];
  let start = 0;
  let end = 0;

  // 2) 贪心划分
  for (let i = 0; i < s.length; i++) {
    end = Math.max(end, last[s.charCodeAt(i) - 97]);
    if (i === end) {
      res.push(end - start + 1);
      start = i + 1;
    }
  }

  return res;
};
```

---

### 一句话口诀

> **先算 last，扫一遍用 end 扩张；i 到 end 就切。**

如果你想，我也能用一个更短的例子（比如 `"eccbbbbdec"`）再走一遍，让你看清 `end` 为什么会被不断“拉长”。
