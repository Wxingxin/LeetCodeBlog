# 跳跃游戏 II

给定一个长度为 `n` 的 `0 `索引整数数组 `nums`。初始位置在下标 `0`。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j) `处：

`0 <= j <= nums[i]` 且`i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

## 示例 1:

输入: `nums = [2,3,1,1,4]`

输出: `2`

解释: 跳到最后一个位置的最小跳跃数是 `2`。

从下标为 `0` 跳到下标为 `1` 的位置，跳 `1` 步，然后跳 `3` 步到达数组的最后一个位置。

## 示例 2:

输入: `nums = [2,3,0,1,4]`

输出: `2`

# Problem Solving

## ideas

1.  问题本质

- 每个元素 `nums[i]` 表示 **从位置 i 最多能跳多远**
- 目标：用**最少的跳跃次数**到达数组最后一个位置

2.  贪心策略

- **不关心具体跳到哪里**
- 只关心：

  - 当前这一步最多能覆盖到哪 (`end`)
  - 在这个范围内，下一步能跳到的最远位置 (`far`)

3.  “分层遍历”的直观理解

- 把数组想象成一层一层的范围：

  - 第 1 层：第 1 次跳跃能到达的所有位置
  - 第 2 层：第 2 次跳跃能到达的所有位置

- 每“扫完一层”，跳跃次数 +1

4.  关键变量含义

| 变量    | 含义                                 |
| ------- | ------------------------------------ |
| `steps` | 已使用的跳跃次数                     |
| `end`   | 当前跳跃能到达的最远边界             |
| `far`   | 在当前边界内，下一跳能到达的最远位置 |

5.  为什么循环到 `n - 1`

- 一旦能到达最后一个位置，就不需要再跳
- 避免在终点处多加一次 `steps`

## code

```js
/**
 * 贪心算法 —— 跳跃游戏 II
 * 核心思想：按“层级”遍历，每一层代表一次跳跃能到达的范围
 *
 * @param {number[]} nums
 * @return {number}
 */
```

```js
var jump = function (nums) {
  const n = nums.length;

  let steps = 0; // 记录最少跳跃次数
  let end = 0; // 当前这一次跳跃所能覆盖到的最远边界
  let far = 0; // 在当前边界内，下一次跳跃能到达的最远位置

  // 遍历到倒数第二个位置即可
  // 因为一旦到达或超过最后一个位置，就不需要再跳
  for (let i = 0; i < n - 1; i++) {
    // 在当前可达范围内，持续更新“下一跳”的最远距离
    far = Math.max(far, i + nums[i]);

    // 当遍历指针 i 到达当前跳跃的边界 end
    // 说明这一跳能覆盖的范围已经走完
    if (i === end) {
      steps++; // 必须再跳一步
      end = far; // 更新新的覆盖边界，进入下一层
    }
  }

  return steps;
};
```

## 贪心思路（核心变量）

- `end`：**当前这一步**最多能到的最远下标（当前层的边界）
- `far`：在扫描当前层内所有点时，能得到的**下一步最远覆盖**
- `steps`：跳跃次数

扫描 `i = 0 ... n-2`（注意最后一个点不用扫）：

1. `far = max(far, i + nums[i])`
2. 当 `i == end`：说明当前这一步的范围扫完了，必须跳一次

   - `steps++`
   - `end = far`（进入下一步的覆盖范围）

---

## 结合示例一步一步走

`nums = [2,3,1,1,4]`

初始化：

- `steps=0`
- `end=0`（第 0 步能覆盖到哪？起点本身）
- `far=0`

### i=0

- `far = max(0, 0 + 2) = 2`
- `i == end`（0==0）→ 当前层结束，必须跳一次

  - `steps = 1`
  - `end = far = 2`
    解释：第一跳后，你**最远能到下标 2**（从 0 可以跳到 1 或 2）

---

### i=1（仍在当前层范围 [0..2] 内扫描）

- `far = max(2, 1 + 3) = 4`

### i=2

- `far = max(4, 2 + 1) = 4`
- `i == end`（2==2）→ 当前层结束，再跳一次

  - `steps = 2`
  - `end = far = 4`

此时 `end` 已经覆盖到最后下标 4，结束。
答案 `steps = 2` ✅

---

## JS 代码（可直接提交）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function (nums) {
  const n = nums.length;
  let steps = 0;
  let end = 0; // 当前步能覆盖到的边界
  let far = 0; // 下一步能覆盖到的最远位置

  for (let i = 0; i < n - 1; i++) {
    far = Math.max(far, i + nums[i]);

    // 扫到当前层的边界，必须跳一步进入下一层
    if (i === end) {
      steps++;
      end = far;
    }
  }

  return steps;
};
```

---

### 一句话记忆

> **扫描当前可达区间，更新下一步最远 far；到边界 end 就跳一次，把 end 更新成 far。**

如果你想，我也能用另一个例子（比如 `[2,3,0,1,4]`）再带你走一遍，帮助你更牢固地理解“分层边界 end”的含义。
