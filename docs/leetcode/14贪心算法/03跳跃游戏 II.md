# 题

给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。

每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：

`0 <= j <= nums[i]` 且`i + j < n`
返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

## 示例 1:

输入: nums = `[2,3,1,1,4]`
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

## 示例 2:

输入: nums = `[2,3,0,1,4]`
输出: 2

#

这题是 **Jump Game II（LeetCode 45）**，最经典解法是 **贪心 + 分层思想（像 BFS 但不用队列）**：
在“当前这一步能覆盖的区间”里，找一个点，使得“下一步能覆盖得最远”。

---

## 贪心思路（核心变量）

- `end`：**当前这一步**最多能到的最远下标（当前层的边界）
- `far`：在扫描当前层内所有点时，能得到的**下一步最远覆盖**
- `steps`：跳跃次数

扫描 `i = 0 ... n-2`（注意最后一个点不用扫）：

1. `far = max(far, i + nums[i])`
2. 当 `i == end`：说明当前这一步的范围扫完了，必须跳一次

   - `steps++`
   - `end = far`（进入下一步的覆盖范围）

---

## 结合示例一步一步走

`nums = [2,3,1,1,4]`

初始化：

- `steps=0`
- `end=0`（第 0 步能覆盖到哪？起点本身）
- `far=0`

### i=0

- `far = max(0, 0 + 2) = 2`
- `i == end`（0==0）→ 当前层结束，必须跳一次

  - `steps = 1`
  - `end = far = 2`
    解释：第一跳后，你**最远能到下标 2**（从 0 可以跳到 1 或 2）

---

### i=1（仍在当前层范围 [0..2] 内扫描）

- `far = max(2, 1 + 3) = 4`

### i=2

- `far = max(4, 2 + 1) = 4`
- `i == end`（2==2）→ 当前层结束，再跳一次

  - `steps = 2`
  - `end = far = 4`

此时 `end` 已经覆盖到最后下标 4，结束。
答案 `steps = 2` ✅

---

## JS 代码（可直接提交）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function (nums) {
  const n = nums.length;
  let steps = 0;
  let end = 0; // 当前步能覆盖到的边界
  let far = 0; // 下一步能覆盖到的最远位置

  for (let i = 0; i < n - 1; i++) {
    far = Math.max(far, i + nums[i]);

    // 扫到当前层的边界，必须跳一步进入下一层
    if (i === end) {
      steps++;
      end = far;
    }
  }

  return steps;
};
```

---

### 一句话记忆

> **扫描当前可达区间，更新下一步最远 far；到边界 end 就跳一次，把 end 更新成 far。**

如果你想，我也能用另一个例子（比如 `[2,3,0,1,4]`）再带你走一遍，帮助你更牢固地理解“分层边界 end”的含义。
