# 题

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。

设计一个算法来计算你所能获取的 **最大利润**。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

## 示例 1：

输入：`[7,1,5,3,6,4]`

输出：`5`

解释：在第 `2` 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 `= 6-1 = 5` 。
注意利润不能是 `7-1 = 6`, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

## 示例 2：

输入：prices = `[7,6,4,3,1]`

输出：`0`

解释：在这种情况下, 没有交易完成, 所以最大利润为` 0`。

# Problem Solving

## ideas

1️⃣ 问题本质

- **只能买一次、卖一次**
- **买在前，卖在后**
- 求最大 `卖出价 - 买入价`

---

2️⃣ 关键思想：

👉 **遍历过程中，始终记住“历史最低价”**

在每一天，你只需要做两件事：

1. **假设今天卖出**

   - 看看用「历史最低价」买入、今天卖出，能赚多少钱
   - 更新最大利润

2. **更新最低买入价**

   - 如果今天更便宜，就记下来，留给以后卖

---

3️⃣ 为什么这样能行？

- 不需要暴力枚举所有买卖组合（O(n²)）
- 每一天都在做“**局部最优选择**”
- 一次遍历即可完成（**O(n)**）

## code

```js
/**
 * @param {number[]} prices  // 股票每天的价格数组
 * @return {number}          // 能获得的最大利润
 */
```

```js
var maxProfit = function (prices) {
  // 如果天数小于等于 1 天，不可能完成买卖
  if (prices.length <= 1) return 0;

  // 记录到当前为止出现过的最低买入价格
  let minPrice = prices[0];

  // 记录最大利润，初始为 0（可以选择不交易）
  let maxProfit = 0;

  // 从第 2 天开始遍历
  for (let i = 1; i < prices.length; i++) {
    // 情况 1：假设今天卖出
    // 利润 = 今天价格 - 之前最低买入价
    maxProfit = Math.max(maxProfit, prices[i] - minPrice);

    // 情况 2：今天价格是否更低？
    // 如果更低，更新最低买入价，方便以后卖出赚更多
    minPrice = Math.min(minPrice, prices[i]);
  }

  // 返回最终得到的最大利润
  return maxProfit;
};
```

## EG 1

### 一步步演示 [7,1,5,3,6,4]

| 天数    | 价格 | minPrice | 当前利润(prices[i]-minPrice) | maxProfit | 解释                      |
| ------- | ---- | -------- | ---------------------------- | --------- | ------------------------- |
| 初始    |      | 7        |                              | 0         |                           |
| 第 2 天 | 1    | 1        | 1-7=负，不更新               | 0         | 发现更低价，更新 minPrice |
| 第 3 天 | 5    | 1        | 5-1=4                        | 4         | 刷新最大利润              |
| 第 4 天 | 3    | 1        | 3-1=2                        | 4         | 不如之前                  |
| 第 5 天 | 6    | 1        | 6-1=5                        | 5         | 最大利润！                |
| 第 6 天 | 4    | 1        | 4-1=3                        | 5         | 不变                      |

最终返回 5

### 更简洁的写法（面试手写推荐）

```js
var maxProfit = function (prices) {
  let minPrice = Infinity;
  let maxProfit = 0;

  for (let price of prices) {
    minPrice = Math.min(minPrice, price);
    maxProfit = Math.max(maxProfit, price - minPrice);
  }

  return maxProfit;
};
```

### 复杂度分析

- 时间复杂度：O(n) —— 只遍历一遍数组
- 空间复杂度：O(1) —— 只用了两个变量

### 总结口诀（面试必背！）

> 「想赚最多钱，就要在最低点买入。  
> 遍历每一天，都假设之前的最低点买入，今天卖出，看能赚多少。  
> 同时不断更新历史最低点。」

这个解法是所有股票系列题（121~123、188、309、714）的基石，务必掌握！

最终推荐代码：

```js
var maxProfit = function (prices) {
  let minPrice = Infinity;
  let profit = 0;
  for (let p of prices) {
    minPrice = Math.min(minPrice, p);
    profit = Math.max(profit, p - minPrice);
  }
  return profit;
};
```

#

好，我们就拿题目里的例子
`prices = [7, 1, 5, 3, 6, 4]`
把算法**从头到尾“跑一遍”**，把每一步变量怎么变都列出来。

先给出代码，后面对着代码讲：

```js
var maxProfit = function (prices) {
  if (!prices || prices.length === 0) return 0;

  let minPrice = prices[0]; // 到目前为止见过的最低价格
  let maxProfit = 0; // 到目前为止能得到的最大利润

  for (let i = 1; i < prices.length; i++) {
    const price = prices[i];
    const profit = price - minPrice; // 假设今天卖出，能赚多少

    if (profit > maxProfit) {
      maxProfit = profit; // 更新最大利润
    }

    if (price < minPrice) {
      minPrice = price; // 更新历史最低买入价
    }
  }

  return maxProfit;
};
```

---

## 核心变量

- `minPrice`：遍历到当前这一天为止，**最低的股价**（也就是最优买入价）
- `maxProfit`：遍历到当前这一天为止，**能获得的最大利润**
- `profit`：如果我在历史最低价那天买入，在**今天**卖出，能赚多少

---

## 示例：`[7, 1, 5, 3, 6, 4]` 详细过程

### 初始

- `minPrice = 7`（先设为第 0 天的价格）
- `maxProfit = 0`

从下标 `1` 开始遍历（也就是从第二天开始）：

| 天数 i | 价格 price | 当前 minPrice（历史最低） | 今天卖出的 profit = price - minPrice | 更新 maxProfit 后 | 是否更新 minPrice？ | 说明                                                                          |
| ------ | ---------- | ------------------------- | ------------------------------------ | ----------------- | ------------------- | ----------------------------------------------------------------------------- |
| 初始   | 7          | 7                         | -                                    | 0                 | -                   | 还没开始循环，只是初始化                                                      |
| 1      | 1          | 7                         | 1 - 7 = -6                           | maxProfit = 0     | ✅ minPrice = 1     | 今天价格 1 比历史最低 7 还低，所以更新最低价；profit 是负的，不更新 maxProfit |
| 2      | 5          | 1                         | 5 - 1 = 4                            | ✅ maxProfit = 4  | ❌（5 > 1）         | 如果在 1 元那天买，今天 5 元卖，可以赚 4，当前最好纪录 4                      |
| 3      | 3          | 1                         | 3 - 1 = 2                            | maxProfit = 4     | ❌（3 > 1）         | 今天卖赚 2，比之前的 4 小，不如之前那次                                       |
| 4      | 6          | 1                         | 6 - 1 = 5                            | ✅ maxProfit = 5  | ❌（6 > 1）         | 在 1 元买，6 元卖可以赚 5，比之前的 4 还高，更新为 5                          |
| 5      | 4          | 1                         | 4 - 1 = 3                            | maxProfit = 5     | ❌（4 > 1）         | 今天卖赚 3，不如 5，好机会还是第 2 天买第 5 天卖                              |

最终结果

- `maxProfit = 5`
  对应的是 **第 2 天价格 = 1 买入，第 5 天价格 = 6 卖出**，利润 `6 - 1 = 5`。

---

## EG 2

比如：`prices = [7, 6, 4, 3, 1]`（一直跌）

初始：

- `minPrice = 7`
- `maxProfit = 0`

| i   | price | minPrice（之前） | profit = price - minPrice | maxProfit 变化 | minPrice 变化 | 说明               |
| --- | ----- | ---------------- | ------------------------- | -------------- | ------------- | ------------------ |
| 1   | 6     | 7                | 6 - 7 = -1                | 仍为 0         | ✅ 变为 6     | 新的更低价格 6     |
| 2   | 4     | 6                | 4 - 6 = -2                | 仍为 0         | ✅ 变为 4     | 更低，继续记作最低 |
| 3   | 3     | 4                | 3 - 4 = -1                | 仍为 0         | ✅ 变为 3     | 更低               |
| 4   | 1     | 3                | 1 - 3 = -2                | 仍为 0         | ✅ 变为 1     | 更低               |

- 全程 `profit` 都是负的，所以 `maxProfit` 一直是 0
- 说明无论怎么买卖都会亏，只能选择 **不交易**，返回 0 ✅

---

## 小总结

1. **遍历一次数组**，动态维护：

   - `minPrice`：到当前为止最低价格
   - `maxProfit`：到当前为止最大利润

2. 每一天：

   - 先算：如果这一天卖出 `profit = price - minPrice`
   - 用 `profit` 去更新 `maxProfit`
   - 再用今天的价格更新 `minPrice`（如果更低）
