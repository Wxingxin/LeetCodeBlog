给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

 

示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
示例 3：

输入：nums = [], target = 0
输出：[-1,-1]
# 

这题是 **二分查找的左右边界模板题**（LeetCode 34）。
核心一句话：

> **用两次二分：一次找“第一个 ≥ target”，一次找“第一个 > target”**

---

## 一、整体思路（先有全局）

我们要的是：

* **左边界**：target 第一次出现的位置
* **右边界**：target 最后一次出现的位置

做法：

1. `left = lowerBound(target)` → 第一个 `>= target` 的位置
2. `right = lowerBound(target + 1) - 1`

如果 `left` 越界或 `nums[left] !== target`，说明 target 不存在。

---

## 二、结合示例一步一步走

### 示例

```txt
nums = [5,7,7,8,8,10]
target = 8
```

---

### 1️⃣ 找左边界（第一个 ≥ 8）

二分过程结果：

```txt
left = 3
nums[3] = 8
```

所以：

```txt
start = 3
```

---

### 2️⃣ 找右边界（第一个 ≥ 9）

即 `lowerBound(9)`：

结果：

```txt
left = 5
nums[5] = 10
```

所以：

```txt
end = 5 - 1 = 4
```

---

### 最终结果

```txt
[3, 4]
```

---

## 三、代码实现（标准可背模板）

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  const n = nums.length;

  // 找第一个 >= x 的位置
  function lowerBound(x) {
    let left = 0, right = n - 1;
    while (left <= right) {
      const mid = left + ((right - left) >> 1);
      if (nums[mid] >= x) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return left;
  }

  const start = lowerBound(target);

  // target 不存在
  if (start === n || nums[start] !== target) {
    return [-1, -1];
  }

  const end = lowerBound(target + 1) - 1;
  return [start, end];
};
```

---

## 四、为什么一定是 O(log n)？

* 每个 `lowerBound` 是一次二分 → `O(log n)`
* 总共 2 次二分 → `O(log n)`

---

## 五、常见错误提醒（面试高频）

❌ 错误 1：找到一个 target 就直接向两边扩散
→ 最坏 `O(n)`，不符合题意

❌ 错误 2：右边界用 `upperBound` 但写错条件
→ 最稳妥是 **`lowerBound(target+1) - 1`**

---

## 六、二分边界题一句话总结（必背）

> **左边界 = 第一个 ≥ target
> 右边界 = 第一个 ≥ (target+1) − 1**

如果你愿意，我可以把：

* `searchInsert`
* `searchMatrix`
* `searchRange`

这三题统一成 **一个二分查找模板表**，让你看到它们其实是同一类题。
