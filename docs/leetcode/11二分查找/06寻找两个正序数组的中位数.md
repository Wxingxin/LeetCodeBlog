给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

 

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

## 

这是 **LeetCode 困难题：寻找两个正序数组的中位数** 的**标准最优解**，时间复杂度 **O(log(min(m,n)))**，也是面试最爱考的版本。
我会 **先给你完整可直接提交的 JS 代码**，再 **一步一步拆解思路**，保证你能讲清楚。

---

## ✅ 一、完整 JS 实现（O(log(m+n))）

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
  // 保证 nums1 是较短的数组（在短数组上二分）
  if (nums1.length > nums2.length) {
    return findMedianSortedArrays(nums2, nums1);
  }

  const m = nums1.length;
  const n = nums2.length;

  let left = 0;
  let right = m;

  while (left <= right) {
    // nums1 的分割位置
    const i = Math.floor((left + right) / 2);
    // nums2 的分割位置（保证左边总数相同）
    const j = Math.floor((m + n + 1) / 2) - i;

    // 边界处理：越界用 ±Infinity
    const nums1LeftMax  = (i === 0) ? -Infinity : nums1[i - 1];
    const nums1RightMin = (i === m) ?  Infinity : nums1[i];

    const nums2LeftMax  = (j === 0) ? -Infinity : nums2[j - 1];
    const nums2RightMin = (j === n) ?  Infinity : nums2[j];

    // 找到正确分割
    if (nums1LeftMax <= nums2RightMin && nums2LeftMax <= nums1RightMin) {
      // 总长度为奇数
      if ((m + n) % 2 === 1) {
        return Math.max(nums1LeftMax, nums2LeftMax);
      }
      // 总长度为偶数
      return (
        Math.max(nums1LeftMax, nums2LeftMax) +
        Math.min(nums1RightMin, nums2RightMin)
      ) / 2;
    }

    // nums1 左边太大，i 需要左移
    if (nums1LeftMax > nums2RightMin) {
      right = i - 1;
    } 
    // nums1 左边太小，i 需要右移
    else {
      left = i + 1;
    }
  }

  return 0; // 理论上不会走到这里
};
```

---

## 🧠 二、核心思路（这是面试官真正想听的）

### 1️⃣ 为什么不能直接合并数组？

* 合并：`O(m + n)` ❌
* 题目要求：`O(log(m + n))` ✅
  👉 **必须用二分**

---

### 2️⃣ 中位数的本质

中位数 =

> **把所有数分成左右两部分**

* 左边元素数量 = 右边（或多 1）
* 左边最大值 ≤ 右边最小值

---

### 3️⃣ 二分的关键思想（核心）

不是在“值”上二分，而是在 **“数组切割位置”上二分**

```
nums1: [ ... | ... ]
            ↑ i

nums2: [ ... | ... ]
            ↑ j
```

满足：

```
i + j = (m + n + 1) / 2
```

---

### 4️⃣ 正确切割的判断条件 ⭐⭐⭐

```text
nums1[i - 1] <= nums2[j]
nums2[j - 1] <= nums1[i]
```

只要这两个条件同时满足：
👉 中位数就在边界附近

---

### 5️⃣ 为什么要保证在短数组上二分？

* 二分次数：`log(min(m,n))`
* 避免 j 越界
* 面试标准写法

---

## 📌 三、举个例子（nums1 = [1,2], nums2 = [3,4]）

```
nums1: [1 | 2]
nums2: [3 | 4]

左边最大值 = max(1, 3) = 3
右边最小值 = min(2, 4) = 2 ❌ 不合法
```

调整 i → 继续二分，直到满足条件
最后中位数 = `(2 + 3) / 2 = 2.5`

---

## 🎯 四、你在面试中可以这样总结（高分话术）

> 这道题不能合并数组，否则是 O(m+n)。
> 我把问题转化为 **在两个有序数组中找一个切割点**，
> 使得左边元素个数等于右边（或多一个），
> 并且左边最大值 ≤ 右边最小值。
>
> 因为数组有序，所以我在 **较短数组上用二分** 查找切割位置，
> 每次只比较边界元素，时间复杂度是 `O(log(min(m,n)))`。

---

## 🚀 下一步建议

如果你愿意，我可以帮你：

* ✍️ 写 **“通俗版口诀记忆法”**
* 🧩 用 **图解 + 动画式步骤** 再讲一遍
* 🎤 帮你整理 **面试 1 分钟讲解模板**

你选一个 👇
