已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

 

示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
示例 2：

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
示例 3：

输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
# 

这题是 **LeetCode 153：寻找旋转排序数组中的最小值**。
关键：数组元素互不相同，所以可以用**二分**，每次通过 `nums[mid]` 和 `nums[right]` 的关系判断最小值在哪一边。

---

## 核心规律（背这个就够了）

把数组想成两段递增的拼接：

* 若 `nums[mid] > nums[right]`
  说明 `mid` 在“左段”（较大那段），**最小值一定在 mid 的右边**
  → `left = mid + 1`

* 否则（`nums[mid] < nums[right]`）
  说明 `mid` 在“右段”（包含最小值那段），**最小值在 mid 或左边**
  → `right = mid`

最终 `left == right`，就是最小值位置。

---

## 结合示例一步一步走

`nums = [3,4,5,1,2]`

* 初始：`left=0 right=4`，`nums[right]=2`

* `mid=2` → `nums[mid]=5`

  * 5 > 2 ✅ → 最小值在右边
    `left = mid + 1 = 3`

* 现在：`left=3 right=4`，`nums[right]=2`

* `mid=3` → `nums[mid]=1`

  * 1 < 2 ✅ → 最小值在 mid 或左边
    `right = mid = 3`

* 结束：`left=3 right=3`
  最小值 `nums[3]=1`

---

## JS 代码（可直接提交）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  let left = 0;
  let right = nums.length - 1;

  while (left < right) {
    const mid = left + ((right - left) >> 1);

    if (nums[mid] > nums[right]) {
      // 最小值在右边
      left = mid + 1;
    } else {
      // 最小值在 mid 或左边
      right = mid;
    }
  }

  return nums[left];
};
```

---

### 一句话记忆

> **跟 nums[right] 比：mid 大 → 去右边；mid 小 → 收缩到 mid。**

如果你愿意，我可以顺手把它和上一题“旋转数组找 target（33题）”放一起对比，让你看出它们的二分判断其实是一套逻辑。
