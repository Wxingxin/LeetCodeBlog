# 题目

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。

请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

## 示例 1：

输入：`intervals = [[1,3],[2,6],[8,10],[15,18]]`

输出：`[[1,6],[8,10],[15,18]]`

解释：区间 `[1,3]` 和 `[2,6]` 重叠, 将它们合并为 `[1,6]`.

## 示例 2：

输入：`intervals = [[1,4],[4,5]]`

输出：`[[1,5]]`

解释：区间 `[1,4]` 和 `[4,5]` 可被视为重叠区间。

## 示例 3：

输入：`intervals = [[4,7],[1,4]]`

输出：`[[1,7]]`

解释：区间 `[1,4]` 和 `[4,7]` 可被视为重叠区间。

# Problem Solving

```js
var merge = function (intervals) {
  if (intervals.length === 0) return [];

  // 1. 按区间起点排序
  intervals.sort((a, b) => a[0] - b[0]);

  // 2. 结果数组，先放一个
  const res = [];
  res.push(intervals[0]); // 先把第一个区间放进去

  // 3. 遍历之后的区间
  for (let i = 1; i < intervals.length; i++) {
    const current = intervals[i]; // 当前区间
    const last = res[res.length - 1]; // 结果里最后一个区间

    // 如果当前区间的起点 <= last 的终点，说明有重叠，需要合并
    if (current[0] <= last[1]) {
      // 更新 last 的终点为两者中较大的那个
      last[1] = Math.max(last[1], current[1]);
      // 注意：这里直接改 last 就相当于改了 res 里的最后一个区间
    } else {
      // 否则没有重叠，直接加入结果数组
      res.push(current);
    }
  }

  return res;
};
```

这道就是经典的 **56. 合并区间**。

---

## 一、题目要干啥？

给你一堆区间，比如：

```js
intervals = [
  [1, 3],
  [2, 6],
  [8, 10],
  [15, 18],
];
```

这些区间有的互相重叠、有的互相独立。
你要把**所有能合并的区间合并掉**，最后返回一个**互不重叠、且覆盖原有所有区间**的新数组。

上面这个例子的答案是：

```js
[
  [1, 6],
  [8, 10],
  [15, 18],
];
```

因为：

- `[1,3]` 和 `[2,6]` 有重叠，能合并成 `[1,6]`
- `[8,10]` 和 `[15,18]` 本来就不重叠，保留

---

## 二、核心思路（排序 + 一次扫描）

**关键操作：先按区间起点排序。**

步骤：

1. 如果数组为空或长度为 0，直接返回 `[]`
2. 按每个区间的起点 `start` 从小到大排序
3. 准备一个结果数组 `res`，先把排序后的第一个区间放进去
4. 从第二个区间开始，逐个和 `res` 里的“最后一个区间”比较：

   - 记：

     - 当前处理的区间是 `[start, end]`
     - 结果数组最后一个区间是 `last = res[res.length - 1]` → `[lastStart, lastEnd]`

   - 如果 `start` > `lastEnd`：

     - 说明**没有重叠**，直接把当前区间丢进 `res`

   - 否则（`start <= lastEnd`）：

     - 有重叠，需要 **合并**
     - 合并后的区间是：`[lastStart, max(lastEnd, end)]`
     - 直接更新 `res` 中最后一个区间的 `end` 值：`last[1] = Math.max(last[1], end)`

---

## 三、用例详解

用这个例子讲一遍：

```js
intervals = [
  [1, 3],
  [2, 6],
  [8, 10],
  [15, 18],
];
```

### 1. 排序

按照起点排序（其实它本来就是有序的）：

```js
[
  [1, 3],
  [2, 6],
  [8, 10],
  [15, 18],
];
```

### 2. 初始化结果数组

```js
res = [[1, 3]];
```

### 3. 遍历剩下区间

#### 处理 `[2,6]`：

- `last = [1,3]`
- 当前区间 `[2,6]` 的 start = 2
- 判断是否重叠：

  - `2 <= 3` → 有重叠

- 合并：
  新的区间起点 = 1（不变）
  新的区间终点 = `max(3, 6) = 6`
- 更新 `res` 最后一个为 `[1,6]`：

```js
res = [[1, 6]];
```

---

#### 处理 `[8,10]`：

- `last = [1,6]`
- 当前 `[8,10]` 的 start = 8
- `8 > 6` → 没有重叠
  直接放进结果数组：

```js
res = [
  [1, 6],
  [8, 10],
];
```

---

#### 处理 `[15,18]`：

- `last = [8,10]`
- 当前 `[15,18]` 的 start = 15
- `15 > 10` → 没有重叠
  直接放进结果数组：

```js
res = [
  [1, 6],
  [8, 10],
  [15, 18],
];
```

遍历结束，`res` 就是答案。

---

---

## 五、复杂度分析

- 排序：O(n log n)
- 一次遍历合并：O(n)
  → 总时间复杂度：**O(n log n)**
  空间复杂度：**O(1)（如果不算结果数组）**，否则 O(n)。

---

如果你愿意，可以给我一组你自己的 `intervals`，我可以按照上面的代码逻辑帮你把每一步的 `res` 状态都推一遍，让你更有感觉。