# 轮转数组

给你一个整数数组` nums `，有一个大小为` k `的滑动窗口从数组的最左侧移动到数组的最右侧。

你只可以看到在滑动窗口内的` k `个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的 **最大值** 。

## 示例 1：

输入：`nums = [1,3,-1,-3,5,3,6,7], k = 3`

输出：`[3,3,5,5,6,7]`

解释：

滑动窗口的位置 最大值


```
[1 3 -1] -3 5 3 6 7 3
1 [3 -1 -3] 5 3 6 7 3
1 3 [-1 -3 5] 3 6 7 5
1 3 -1 [-3 5 3] 6 7 5
1 3 -1 -3 [5 3 6] 7 6
1 3 -1 -3 5 [3 6 7] 7
```
## 示例 2：

输入：`nums = [1], k = 1`
输出：`[1]`

# Problem Solving

## code

```js
/**
 * @param {number[]} nums  输入数组
 * @param {number} k      滑动窗口大小
 * @return {number[]}     每个窗口的最大值
 */
```
```js
var maxSlidingWindow = function (nums, k) {
  const n = nums.length;
  // 边界情况：数组为空或窗口大小为 0
  if (n === 0 || k === 0) return [];

  // 双端队列，存的是「数组下标」
  // 队列中对应的 nums 值是「单调递减」的
  const deque = [];

  // 结果数组，保存每个窗口的最大值
  const result = [];

  // 遍历数组
  for (let i = 0; i < n; i++) {

    // ===== 步骤 1：移除滑出窗口的元素 =====
    // 如果队头下标已经不在当前窗口范围内（i - k）
    if (deque.length > 0 && deque[0] === i - k) {
      deque.shift(); // 移除队头
    }

    // ===== 步骤 2：维护单调递减队列 =====
    // 当前元素 nums[i] 比队尾对应的值大
    // 那么队尾永远不可能成为最大值，直接移除
    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }

    // ===== 步骤 3：加入当前元素下标 =====
    deque.push(i);

    // ===== 步骤 4：窗口形成后，记录最大值 =====
    // 当 i >= k - 1，窗口大小达到 k
    // 队头元素始终是当前窗口的最大值
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }

  return result;
};

```

这是经典的「滑动窗口最大值」问题，我们一步一步来讲清楚思路和过程。

### 手把手案例演示（nums = [1,3,-1,-3,5,3,6,7], k=3）

| i   | 当前元素 | 移除滑出窗口                     | 移除比自己小的                             | 入队 | 当前队列(deque) | 窗口已形成？ | 结果          |
| --- | -------- | -------------------------------- | ------------------------------------------ | ---- | --------------- | ------------ | ------------- |
| 0   | 1        | -                                | -                                          | →1   | [0]             | 否           |               |
| 1   | 3        | -                                | 1<3 → 移除 0                               | →3   | [1]             | 否           |               |
| 2   | -1       | -                                | -1<3 不移除                                | →-1  | [1,2]           | 是 → 最大=3  | [3]           |
| 3   | -3       | -                                | -3<-1 不移除                               | →-3  | [1,2,3]         | 是 → 最大=3  | [3,3]         |
| 4   | 5        | -                                | 5>-3→ 移除 3<br>5>-1→ 移除 2<br>5<3 不移除 | →5   | [1,4]           | 是 → 最大=5  | [3,3,5]       |
| 5   | 3        | 下标 1 滑出(i- k=5-3=2) → 移除 1 | 3<5 不移除                                 | →3   | [4,5]           | 是 → 最大=5  | [3,3,5,5]     |
| 6   | 6        | -                                | 6>3→ 移除 5<br>6>5→ 移除 4                 | →6   | [6]             | 是 → 最大=6  | [3,3,5,5,6]   |
| 7   | 7        | -                                | 7>6→ 移除 6                                | →7   | [7]             | 是 → 最大=7  | [3,3,5,5,6,7] |

---

## 一、题目再描述一下

给定：

- 一个整数数组 `nums`
- 一个窗口大小 `k`（窗口里面同时“容纳”的元素个数）

窗口从**最左边**开始，每次向右滑动 1 格，滑到最右边为止。
在每一个窗口位置，你要找出：**当前窗口里的最大值**。
把所有窗口位置的最大值按顺序返回。

---

## 二、先用一个具体例子理解

我们用最常见的例子：

```text
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
```

### 1）每个窗口的内容 & 最大值（暴力理解）

窗口大小为 3，那么窗口依次为：

1. 窗口 `[1, 3, -1]`（覆盖 nums[0..2]）

   - 最大值：`max(1, 3, -1) = 3`

2. 窗口 `[3, -1, -3]`（nums[1..3]）

   - 最大值：`max(3, -1, -3) = 3`

3. 窗口 `[-1, -3, 5]`（nums[2..4]）

   - 最大值：`max(-1, -3, 5) = 5`

4. 窗口 `[-3, 5, 3]`（nums[3..5]）

   - 最大值：`max(-3, 5, 3) = 5`

5. 窗口 `[5, 3, 6]`（nums[4..6]）

   - 最大值：`max(5, 3, 6) = 6`

6. 窗口 `[3, 6, 7]`（nums[5..7]）

   - 最大值：`max(3, 6, 7) = 7`

所以返回结果是：

```text
[3, 3, 5, 5, 6, 7]
```

**暴力做法**就是：
对每一个窗口，把里面 `k` 个数都遍历一遍找最大值。

- 时间复杂度：O(n \* k)
  当 n, k 都很大时就很慢。

---

## 三、如何高效求解？——单调队列（O(n)）

我们用一个 **「双端队列」deque**，但**存的是下标 index**，并维护一个**“单调递减队列”**（队首最大）。

### 核心思想

队列里存的是「当前窗口可能成为最大值的元素的下标」，而且这些下标在队列中对应的值是**从大到小递减**的。

操作规则：

1. **向右移动窗口时，处理新元素 `nums[i]`：**

   - 把队尾中**比 `nums[i]` 小或等于的元素全都弹掉**（因为它们永远不可能成为之后窗口的最大值了——右边来了一个更大的，并且更靠右，窗口又向右移动）
   - 然后把当前下标 `i` 加到队尾

2. **保证队首在当前窗口范围内：**

   - 如果队首下标 `deque[0] < i - k + 1`，说明它已经滑出窗口左边了，就从队首弹出。

3. **从第一个完整窗口开始（i >= k - 1），每一步的最大值就是：**

   - `nums[deque[0]]`

---

## 四、结合例子一步一步走（超详细）

再看这组数据：

```text
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
```

我们用一个 `deque` 存下标，下标 → 值如下：
0→1, 1→3, 2→-1, 3→-3, 4→5, 5→3, 6→6, 7→7

> 记号说明：
>
> - `Q` 表示当前队列中存的下标
> - `Q-val` 表示这些下标对应的值
> - 窗口范围是 `[i-k+1 .. i]`

---

### i = 0，元素 = 1

当前元素：`nums[0] = 1`

- 队列为空，直接把下标 0 放进队列

```text
Q = [0]
Q-val = [1]
窗口：[0..0] 还没满 k=3，不记录最大值
```

---

### i = 1，元素 = 3

当前元素：`nums[1] = 3`

1. 看队尾：

   - `nums[Q[-1]] = nums[0] = 1`，比 3 小
     → 从队尾弹出 0

2. 队列空了，把 1 放进去

```text
Q = [1]
Q-val = [3]
窗口：[0..1] 还没满 k=3，不记录最大值
```

---

### i = 2，元素 = -1

当前元素：`nums[2] = -1`

1. 看队尾：

   - `nums[1] = 3`，比 -1 大，不弹

2. 直接把 2 放到队尾

```text
Q = [1, 2]
Q-val = [3, -1]
窗口：[0..2] 恰好长度 = 3，开始有结果

当前窗口最大值 = nums[Q[0]] = nums[1] = 3
结果数组： [3]
```

---

### i = 3，元素 = -3

当前元素：`nums[3] = -3`

1. 看队尾：

   - `nums[2] = -1` > -3，不弹
   - 所以直接把 3 放入队尾

```text
Q = [1, 2, 3]
Q-val = [3, -1, -3]
当前窗口：[1..3]  （i - k + 1 = 3 - 3 + 1 = 1）

2. 检查队首是否过期：
   - Q[0] = 1，仍在窗口[1..3]内，不弹

当前窗口最大值 = nums[1] = 3
结果数组： [3, 3]
```

---

### i = 4，元素 = 5

当前元素：`nums[4] = 5`

1. 处理队尾，比 5 小的全部弹掉：

   - `nums[3] = -3` < 5 → 弹出 3
   - `nums[2] = -1` < 5 → 弹出 2
   - `nums[1] = 3` < 5 → 弹出 1
     现在队列空了。

2. 把 4 放入队尾：

```text
Q = [4]
Q-val = [5]
当前窗口：[2..4]

3. 检查队首是否过期：
   - Q[0] = 4，在窗口[2..4]内，不弹

当前窗口最大值 = nums[4] = 5
结果数组： [3, 3, 5]
```

---

### i = 5，元素 = 3

当前元素：`nums[5] = 3`

1. 处理队尾：

   - `nums[4] = 5` > 3，不弹

2. 把 5 放入队尾：

```text
Q = [4, 5]
Q-val = [5, 3]
当前窗口：[3..5]

3. 检查队首是否过期：
   - Q[0] = 4，在[3..5]内，不弹

当前窗口最大值 = nums[4] = 5
结果数组： [3, 3, 5, 5]
```

---

### i = 6，元素 = 6

当前元素：`nums[6] = 6`

1. 处理队尾：

   - `nums[5] = 3` < 6 → 弹出 5
   - `nums[4] = 5` < 6 → 弹出 4
     队列空了。

2. 把 6 放入队尾：

```text
Q = [6]
Q-val = [6]
当前窗口：[4..6]

3. 检查队首是否过期：
   - Q[0] = 6，在窗口[4..6]内，不弹

当前窗口最大值 = nums[6] = 6
结果数组： [3, 3, 5, 5, 6]
```

---

### i = 7，元素 = 7

当前元素：`nums[7] = 7`

1. 处理队尾：

   - `nums[6] = 6` < 7 → 弹出 6

2. 把 7 放入队尾：

```text
Q = [7]
Q-val = [7]
当前窗口：[5..7]

3. 检查队首是否过期：
   - Q[0] = 7，在窗口[5..7]内，不弹

当前窗口最大值 = nums[7] = 7
结果数组： [3, 3, 5, 5, 6, 7]
```

到这里遍历结束，结果就是：

```text
[3, 3, 5, 5, 6, 7]
```

---

## 五、为什么是 O(n)？

对于每个元素 `nums[i]`：

- 它 **最多入队一次**
- 被比它更大的值「踢出」时，**最多出队一次**

也就是说，每个下标最多被操作 2 次，所以总操作次数是 `O(2n)`，忽略常数就是 `O(n)`。