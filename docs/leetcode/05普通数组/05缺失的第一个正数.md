# 缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

## 示例 1：

输入：`nums = [1,2,0]`

输出：`3`

解释：范围 `[1,2]` 中的数字都在数组中。

## 示例 2：

输入：`nums = [3,4,-1,1]`

输出：`2`

解释：`1` 在数组中，但 `2` 没有。

## 示例 3：

输入：`nums = [7,8,9,11,12]`

输出：`1`

解释：最小的正数 `1` 没有出现。

# 🌏Problem 🌏Solving🌏

## ideas

第一步：数据清洗

- 把 **无用数据**（≤0 或 >n）全部变成 `n+1`
- 保证后续只处理合法范围内的数

第二步：原地哈希标记

- 用 **数组下标** 代替哈希表
- 数字 `x` 出现 → 把 `nums[x-1]` 变成负数
- 取绝对值，防止重复标记

第三步：扫描结果

- 第一个 **仍为正数** 的位置 `i`
- 说明 `i+1` 没出现过 → 直接返回

## code

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
```

```js
var firstMissingPositive = function (nums) {
  const n = nums.length; // 数组长度 n

  /**
   * ⭐ 第一步：数据清洗
   * 目标：只关心 [1, n] 这个范围内的数
   * 因为最小缺失正整数一定出现在 [1, n+1]
   *
   * 将所有 <=0 或 >n 的数，统一替换为 n+1
   * n+1 是一个“安全值”，后续不会被用于标记
   */
  for (let i = 0; i < n; i++) {
    if (nums[i] <= 0 || nums[i] > n) {
      nums[i] = n + 1;
    }
  }

  /**
   * ⭐ 第二步：原地标记出现过的数字
   * 核心思想：
   * - 数字 x 出现过 → 把索引 x-1 位置的数变成负数
   * - 使用数组本身作为哈希表
   */
  for (let i = 0; i < n; i++) {
    const num = Math.abs(nums[i]); // 取绝对值，防止重复标记影响判断

    if (num >= 1 && num <= n) {
      // 对应的索引是 num - 1
      // 取负号表示 num 出现过
      nums[num - 1] = -Math.abs(nums[num - 1]);
    }
  }

  /**
   * ⭐ 第三步：寻找第一个没有被标记的位置
   * - 正数：说明索引 + 1 没出现过
   * - 负数：说明出现过
   */
  for (let i = 0; i < n; i++) {
    if (nums[i] > 0) {
      return i + 1; // 第一个缺失的正整数
    }
  }

  /**
   * 如果 1 ~ n 都出现过
   * 那么答案只能是 n + 1
   */
  return n + 1;
};
```

### 代码解释：firstMissingPositive 函数

这个 JavaScript 函数实现了 LeetCode 问题“缺失的第一个正数”（First Missing Positive），要求在时间复杂度 O(n) 内，且只使用常数额外空间，找出未排序数组 `nums` 中缺失的最小正整数（从 1 开始）。

#### 整体思路

- **问题约束**：数组可能包含负数、零、重复或大于数组长度的数。我们只关心 1 到 n（n 为数组长度）的正整数是否出现。不能用哈希表（额外空间 O(n)）或排序（O(n log n)）。
- **核心方法：数组原地标记**
  - 第一步：将所有 ≤0 的数替换为 n+1（一个超出范围的值），因为它们不影响正整数缺失。
  - 第二步：遍历数组，对于每个出现的正数 num（1 ≤ num ≤ n），将 nums[num-1] 标记为负数，表示 num 已存在。使用 Math.abs 处理可能已被标记的负值。
  - 第三步：遍历数组，找到第一个 >0 的位置 i，返回 i+1（表示缺失 i+1）。如果所有位置 ≤0，返回 n+1（表示 1 到 n 都存在）。
- **为什么 O(1) 空间？** 我们修改原数组作为“哈希标记”，无需额外数组。
- **时间复杂度**：三次 O(n) 遍历，总 O(n)。
- **注意事项**：处理重复数（多次标记无影响）、负数/零（忽略）、大于 n 的数（忽略）。空数组返回 1（但题目假设 n ≥ 1）。

#### 代码逐行分析

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function (nums) {
  const n = nums.length; // 获取数组长度

  // 第一步：将所有非正数替换为 n+1
  for (let i = 0; i < n; i++) {
    if (nums[i] <= 0) {
      nums[i] = n + 1; // 替换为一个“无关”大值，避免干扰标记
    }
  }

  // 第二步：标记出现的正数（1 到 n）
  for (let i = 0; i < n; i++) {
    const num = Math.abs(nums[i]); // 取绝对值（因为后续可能被标记负）
    if (num <= n) {
      // 只标记 1 到 n 的数
      nums[num - 1] = -Math.abs(nums[num - 1]); // 标记对应索引为负，确保不翻转已负
    }
  }

  // 第三步：找到第一个非负位置，返回索引+1
  for (let i = 0; i < n; i++) {
    if (nums[i] > 0) {
      // 找到未标记的位置
      return i + 1;
    }
  }

  // 如果都标记了，返回 n+1
  return n + 1;
};
```

#### 结合案例学习

我们用几个典型案例逐步模拟代码执行过程，帮助理解逻辑。每个步骤都显示数组变化。

**案例 1: nums = [3, 4, -1, 1]**（预期输出：2，缺失 2）

1. **初始化**：n = 4
2. **第一步：替换非正数**：
   - nums[2] = -1 → 5 (n+1=5)
   - nums = [3, 4, 5, 1]
3. **第二步：标记出现**：
   - i=0, num=|3|=3 ≤4，nums[2] = -|5| = -5（标记 3 出现）
   - i=1, num=|4|=4 ≤4，nums[3] = -|1| = -1（标记 4 出现）
   - i=2, num=|-5|=5 >4，跳过
   - i=3, num=|-1|=1 ≤4，nums[0] = -|3| = -3（标记 1 出现）
   - nums = [-3, 4, -5, -1]
4. **第三步：查找缺失**：
   - i=0: -3 ≤0，跳过
   - i=1: 4 >0，返回 1+1=2（缺失 2）
   - 解释：1、3、4 出现，2 缺失；-1 被忽略。

**案例 2: nums = [1, 2, 0]**（预期输出：3，缺失 3）

1. **初始化**：n = 3
2. **第一步：替换非正数**：
   - nums[2] = 0 → 4 (n+1=4)
   - nums = [1, 2, 4]
3. **第二步：标记出现**：
   - i=0, num=|1|=1 ≤3，nums[0] = -|1| = -1（标记 1）
   - i=1, num=|2|=2 ≤3，nums[1] = -|2| = -2（标记 2）
   - i=2, num=|4|=4 >3，跳过
   - nums = [-1, -2, 4]
4. **第三步：查找缺失**：
   - i=0: -1 ≤0，跳过
   - i=1: -2 ≤0，跳过
   - i=2: 4 >0，返回 2+1=3（缺失 3）
   - 解释：1、2 出现，3 缺失；0 被忽略；4 无关。

**案例 3: nums = [7, 8, 9, 11, 12]**（预期输出：1，缺失 1）

1. **初始化**：n = 5
2. **第一步：替换非正数**：无变化（全正），nums = [7, 8, 9, 11, 12]
3. **第二步：标记出现**：
   - i=0, num=7 >5，跳过
   - i=1, num=8 >5，跳过
   - i=2, num=9 >5，跳过
   - i=3, num=11 >5，跳过
   - i=4, num=12 >5，跳过
   - nums = [7, 8, 9, 11, 12]（无标记，因为所有 >n）
4. **第三步：查找缺失**：
   - i=0: 7 >0，返回 0+1=1（缺失 1）
   - 解释：所有数 >5，无 1-5 的正数，缺失最小是 1。

**案例 4: nums = [1, 1]**（预期输出：2，包含重复）

1. **初始化**：n = 2
2. **第一步：替换非正数**：无变化，nums = [1, 1]
3. **第二步：标记出现**：
   - i=0, num=1 ≤2，nums[0] = -|1| = -1（标记 1）
   - i=1, num=1 ≤2，nums[0] = -|-1| = -1（重复标记，无变化）
   - nums = [-1, 1]
4. **第三步：查找缺失**：
   - i=0: -1 ≤0，跳过
   - i=1: 1 >0，返回 1+1=2（缺失 2）
   - 解释：重复 1 不影响，缺失 2。

**案例 5: nums = [-1, -2, 0]**（预期输出：1，全非正）

1. **初始化**：n = 3
2. **第一步：替换非正数**：全替换为 4，nums = [4, 4, 4]
3. **第二步：标记出现**：
   - i=0, num=4 >3，跳过（类似其他）
   - nums = [4, 4, 4]（无标记）
4. **第三步：查找缺失**：
   - i=0: 4 >0，返回 1（缺失 1）
   - 解释：无正数，缺失 1。

通过这些案例，可以看到算法如何巧妙利用数组索引作为“存在标记”，高效处理各种情况。如果有更多边缘案例（如空数组，返回 1，但代码需调整），可以进一步测试。这个方法在实际编码面试中很实用，因为它优化了空间。
