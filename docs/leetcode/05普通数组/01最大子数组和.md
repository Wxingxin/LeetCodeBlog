# 题目

- 给你一个**整数数组** nums ，请你找出一个具有**最大和**的**连续**子数组（子数组最少包含一个元素），返回其最大和。

- 子数组是数组中的一个**连续部分**。

## 示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

## 示例 2：

输入：nums = [1]
输出：1

## 示例 3：

输入：nums = [5,4,-1,7,8]
输出：23

# 解

下面我来 **结合案例 + 带着代码逐行解释**，让你一眼就能看懂这个最大子数组和的解法（Kadane 算法）。
解释会像把一只小小的灯放在代码上，一步步照亮它的意图。🌙✨

---

# 🔥 要解释的代码

```js
/**
 * 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），
 * 返回其最大和。
 *
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  // 当前子数组的最大和（以当前元素结尾）
  let currentMax = nums[0];

  // 全局最大和（整个过程中遇到的最大值）
  let globalMax = nums[0];

  // 从第二个元素开始遍历数组
  for (let i = 1; i < nums.length; i++) {
    // 关键决策：以 nums[i] 结尾的最大子数组和有两种选择：
    // 1. 只包含 nums[i] 自己（抛弃之前的所有元素）
    // 2. 在之前的 currentMax 基础上加上 nums[i]
    // 我们取两者中较大的那个
    currentMax = Math.max(nums[i], currentMax + nums[i]);

    // 如果当前以 nums[i] 结尾的子数组和比历史全局最大还大，就更新全局最大值
    if (currentMax > globalMax) {
      globalMax = currentMax;
    }
  }

  return globalMax;
};
```

我们用经典测试用例：

```js
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
```

最终答案是 **6**（来自子数组 `[4, -1, 2, 1]`）。

---

# 🧠 整体思路一句话

`currentMax` = **以当前元素结尾的最大子数组和**
`globalMax` = **全局历史最大子数组和**

每一步：

- 要么 **从头开始**（只取 nums[i]）
- 要么 **把当前值并入之前的和**（currentMax + nums[i]）

两者取最大。

---

# 🧩 逐行拆解代码 & 结合案例

---

## 🟦 第 1 步：初始化

```js
let currentMax = nums[0];
let globalMax = nums[0];
```

对于数组 `[-2,1,-3,4,-1,2,1,-5,4]`：

```
currentMax = -2
globalMax  = -2
```

含义：

- 当前最大和，从第一个元素开始。
- 全局最大和，也先认为就是第一个元素。

---

## 🟦 第 2 步：进入循环，从 i = 1 开始

```js
for(let i = 1; i < nums.length; i++) {
```

从第二个数 `nums[1] = 1` 开始，看每个位置的情况。

---

# 🔍 循环内部是整个算法的灵魂！

---

## 🚀 第 3 步：更新 currentMax（以 nums[i] 作为结尾的最大子数组和）

```js
currentMax = Math.max(nums[i], currentMax + nums[i]);
```

这是本题的关键：
对于当前位置 `i`，以它结尾的最大子数组有两种可能：

1. **从它自己重新开始子数组** → `nums[i]`
2. **把它加到前面的 currentMax 里面去** → `currentMax + nums[i]`

取较大的那个就是 "以它结尾的最强子数组"。

---

## 🚀 第 4 步：更新 globalMax（历史最强）

```js
if (currentMax > globalMax) {
  globalMax = currentMax;
}
```

如果当前获得的最大子数组和已经超过历史纪录，就更新。

---

# 🔥 接下来真正亮点：结合每个 i 的具体数值计算！

下表是算法真正的运行过程：

| i    | nums[i] | currentMax 计算过程 | currentMax | globalMax |
| ---- | ------- | ------------------- | ---------- | --------- |
| 初始 | -2      | —                   | -2         | -2        |
| 1    | 1       | max(1, -2+1=-1)     | **1**      | 1         |
| 2    | -3      | max(-3, 1-3=-2)     | **-2**     | 1         |
| 3    | 4       | max(4, -2+4=2)      | **4**      | 4         |
| 4    | -1      | max(-1, 4-1=3)      | **3**      | 4         |
| 5    | 2       | max(2, 3+2=5)       | **5**      | 5         |
| 6    | 1       | max(1, 5+1=6)       | **6**      | 6         |
| 7    | -5      | max(-5, 6-5=1)      | **1**      | 6         |
| 8    | 4       | max(4, 1+4=5)       | **5**      | 6         |

最终：

```
globalMax = 6
```

---

# 🎯 最终结果

```js
return globalMax;
```

返回 **6**。

---

# 🌟 这里用一句更“形象”的比喻总结：

算法一路走过去，像是给每个位置发问：

> “我把你加入之前的队伍，整体变强了吗？
> 还是你自己单飞更厉害？”

`currentMax` 就是“以你为结束点的最强战斗值”；
而 `globalMax` 是“这一路上遇到的王者分数”。
