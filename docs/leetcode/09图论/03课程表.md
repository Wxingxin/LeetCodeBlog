# 题

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 必须 先学习课程 `bi` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

:::info

例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

:::

## 示例 1：

输入：`numCourses = 2, prerequisites = [[1,0]]`

输出：`true`

解释：总共有 `2` 门课程。学习课程 `1` 之前，你需要完成课程 `0` 。这是可能的。

## 示例 2：

输入：`numCourses = 2, prerequisites = [[1,0],[0,1]]`

输出：`false`

解释：总共有 `2` 门课程。学习课程 `1` 之前，你需要先完成 ​ 课程 `0` ；并且学习课程 `0 `之前，你还应先完成课程
`1`。这是不可能的。

# 解

## 思路

### 1️⃣ 问题本质

这是一个**有向图是否存在环**的问题：

- 课程 = 节点
- 先修关系 = 有向边
- **如果图中有环 → 课程无法全部完成**

---

### 2️⃣ 解法：拓扑排序（Kahn 算法）

**核心思想**：

> 不断学习“当前没有前置条件的课程”，看能不能学完所有课。

---

### 3️⃣ 算法步骤

1. **建图**

   - 邻接表：记录课程解锁关系
   - 入度数组：记录每门课还缺几门前置课

2. **初始化队列**

   - 把所有入度为 0 的课程放入队列（可以直接学）

3. **BFS 拓扑排序**

   - 每次取一门可学的课
   - 学完后，降低它指向课程的入度
   - 如果某门课入度变为 0，加入队列

4. **统计学完的课程数**

   - 如果最终学完的课程数 == 总课程数 → **无环**
   - 否则 → **有环**

---

### 4️⃣ 时间 & 空间复杂度

- **时间复杂度**：`O(numCourses + prerequisites.length)`
- **空间复杂度**：`O(numCourses + prerequisites.length)`

## ✅ 代码实现（JavaScript）

```js
/**
 * @param {number} numCourses       // 课程总数，编号为 0 ~ numCourses-1
 * @param {number[][]} prerequisites // 先修关系 [a, b]：学 a 之前必须学 b
 * @return {boolean}                // 是否能修完所有课程
 */
var canFinish = function (numCourses, prerequisites) {
  // 1. 构建邻接表 graph
  // graph[i] 表示：学完课程 i 之后，可以继续学哪些课程
  const graph = new Array(numCourses).fill(0).map(() => []);

  // 2. 入度数组 indegree
  // indegree[i] 表示：课程 i 还有多少门前置课程没学
  const indegree = new Array(numCourses).fill(0);

  // 3. 读取先修条件，构建图和入度
  for (const [a, b] of prerequisites) {
    // 表示：b -> a（必须先学 b，才能学 a）
    graph[b].push(a);
    indegree[a]++; // a 的前置课程数量 +1
  }

  // 4. 初始化队列
  // 所有“入度为 0”的课程，说明可以直接学
  const queue = [];
  for (let i = 0; i < numCourses; i++) {
    if (indegree[i] === 0) {
      queue.push(i);
    }
  }

  // 5. 记录已经“学完”的课程数量
  let taken = 0;

  // 6. 拓扑排序（Kahn 算法）
  while (queue.length > 0) {
    // 取出一门当前可以学的课
    const cur = queue.shift();
    taken++;

    // 遍历 cur 学完后解锁的课程
    for (const next of graph[cur]) {
      // 对应课程的前置条件减少一个
      indegree[next]--;

      // 如果 next 的前置课都学完了
      if (indegree[next] === 0) {
        queue.push(next);
      }
    }
  }

  // 7. 判断是否所有课程都被学完
  // 如果存在环，就一定有课程入度无法降为 0
  return taken === numCourses;
};
```

---

## 🌰 小例子感受一下

假设：

```js
numCourses = 2;
prerequisites = [[1, 0]];
```

表示：想上课 1，要先上课 0

- 边：`0 -> 1`
- 入度：

  - indegree[0] = 0
  - indegree[1] = 1

流程：

- 队列初始：`[0]`
- 取出 0，taken = 1

  - 0 指向 1 → indegree[1] 从 1 变成 0 → 入队 1

- 取出 1，taken = 2
- 最终 taken = 2 = numCourses → `true`

再看有环的：

```js
numCourses = 2;
prerequisites = [
  [1, 0],
  [0, 1],
];
```

- 边：`0 -> 1` 和 `1 -> 0`
- 入度：

  - indegree[0] = 1
  - indegree[1] = 1

- 没有入度为 0 的课程，队列一开始就是空
- BFS 完全不执行，taken = 0 ≠ 2 → `false`

说明这俩课互相依赖，真的学不了。

---

如果你想，我也可以给一个 **DFS 检测有向图是否有环** 的写法（用状态 0/1/2 标记：未访问、访问中、访问完），你可以对比两种实现。
