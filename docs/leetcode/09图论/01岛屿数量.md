# 岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

## 示例 1：

输入：

`grid = [`

`['1','1','1','1','0'],`

`['1','1','0','1','0'],`

`['1','1','0','0','0'],`

`['0','0','0','0','0']`

`]`

输出：`1`

## 示例 2：

输入：

`grid = [`

`['1','1','0','0','0'],`

`['1','1','0','0','0'],`

`['0','0','1','0','0'],`

`['0','0','0','1','1']`

`]`

输出：3

---

# 解题

## 思路

### 1. **遍历每一个格子，寻找新岛屿的起点**

- 用双重循环遍历网格的所有位置 (i, j)。
- 每当发现一个尚未被访问的陆地（grid[i][j] === "1"），就说明发现了一个**新的岛屿**，岛屿计数 `count++`。

### 2. **从这个起点开始“沉没”整个岛屿**

- 立即调用 DFS，从当前格子开始，把这个格子以及所有与之**上下左右连通**的陆地全部标记为已访问。
- 这里巧妙地直接把陆地改为 `"0"`（相当于把岛屿“沉没”入水），这样不需要额外空间来记录访问状态。

### 3. **DFS 的作用：淹没一个完整的连通区域**

- DFS 递归地访问当前格子的四个方向（上、下、左、右）。
- 在访问前先检查：
  - 是否越界
  - 是否已经是水（"0"，即已访问或本来就是水）
- 如果都不满足，则说明是未访问的陆地 → 沉没它 → 继续向四个方向递归。

### 4. **避免重复计数**

- 因为整个岛屿在一次 DFS 中会被全部沉没，后续遍历到同一个岛屿的其他格子时，它们已经变成 "0"，不会再次触发计数。

### 5. **最终返回岛屿总数**

- 遍历结束后，`count` 就是独立的岛屿数量。

## code

```js
var numIslands = function (grid) {
  if (!grid || grid.length === 0) return 0; // 边界情况：网格为空或没有行，返回 0
  const rows = grid.length; // 行数
  const cols = grid[0].length; // 列数
  let count = 0; // 岛屿数量计数器

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      // 如果发现一个陆地（"1"）
      if (grid[i][j] === "1") {
        count++; // 岛屿数量 +1
        dfs(i, j); // 从这个点开始 DFS，把整个连通的岛屿全部沉没（标记为 "0"）
      }
    }
  }

  // 定义深度优先搜索函数，用于“沉没”一个完整的岛屿
  const dfs = (r, c) => {
    // 1. 坐标越界：超出网格范围，直接返回
    if (r < 0 || r >= rows || c < 0 || c >= cols) {
      return;
    }

    // 2. 当前位置是水 或 已经被访问过（已沉没为 "0"）
    if (grid[r][c] === "0") {
      return;
    }

    // 把当前陆地标记为已访问（改为 "0"，相当于“沉没”这个岛屿）
    grid[r][c] = "0";
    // 递归访问上下左右四个方向的相邻格子
    dfs(r - 1, c); // 上
    dfs(r + 1, c); // 下
    dfs(r, c - 1); // 左
    dfs(r, c + 1); // 右
  };

  return count;
};
```

## code 讲解

下面给你一个**真正图形化、像流程图一样的递归调用过程**，
并且完全基于这个示例 grid：

```
[
  ['1','1','1','1','0'],
  ['1','1','0','1','0'],
  ['1','1','0','0','0'],
  ['0','0','0','0','0']
]
```

我们重点展示：**从 (0,0) 开始 DFS 如何淹掉整个岛屿**。
你会看到一个“递归树 + 方向扩展”的可视化流程。

---

# 🌊 全图示意（上帝视角）

先标出每个位置坐标（方便你理解 DFS 跳转）：

```
     c0 c1 c2 c3 c4
r0   1  1  1  1  0
r1   1  1  0  1  0
r2   1  1  0  0  0
r3   0  0  0  0  0
```

DFS 从 (0,0) 开始往上下左右扩散。

---

# 🌀 树形 + 流程图化递归展开（核心）

DFS(0,0) 流程如下：

```
DFS(0,0)
│
├── 淹掉 (0,0)
│
├── DFS(-1,0)   ← 越界返回
│
├── DFS(1,0)
│   │
│   ├── 淹掉 (1,0)
│   │
│   ├── DFS(0,0) ← 已经变成'0'，返回
│   │
│   ├── DFS(2,0)
│   │   │
│   │   ├── 淹掉 (2,0)
│   │   │
│   │   ├── DFS(1,0) ← 已淹，返回
│   │   │
│   │   ├── DFS(3,0) ← grid=0，返回
│   │   │
│   │   ├── DFS(2,-1) ← 越界返回
│   │   │
│   │   └── DFS(2,1)
│   │       │
│   │       ├── 淹掉 (2,1)
│   │       │
│   │       ├── DFS(1,1)
│   │       │   │
│   │       │   ├── 淹掉 (1,1)
│   │       │   │
│   │       │   ├── DFS(0,1)
│   │       │   │   │
│   │       │   │   ├── 淹掉 (0,1)
│   │       │   │   │
│   │       │   │   ├── DFS(-1,1) ← 越界
│   │       │   │   ├── DFS(1,1)  ← 已淹
│   │       │   │   ├── DFS(0,0)  ← 已淹
│   │       │   │   └── DFS(0,2)
│   │       │   │       │
│   │       │   │       ├── 淹掉 (0,2)
│   │       │   │       │
│   │       │   │       ├── DFS(-1,2)
│   │       │   │       ├── DFS(1,2) ← grid=0
│   │       │   │       ├── DFS(0,1) ← 已淹
│   │       │   │       └── DFS(0,3)
│   │       │   │           │
│   │       │   │           ├── 淹掉 (0,3)
│   │       │   │           │
│   │       │   │           ├── DFS(-1,3)
│   │       │   │           ├── DFS(1,3)
│   │       │   │           │   │
│   │       │   │           │   ├── 淹掉 (1,3)
│   │       │   │           │   │
│   │       │   │           │   ├── DFS(0,3)
│   │       │   │           │   ├── DFS(2,3) ← grid=0
│   │       │   │           │   ├── DFS(1,2) ← 0
│   │       │   │           │   └── DFS(1,4) ← 0
│   │       │   │           │
│   │       │   │           ├── DFS(0,2)
│   │       │   │           └── DFS(0,4) ← grid=0
│   │       │   │
│   │       │   ├── DFS(2,1) ← 已淹
│   │       │   ├── DFS(1,0) ← 已淹
│   │       │   └── DFS(1,2) ← 0
│   │       │
│   │       ├── DFS(3,1) ← 0
│   │       ├── DFS(2,0) ← 已淹
│   │       └── DFS(2,2) ← 0
│   │
│   ├── DFS(1,-1) ← 越界
│   └── DFS(1,1)  ← 已淹
│
├── DFS(0,-1) ← 越界
└── DFS(0,1) ← 已淹
```

---

# 🔍 更直观的图（按扩散顺序“涂色”）

假设 DFS 每次淹掉的位置标记为 `X`
淹岛顺序如下（按编号标出 DFS 执行顺序）：

```
步骤序号 即 DFS 淹掉该点的顺序
--------------------------------
 1  2  6 10  .
 3  4  . 11  .
 5  7  .  .  .
 .  .  .  .  .
```

图示：

```
r0: 1  8  9  10  .
r1: 2  7  .  11  .
r2: 3  6  .   .  .
r3: .  .  .   .  .
```

说明：

- 从 (0,0) → (1,0) → (2,0) 向“下”扩散
- 再转向“右”扩散： (2,1) → (1,1) → (0,1)
- 再向右： (0,2) → (0,3)
- 再往下： (1,3)

最后整个岛淹掉， DFS 完成。

---

# 🎉 总结（你看到的是什么）

上面图形化展示清楚说明了：

1. DFS 是一个“树形展开”的过程
2. 每个位置会往 **上、下、左、右** 扩散
3. 所有能连到的 `'1'` 都会被递归访问并淹掉
4. 岛屿只会被计数一次（因为第一次遇到它时会被整片吞掉）

---

如果你想，我还可以制作一个 **ASCII 动态过程**（一帧一帧显示 DFS 如何扩散），或者做一个 **颜色图标标记图（彩色岛屿连通演示）**。

告诉我即可！

#

我们可以把这个题理解成：
在一个由 `'1'`（陆地）和 `'0'`（水）组成的地图里，**数有多少块互相连通的陆地块**（上下左右连成一片算一座岛）。

下面给你经典的 DFS 解法（也顺便说下 BFS 思路），最后是完整 JS 代码。

---

## 🧠 思路

核心想法：

1. 遍历整个二维网格 `grid`。
2. 每当遇到一个还没访问过的 `'1'`：

   - 说明发现了一座**新岛屿** → 岛屿数量 `count++`
   - 然后从这个格子出发，使用 **DFS 或 BFS** 把与它相连的所有 `'1'` 都“淹掉”或标记为已访问，避免重复计数。

3. 遍历完所有格子之后，`count` 就是岛屿数量。

“淹掉”的具体操作可以是：

- 把 `'1'` 改成 `'0'`（原地修改，不需要额外 visited 数组）
- 或者用一个 `visited` 数组记录访问过的节点

我们用原地改成 `'0'` 的方式，代码更简洁。

---

## 🔁 DFS 具体做法

定义一个 `dfs(r, c)` 函数，作用是：

> 从位置 `(r, c)` 这个 `'1'` 出发，把与它连接的整块陆地都递归标记为 `'0'`。

步骤：

1. 如果 `(r, c)` 越界，直接返回。
2. 如果 `grid[r][c] === '0'`，说明不是陆地，返回。
3. 否则：

   - 把 `grid[r][c]` 改为 `'0'`，表示已经访问过。
   - 递归访问它的 **上、下、左、右** 四个方向：

     ```js
     dfs(r - 1, c);
     dfs(r + 1, c);
     dfs(r, c - 1);
     dfs(r, c + 1);
     ```

主循环：

- 两层 for 循环遍历每个格子 `(i, j)`：

  - 如果 `grid[i][j] === '1'`：

    - `count++`
    - 调用 `dfs(i, j)` 把整块岛淹掉

---

## ✅ 完整 JavaScript 代码

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {
  if (!grid || grid.length === 0) return 0;

  const rows = grid.length;
  const cols = grid[0].length;
  let count = 0;

  // 深度优先搜索，把连接的陆地全部“淹掉”
  const dfs = (r, c) => {
    // 越界直接返回
    if (r < 0 || r >= rows || c < 0 || c >= cols) return;
    // 遇到水或者已访问过的陆地（已被置为 '0'）也返回
    if (grid[r][c] === "0") return;

    // 标记当前格子为水，表示已访问
    grid[r][c] = "0";

    // 继续向上下左右扩展
    dfs(r - 1, c); // 上
    dfs(r + 1, c); // 下
    dfs(r, c - 1); // 左
    dfs(r, c + 1); // 右
  };

  // 遍历网格
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (grid[i][j] === "1") {
        // 发现一座新的岛
        count++;
        // 把整座岛都淹掉
        dfs(i, j);
      }
    }
  }

  return count;
};
```

---

## 🧪 用你的示例跑一遍

```js
grid = [
  ["1", "1", "1", "1", "0"],
  ["1", "1", "0", "1", "0"],
  ["1", "1", "0", "0", "0"],
  ["0", "0", "0", "0", "0"],
];
```

- 从 (0,0) 第一次遇到 `'1'` → `count = 1`，然后 DFS 把所有连通的 `'1'` 都改成 `'0'`
- 之后再遍历整个网格时，再也不会出现新的 `'1'`
- 最终结果：`1`

---

如果你想我也可以再给你：

- BFS 队列版本写法
- 加打印日志版，逐步展示 DFS 如何“淹岛”
  你说一声就行。

#

太棒了！这是 LeetCode 第 200 题「岛屿数量」（Number of Islands），经典的 **DFS + 原地修改** 题目。

你给的代码已经是 **最优解**，现在我结合你提供的案例，用 **图形化递归调用栈流程图**（像画树一样）来完整演示整个执行过程！

---

### 输入网格（4×5）

```text
grid = [
  ['1','1','0','0','0'],    → 第0行
  ['1','1','0','0','0'],    → 第1行
  ['0','0','1','0','0'],    → 第2行
  ['0','0','0','1','1']     → 第3行
]
```

可视化如下：

```
    0   1   2   3   4      ← 列号
  +---+---+---+---+---+
0 | 1 | 1 | 0 | 0 | 0 |
  +---+---+---+---+---+
1 | 1 | 1 | 0 | 0 | 0 |
  +---+---+---+---+---+
2 | 0 | 0 | 1 | 0 | 0 |
  +---+---+---+---+---+
3 | 0 | 0 | 0 | 1 | 1 |
  +---+---+---+---+---+
  ↑       ↑       ↑ ↑
 行号      岛1     岛2  岛3
```

一共有 **3 座岛**

---

### 完整递归调用过程（像流程图一样展开）

我们从左上角开始遍历，第一次遇到 `'1'` 是在 `(0,0)`

#### 第 1 座岛：左上角大岛（坐标集合：(0,0),(0,0),(1,0),(1,1)）

```
主程序调用：dfs(0,0)  → 发现新岛！count = 1
└── dfs(0,0) 开始
    ├── grid[0][0] = '1' → 标记为 '0'（沉没）
    ├── 调用 dfs(-1,0) → 越界 → 返回
    ├── 调用 dfs(1,0)  → 进入！
    │   └── dfs(1,0)
    │       ├── grid[1][0]='1' → 沉没
    │       ├── dfs(0,0) → 已是'0' → 返回
    │       ├── dfs(2,0) → 是'0' → 返回
    │       ├── dfs(1,-1)→ 越界
    │       └── 调用 dfs(1,1) → 进入！
    │           └── dfs(1,1)
    │               ├── grid[1][1]='1' → 沉没
    │               ├── dfs(0,1) → 进入！
    │               │   └── dfs(0,1)
    │               │       ├── grid[0][1]='1' → 沉没
    │               │       ├── dfs(-1,1) 越界
    │               │       ├── dfs(1,1) 已沉
    │               │       ├── dfs(0,0) 已沉
    │               │       └── dfs(0,1+1)=(0,2) → 是'0' → 返回
    │               ├── dfs(2,1) → 是'0'
    │               ├── dfs(1,0) 已沉
    │               └── dfs(1,2) → 是'0'
    └── 调用 dfs(0,1) → 已被上面 dfs(1,1) 沉没 → 返回
```

**第一座岛全部沉没！** 左上角 4 个 `'1'` 全变成 `'0'`

此时网格变成：

```
  0 1 0 0 0
  0 0 0 0 0
  0 0 1 0 0
  0 0 0 1 1
```

继续遍历，跳过一堆 `'0'`，直到发现 `(2,2)`

#### 第 2 座岛：中间的孤岛 `(2,2)`

```
主程序调用：dfs(2,2) → 发现新岛！count = 2
└── dfs(2,2)
    ├── grid[2][2]='1' → 沉没
    ├── dfs(1,2) → 是'0'
    ├── dfs(3,2) → 是'0'
    ├── dfs(2,1) → 是'0'
    └── dfs(2,3) → 是'0'
```

只有自己一个，孤岛沉没！

网格变成：

```
  0 1 0 0 0
  0 0 0 0 0
  0 0 0 0 0
  0 0 0 1 1
```

#### 第 3 座岛：右下角小岛 `(3,3)` 和 `(3,4)`

```
主程序调用：dfs(3,3) → 发现新岛！count = 3
└── dfs(3,3)
    ├── grid[3][3]='1' → 沉没
    ├── dfs(2,3) → 是'0'
    ├── dfs(4,3) → 越界
    ├── dfs(3,2) → 是'0'
    └── 调用 dfs(3,4) → 进入！
        └── dfs(3,4)
            ├── grid[3][4]='1' → 沉没
            ├── dfs(2,4) → 是'0'
            ├── dfs(4,4) 越界
            ├── dfs(3,3) 已沉
            └── dfs(3,5) 越界
```

整座岛沉没！

---

### 最终结果

所有 `'1'` 都被“淹没”成 `'0'`0'`，共触发了 3 次 `dfs` 入口 → **岛屿数量 = 3**

返回 `3`

---

### 递归调用栈树状图总结（超级清晰版！）

```
主遍历
├── 发现 (0,0) → dfs(0,0) → 第1座岛（左上连通块）
│   ├── dfs(1,0)
│   │   └── dfs(1,1)
│   │       └── dfs(0,1)   ← 回溯时发现并沉没
│   └── dfs(0,1)           ← 已被沉没，直接返回
│
├── 发现 (2,2) → dfs(2,2) → 第2座岛（孤岛）
│   └── 四个方向全是0，直接返回
│
└── 发现 (3,3) → dfs(3,3) → 第3座岛
    └── dfs(3,4) → 相邻陆地被沉没
```

---

### 为什么这个写法是最优的？

| 方案        | 时间复杂度 | 空间复杂度       | 是否修改原数组 | 推荐度          |
| ----------- | ---------- | ---------------- | -------------- | --------------- |
| DFS（本题） | O(m×n)     | O(m×n) 递归栈    | 是（原地标记） | 5 stars         |
| BFS         | O(m×n)     | O(min(m,n)) 队列 | 是             | 4 stars         |
| 并查集      | O(m×n)     | O(m×n)           | 否             | 3 stars（复杂） |

**本解法 = 时间最优 + 空间最优（不额外用 visited 数组）**

---

**答案：3**  
**技巧口诀**：「看到 1 就沉没整座岛，沉没用 DFS，标记用原地改 0，数岛只数入口次数」！

收藏、背会、面试直接写！
