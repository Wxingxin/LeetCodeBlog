# 颜色分类

给定一个包含红色、白色和蓝色、共`n`个元素的数组` nums` ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数`0、 1 和 2`分别表示`红色、白色和蓝色`。

必须在 **不使用** 库内置的 `sort` 函数的情况下解决这个问题。

## 示例 1：

输入：`nums = [2,0,2,1,1,0]`

输出：`[0,0,1,1,2,2]`

## 示例 2：

输入：`nums = [2,0,1]`

输出：`[0,1,2]`

# Problem Solving

## ideas


1️⃣ 题目本质

- 数组只包含 `0、1、2`
- 要求：

  - **原地排序**
  - **一次遍历**
  - **O(1) 额外空间**

👉 典型的 **三指针 / 分区问题**

---

2️⃣ 三个指针的含义（关键）

| 指针    | 含义                 |
| ------- | -------------------- |
| `left`  | 左边界，左侧全是 `0` |
| `right` | 右边界，右侧全是 `2` |
| `i`     | 当前扫描位置         |

数组在任何时刻都满足：

```
[ 0 区域 | 1 区域 | 未处理区域 | 2 区域 ]
  0~left-1   left~i-1      i~right     right+1~end
```

---

3️⃣ 扫描规则（记住这 3 条）

- `nums[i] === 0`

  - 和 `left` 交换
  - `left++，i++`

- `nums[i] === 1`

  - 什么都不做
  - `i++`

- `nums[i] === 2`

  - 和 `right` 交换
  - `right--`
  - **`i 不动`**

---

为什么处理 2 时 i 不能加？（高频考点）

```txt
nums = [2, 0, 1]
```

- i = 0，nums[i] = 2
- 与 right 交换 → `[1, 0, 2]`
- 交换后 `nums[i] = 1`（新元素）

👉 如果此时 `i++`，就会 **跳过对 1 的判断**

所以：

> **只有在确定当前位置已经处理完成时，i 才能加**

## code

```js
/**
 * @param {number[]} nums
 * @return {void} 不返回，原地修改
 */
var sortColors = function (nums) {
  // 左指针：指向下一个应该放 0 的位置
  let left = 0;

  // 右指针：指向下一个应该放 2 的位置
  let right = nums.length - 1;

  // 当前遍历指针，用来扫描数组
  let i = 0;

  // 当 i > right 时，说明 0、1、2 都已分区完成
  while (i <= right) {
    if (nums[i] === 0) {
      // 当前是 0，应放到左边区域
      // 与 left 指针位置交换
      [nums[i], nums[left]] = [nums[left], nums[i]];

      // 左边 0 区域扩大
      left++;

      // i 位置已经处理完，继续向右扫描
      i++;
    } else if (nums[i] === 1) {
      // 当前是 1，属于中间区域
      // 不用交换，直接跳过
      i++;
    } else {
      // nums[i] === 2
      // 当前是 2，应放到右边区域
      // 与 right 指针位置交换
      [nums[i], nums[right]] = [nums[right], nums[i]];

      // 右边 2 区域扩大
      right--;

      // 注意：这里不能 i++
      // 因为换过来的元素还没判断
    }
  }
};
```

这是 **颜色分类问题（LeetCode 75）**，
核心要求只有四个字：**原地 + 一趟遍历**。

下面我用**最好理解、最常考的解法：荷兰国旗算法**，
**结合案例 + 详细注释**一步一步讲清楚 👇

---

## 一、核心思想（荷兰国旗算法）

我们维护 **三个指针**，把数组分成 4 个区间：

```text
[ 0 区 | 1 区 | 未处理 | 2 区 ]
```

### 三个指针含义

| 指针    | 作用                |
| ------- | ------------------- |
| `left`  | 下一个放 `0` 的位置 |
| `right` | 下一个放 `2` 的位置 |
| `i`     | 当前正在检查的元素  |

---

## 二、规则（只需记 3 条）

当我们看 `nums[i]`：

### 1️⃣ 如果是 `0`

👉 放到左边

```js
swap(nums[i], nums[left]);
left++;
i++;
```

---

### 2️⃣ 如果是 `1`

👉 本来就在中间

```js
i++;
```

---

### 3️⃣ 如果是 `2`

👉 放到右边

```js
swap(nums[i], nums[right]);
right--;
// ⚠️ i 不能加
```

> 因为换过来的数还没检查过

---

## 三、结合示例 1 详细演示

### 输入

```js
nums = [2, 0, 2, 1, 1, 0];
```

### 初始状态

```text
left = 0, i = 0, right = 5
[2,0,2,1,1,0]
```

---

### 第一步（i = 0）

`nums[0] = 2`

👉 和 `right` 交换

```text
[0,0,2,1,1,2]
right = 4
i 不动
```

---

### 第二步（i = 0）

`nums[0] = 0`

👉 和 `left` 交换

```text
[0,0,2,1,1,2]
left = 1
i = 1
```

---

### 第三步（i = 1）

`nums[1] = 0`

```text
left = 2
i = 2
```

---

### 第四步（i = 2）

`nums[2] = 2`

```text
swap(2, nums[4])
[0,0,1,1,2,2]
right = 3
i 不动
```

---

### 剩余都是 1，结束 🎉

---

## 四、完整代码（详细注释）

```js
/**
 * @param {number[]} nums
 * @return {void} 不返回，原地修改
 */
var sortColors = function (nums) {
  // 左指针：下一个 0 应该放的位置
  let left = 0;
  // 右指针：下一个 2 应该放的位置
  let right = nums.length - 1;
  // 当前遍历指针
  let i = 0;

  // 当 i 超过 right 时，说明中间区域已处理完
  while (i <= right) {
    if (nums[i] === 0) {
      // 把 0 放到左边
      [nums[i], nums[left]] = [nums[left], nums[i]];
      left++;
      i++;
    } else if (nums[i] === 1) {
      // 1 在中间，不用动
      i++;
    } else {
      // nums[i] === 2
      // 把 2 放到右边
      [nums[i], nums[right]] = [nums[right], nums[i]];
      right--;
      // 注意：这里 i 不能加
    }
  }
};
```

---

## 五、复杂度分析

| 项目       | 复杂度                    |
| ---------- | ------------------------- |
| 时间复杂度 | **O(n)**（只遍历一遍）    |
| 空间复杂度 | **O(1)**（只用 3 个变量） |

---

## 六、口诀版（面试秒答）

> **0 往左，2 往右，1 不动
> 遇 2 不前进，换完再检查**

---

如果你愿意，我可以：

- 用 **动画步骤图**再演示一遍
- 把 **三道题（异或 / 投票 / 颜色分类）做成一张对比表**
- 或帮你整理一套 **双指针必考模板**
