# 两数之和 II - 输入有序数组
## 题目

给你一个下标从 `1 `开始的整数数组 `numbers` ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。

如果设这两个数分别是 `numbers[index1] 和 numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 `2` 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

 
### 示例 1：

输入：`numbers = [2,7,11,15], target = 9`
输出：`[1,2]`
解释：`2 `与 `7 `之和等于目标数 `9` 。因此 `index1 = 1, index2 = 2` 。返回 `[1, 2] `。
### 示例 2：

输入：`numbers = [2,3,4], target = 6`
输出：`[1,3]`
解释：`2 与 4` 之和等于目标数 `6` 。因此 `index1 = 1, index2 = 3` 。返回 `[1, 3]` 。
### 示例 3：

输入：`numbers = [-1,0], target = -1`
输出：`[1,2]`
解释：`-1` 与` 0` 之和等于目标数 `-1` 。因此 `index1 = 1, index2 = 2` 。返回 `[1, 2]` 。

## 

这题是 **有序数组版 Two Sum**，标准解法就是 **双指针**，满足

* 时间复杂度 **O(n)**
* 额外空间 **O(1)**（常量级）
* 完全符合题目要求

---

## 核心思路（双指针）

* 数组 **已按非递减排序**
* 用两个指针：

  * `left` 指向最左边
  * `right` 指向最右边
* 每次计算 `numbers[left] + numbers[right]`

判断规则：

* **等于 target** → 直接返回答案
* **小于 target** → 左指针右移（想要更大）
* **大于 target** → 右指针左移（想要更小）

---

## 代码（JS，LeetCode 可直接提交）

```js
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
  let left = 0;
  let right = numbers.length - 1;

  while (left < right) {
    const sum = numbers[left] + numbers[right];

    if (sum === target) {
      // 题目下标从 1 开始
      return [left + 1, right + 1];
    } else if (sum < target) {
      left++;   // 和太小，左指针右移
    } else {
      right--;  // 和太大，右指针左移
    }
  }

  // 题目保证一定有解，这里只是兜底
  return [];
};
```

---

## 举个例子（示例 1）

```
numbers = [2,7,11,15], target = 9

left = 0 (2), right = 3 (15) → 17 > 9 → right--
left = 0 (2), right = 2 (11) → 13 > 9 → right--
left = 0 (2), right = 1 (7)  → 9 == 9 ✅
返回 [1, 2]
```

---

## 为什么不用哈希表？

* 普通 Two Sum 可以用 `Map`
* **但本题明确要求：常量级额外空间**
* 又因为 **数组有序**，双指针是最优解

---

### 一句话总结（面试版）

> 利用有序数组特性，使用左右双指针夹逼，根据当前和与 target 的大小关系移动指针，在 O(n) 时间、O(1) 空间内找到唯一解。

如果你愿意，我也可以给你：

* ❓「为什么一定能找到解」的数学解释
* 🔁 用 `while` / `for` 写法对比
* 🚫 常见写错点（比如下标从 1 开始）
