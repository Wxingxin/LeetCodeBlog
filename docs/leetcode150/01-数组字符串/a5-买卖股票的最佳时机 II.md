# 买卖股票的最佳时机 II
## 题目

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。

然而，你可以在 同一天 多次买卖该股票，但要确保你持有的股票不超过一股。

返回 你能获得的 最大 利润 。

 

### 示例 1：

输入：`prices = [7,1,5,3,6,4]`

输出：`7`

解释：在第 `2` 天（股票价格 = `1`）的时候买入，在第 `3` 天（股票价格 = `5`）的时候卖出, 这笔交易所能获得利润 = `5 - 1 = 4`

随后，在第 `4` 天（股票价格 = `3`）的时候买入，在第 `5` 天（股票价格 = `6`）的时候卖出, 这笔交易所能获得利润 = `6 - 3 = 3`。

最大总利润为 `4 + 3 = 7` 。

### 示例 2：

输入：`prices = [1,2,3,4,5]`

输出：`4`

解释：在第 `1` 天（股票价格 =` 1`）的时候买入，在第` 5` 天 （股票价格 = `5`）的时候卖出, 这笔交易所能获得利润 = `5 - 1 = 4`。

最大总利润为 `4` 。

### 示例 3：

输入：`prices = [7,6,4,3,1]`

输出：`0`

解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 `0`。


## 

下面这题（LeetCode 122：买卖股票的最佳时机 II）核心就一句话：**把所有“上涨的差价”都赚到手**。

因为你可以无限次交易（但同一时间最多持有 1 股），所以只要今天比昨天贵，就相当于“昨天买、今天卖”能赚这段涨幅；把每一段涨幅加起来，就是最大利润。

---

## ✅ 解法一：贪心（最常用、最简单）

### 思路

* 遍历 prices
* 如果 `prices[i] > prices[i-1]`，就把差值加到利润里
* 等价于把一段连续上涨拆成每天的小交易，最终收益和“低买高卖一次”一样，但实现最简单

### 代码（JS + 注释）

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let profit = 0;

  // 从第 2 天开始看（i=1），比较今天和昨天价格
  for (let i = 1; i < prices.length; i++) {
    // 只要今天比昨天贵，就把这段上涨利润吃掉
    if (prices[i] > prices[i - 1]) {
      profit += prices[i] - prices[i - 1];
    }
  }

  return profit;
};
```

---

## 🧠 结合案例讲清楚

### 示例1：`[7,1,5,3,6,4]`

逐天看差价：

* 1 -> 5 上涨：赚 `4`
* 3 -> 6 上涨：赚 `3`
* 其他是下跌，不操作

最终：`4 + 3 = 7`

用“贪心累加”看就是：

* 7→1（跌，不加）
* 1→5（加 4）
* 5→3（跌，不加）
* 3→6（加 3）
* 6→4（跌，不加）
  = 7

---

### 示例2：`[1,2,3,4,5]`

每天都涨：

* 1→2 加1
* 2→3 加1
* 3→4 加1
* 4→5 加1
  总利润 = 4
  等价于 “第1天买，第5天卖” 赚 4

---

### 示例3：`[7,6,4,3,1]`

每天都跌，没有任何 `prices[i] > prices[i-1]`
利润一直是 0

---

## 📌 总结一句话

**最大利润 = 把所有相邻两天的“正差价”加起来。**
因为无限次交易允许你把每一段上涨都拆成“昨天买今天卖”，不会错过任何利润。

如果你还想要 DP 写法（更通用，能迁移到“最多 k 次交易”的题），我也可以给你同样带注释的版本。
