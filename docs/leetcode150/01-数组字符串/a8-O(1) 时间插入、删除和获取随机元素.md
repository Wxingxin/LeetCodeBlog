# O(1) 时间插入、删除和获取随机元素
## 题目

实现`RandomizedSet` 类：

`RandomizedSet()` 初始化 `RandomizedSet` 对象

`bool insert(int val)` 当元素 `val `不存在时，向集合中插入该项，并返回` true` ；否则，返回 `false` 。

`bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。

`int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。

你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 `O(1)` 。

 

### 示例：

输入
`["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]`

`[[], [1], [2], [2], [], [1], [2], []]`

输出

`[null, true, false, true, 2, true, false, 2]`

解释
```js
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。
randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。
randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。
randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
```

## 


 这题是 **LeetCode 380：O(1) 时间插入、删除和获取随机元素**，属于**“数据结构设计 + 组合拳”**的经典题。

核心不是某一个结构，而是：
👉 **数组 + 哈希表（Map）配合使用**

我按你熟悉的节奏来：**思路 → 代码（详细注释）→ 为什么是 O(1) → 结合示例完整跑一遍**。

---

## 一、核心思路（一定要记住这 4 点）

### 为什么不能只用 Set / Map？

* Set / Map：插入、删除是 `O(1)`
* ❌ 但 **随机取一个元素** 不是 `O(1)`（没法按下标取）

### 为什么不能只用数组？

* 数组：随机取是 `O(1)`
* ❌ 但 **删除中间元素** 是 `O(n)`

---

## ✅ 正确解法：数组 + Map

我们维护两样东西：

1. **数组 `arr`**

   * 存所有元素
   * 用来 `getRandom()`（随机下标）

2. **Map `map`**

   * `key = 值`
   * `value = 这个值在数组里的下标`
   * 用来 O(1) 定位、删除

---

## 二、关键技巧（删除的灵魂）

删除 `val` 时：

1. 找到 `val` 在数组中的下标 `idx`
2. 把 **数组最后一个元素** 挪到 `idx` 位置
3. 更新这个被挪动元素在 `map` 里的下标
4. `pop()` 删除数组最后一位
5. 从 `map` 中删掉 `val`

⚠️ 这样就避免了数组整体移动，**删除仍是 O(1)**。

---

## 三、完整代码（JS + 超详细注释）

```js
var RandomizedSet = function() {
  this.arr = [];          // 存放元素
  this.map = new Map();   // val -> index
};

/** 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.insert = function(val) {
  // 如果已经存在，不能插入
  if (this.map.has(val)) return false;

  // 插入到数组末尾
  this.arr.push(val);
  // 记录 val 在数组中的下标
  this.map.set(val, this.arr.length - 1);

  return true;
};

/** 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.remove = function(val) {
  // 不存在，直接返回 false
  if (!this.map.has(val)) return false;

  // 1. 找到 val 的下标
  const idx = this.map.get(val);

  // 2. 拿到数组最后一个元素
  const lastVal = this.arr[this.arr.length - 1];

  // 3. 把最后一个元素放到 idx 位置
  this.arr[idx] = lastVal;

  // 4. 更新 lastVal 在 map 中的下标
  this.map.set(lastVal, idx);

  // 5. 删除数组最后一个元素
  this.arr.pop();

  // 6. 从 map 中删除 val
  this.map.delete(val);

  return true;
};

/**
 * @return {number}
 */
RandomizedSet.prototype.getRandom = function() {
  // 在 [0, arr.length) 中随机一个下标
  const randIndex = Math.floor(Math.random() * this.arr.length);
  return this.arr[randIndex];
};
```

---

## 四、时间复杂度为什么都是 O(1)？

| 操作        | 原因                              |
| --------- | ------------------------------- |
| insert    | `push` + `map.set`              |
| remove    | 常数次 swap + `pop` + `map.delete` |
| getRandom | 随机下标访问数组                        |

➡ **全部平均 O(1)**，完全符合题目要求。

---

## 五、结合示例完整跑一遍（非常重要）

### 操作序列

```txt
["insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[   1   ,   2   ,   2   ,    -     ,   1   ,   2   ,    -     ]
```

---

### 1️⃣ insert(1)

```js
arr = [1]
map = { 1 -> 0 }
返回 true
```

---

### 2️⃣ remove(2)

```js
map 中没有 2
返回 false
```

---

### 3️⃣ insert(2)

```js
arr = [1, 2]
map = { 1 -> 0, 2 -> 1 }
返回 true
```

---

### 4️⃣ getRandom()

```js
随机下标 0 或 1
返回 1 或 2（概率相同）
```

---

### 5️⃣ remove(1)

* idx = 0
* lastVal = 2
* 用 2 覆盖 arr[0]

```js
arr = [2]
map = { 2 -> 0 }
返回 true
```

---

### 6️⃣ insert(2)

```js
2 已存在
返回 false
```

---

### 7️⃣ getRandom()

```js
arr = [2]
只能返回 2
```

---

## 六、面试一句话总结（🔥 很加分）

> **用数组保证 O(1) 随机访问，用哈希表保证 O(1) 定位元素，删除时通过“末尾元素交换”避免数组移动。**

---

如果你愿意，我还能继续帮你：

* 🔹 手写一版 **极简面试版**
* 🔹 解释为什么这个结构 **概率是均匀的**
* 🔹 延伸到 **RandomizedCollection（允许重复元素）**

你挑一个，我接着讲。
