# 删除有序数组中的重复项

## 题目

给你一个 非严格递增排列 的数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k`。去重后，返回唯一元素的数量 `k`。

`nums` 的前 `k` 个元素应包含 排序后 的唯一数字。下标 `k - 1` 之后的剩余元素可以忽略。

### 判题标准:

系统会用下面的代码来测试你的题解:
```js
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 通过。

 

 ### 示例 1：

输入：`nums = [1,1,2]`

输出：`2, nums = [1,2,_]`

解释：函数应该返回新的长度 `2` ，并且原数组 `nums` 的前两个元素被修改为 `1`, `2` 。

不需要考虑数组中超出新长度后面的元素。
### 示例 2：

输入：`nums = [0,0,1,1,1,2,2,3,3,4]`

输出：`5, nums = [0,1,2,3,4,_,_,_,_,_]`

解释：函数应该返回新的长度 `5` ， 并且原数组` nums` 的前五个元素被修改为 `0, 1, 2, 3, 4` 。

不需要考虑数组中超出新长度后面的元素。

## Problem Sovling

这是 **LeetCode 26：删除有序数组中的重复项**（简单，但**非常基础**，面试必考）。
你这次要求：**代码注释 + 思路总结 + 结合案例**，我一步一步来。

---

## ✅ 核心思路（一句话先记住）

> **有序数组去重，用快慢指针；
> 慢指针记录“下一个不同元素该放哪”**

---

## ✅ 标准解法：双指针（原地，O(1) 空间）

### 🧠 指针含义

* `i`：**快指针**，负责遍历数组
* `k`：**慢指针**，指向下一个“唯一元素”应该放的位置

---

## ✨ 代码（逐行注释版）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const n = nums.length;
  if (n === 0) return 0;

  let k = 1; // 第一个元素一定是唯一的，直接保留

  // 从第二个元素开始遍历
  for (let i = 1; i < n; i++) {
    // 如果当前元素和前一个不同，说明是新的唯一值
    if (nums[i] !== nums[i - 1]) {
      nums[k] = nums[i]; // 放到唯一区
      k++;
    }
  }

  // k 即为去重后的新长度
  return k;
};
```

---

## 🧪 示例 1 详细推演

### 输入

```js
nums = [1,1,2]
```

### 过程

```txt
初始：
k = 1
nums = [1,1,2]

i=1 → nums[1]=1
nums[1] === nums[0] → 重复 ❌ 跳过

i=2 → nums[2]=2
nums[2] !== nums[1] → 新元素 ✅
nums[1] = 2
k = 2
```

### 结果

```js
返回 k = 2
nums = [1,2,_]
```

---

## 🧪 示例 2 快速理解

### 输入

```js
nums = [0,0,1,1,1,2,2,3,3,4]
```

### 去重过程本质

```txt
每当遇到「和前一个不同」的数，就写到 nums[k]
```

### 结果

```js
返回 k = 5
nums = [0,1,2,3,4,_,_,_,_,_]
```

---

## ❗ 为什么一定能「原地」完成？

* 数组是 **非严格递增（有序）**
* 重复元素 **一定是连续的**
* 所以只需要比较：

  ```js
  nums[i] 和 nums[i - 1]
  ```
* 不需要额外数组

---

## ⏱️ 复杂度分析（面试必说）

* **时间复杂度**：`O(n)`（只遍历一遍）
* **空间复杂度**：`O(1)`（原地修改）

---

## 🧠 一句话模板总结（强烈建议背）

> **有序数组去重：
> 快指针遍历，慢指针收集唯一值**

---

## 🔗 和你刚做的题的关系（帮你串起来）

| 题号 | 题意         | 判断条件                    |
| -- | ---------- | ----------------------- |
| 26 | 每个元素保留 1 次 | `nums[i] !== nums[i-1]` |
| 80 | 每个元素保留 2 次 | `nums[i] !== nums[k-2]` |
| 27 | 删除指定值      | `nums[i] !== val`       |

👉 **本质全是“双指针覆盖写”**

---

如果你愿意，我可以：

* 给你一张 **数组双指针通用模板表**
* 帮你写一段 **30 秒面试讲解话术**
* 或把 **26 / 27 / 80** 三题用一套代码思维串起来

你选一个 👇
