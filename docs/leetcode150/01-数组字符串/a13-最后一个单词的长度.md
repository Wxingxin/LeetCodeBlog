# 最后一个单词的长度
## 题目

给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

 

### 示例 1：

输入：`s = "Hello World"`

输出：`5`

解释：最后一个单词是`“World”`，长度为` 5`。
### 示例 2：

输入：`s = "   fly me   to   the moon  "`

输出：`4`

解释：最后一个单词是`“moon”`，长度为 `4`。
### 示例 3：

输入：`s = "luffy is still joyboy"`

输出：`6`

解释：最后一个单词是长度为 `6` 的`“joyboy”`。

## 

这题是 **LeetCode · 最后一个单词的长度**，属于**字符串基础题**，但有个常见坑：**末尾空格**。

我给你 **最稳妥、面试官最喜欢的写法**，再补两个可选解法。

---

## ✅ 核心思路（从后往前，最优）

1. **从字符串末尾开始**
2. **先跳过所有空格**
3. 遇到字母开始计数
4. 再遇到空格或到头就停

👉 这样不用 `split`，**一次遍历，O(1) 额外空间**

---

## ✅ 标准 JS 解法（推荐）

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
  let i = s.length - 1;
  let count = 0;

  // 1. 跳过末尾空格
  while (i >= 0 && s[i] === ' ') {
    i--;
  }

  // 2. 统计最后一个单词长度
  while (i >= 0 && s[i] !== ' ') {
    count++;
    i--;
  }

  return count;
};
```

---

## 🧠 示例拆解（`"   fly me   to   the moon  "`）

* 从末尾开始 → 跳过 `"  "`
* 遇到 `n o o m` → 计数 4
* 遇到空格 → 停
* 返回 `4`

---

## ⏱️ 复杂度分析

* **时间复杂度**：`O(n)`
* **空间复杂度**：`O(1)`（最优）

---

## 🧩 可选解法一：`trim + split`（简单但不最优）

```js
var lengthOfLastWord = function(s) {
  const arr = s.trim().split(' ');
  return arr[arr.length - 1].length;
};
```

❌ 缺点：

* 用了额外数组
* 面试官一般不首选

---

## 🧩 可选解法二：正则（不推荐面试）

```js
var lengthOfLastWord = function(s) {
  const match = s.match(/([a-zA-Z]+)\s*$/);
  return match ? match[1].length : 0;
};
```

❌ 可读性差，不利于手写

---

## 📌 面试官想听你怎么说？

> “我从字符串末尾开始，先跳过空格，再统计连续字母的长度，一次遍历，不用额外空间。”

这句话说出来，**基本稳过**。

---

## 🧠 一句话总结

> **从后往前，先去空格，再数单词。**

如果你愿意，我可以：

* 给你 **所有字符串题的通用模板**
* 或把这题和 `reverseWords`、`isPalindrome` 串起来讲
* 或直接 **出 3 道同类型面试题给你练**

你选一个 👇
