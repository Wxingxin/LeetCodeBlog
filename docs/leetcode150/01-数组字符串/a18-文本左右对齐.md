# 文本左右对齐

## 题目

给定一个单词数组 `words` 和一个长度 `maxWidth` ，重新排版单词，使其成为每行恰好有 `maxWidth `个字符，且左右两端对齐的文本。

你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 `maxWidth` 个字符。

要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。

文本的最后一行应为左对齐，且单词之间不插入额外的空格。

注意:

单词是指由非空格字符组成的字符序列。

每个单词的长度大于 `0`，小于等于 `maxWidth`。

输入单词数组 `words` 至少包含一个单词。
 

### 示例 1:

输入: `words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16`

输出:
```js
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
```
### 示例 2:

输入:`words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16`

输出:

```js
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
```

解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。

### 示例 3:

输入:`words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"]，maxWidth = 20`

输出:
```js
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
```
## 

```js
/**
 * 68. Text Justification
 * 贪心装行 + 计算空格分配
 * @param {string[]} words
 * @param {number} maxWidth
 * @return {string[]}
 */
var fullJustify = function (words, maxWidth) {
  const res = [];
  let i = 0;

  while (i < words.length) {
    // 1) 贪心：尽可能多塞单词到一行
    let j = i;           // 本行最后一个单词的下一个位置
    let wordsLen = 0;    // 本行所有单词长度之和（不含空格）

    // 试着把 words[j] 放进来
    // 当前已有 (j - i) 个间隔，至少需要 (j - i) 个空格
    while (
      j < words.length &&
      wordsLen + words[j].length + (j - i) <= maxWidth
    ) {
      wordsLen += words[j].length;
      j++;
    }

    const count = j - i;               // 本行单词数
    const isLastLine = j === words.length;

    // 2) 处理最后一行 或 单词数为1：左对齐
    if (isLastLine || count === 1) {
      let line = words[i];
      for (let k = i + 1; k < j; k++) {
        line += " " + words[k];        // 单词之间 1 个空格
      }
      // 右侧补齐空格
      line += " ".repeat(maxWidth - line.length);
      res.push(line);
    } else {
      // 3) 普通行：两端对齐，均匀分配空格
      const gaps = count - 1;          // 间隔数
      const totalSpaces = maxWidth - wordsLen; // 需要塞进去的总空格数

      const base = Math.floor(totalSpaces / gaps); // 每个间隔至少 base 个空格
      const extra = totalSpaces % gaps;            // 左边 extra 个间隔多 1 个空格

      let line = "";
      for (let k = i; k < j; k++) {
        line += words[k];
        if (k < j - 1) {
          // 左侧优先多分配 1 个空格
          const spaces = base + (k - i < extra ? 1 : 0);
          line += " ".repeat(spaces);
        }
      }
      res.push(line);
    }

    // 4) 进入下一行
    i = j;
  }

  return res;
};
```

**核心思路（你上台讲就这几句）：**

* 用贪心把一行能放的单词尽量放满（判断条件：单词总长 + 最少间隔空格 ≤ maxWidth）。
* 如果是最后一行或这一行只有一个单词：左对齐（单词间 1 个空格，末尾补空格）。
* 否则两端对齐：总空格 `maxWidth - 单词总长`，平均分到 `gaps` 个间隔，左边多出来的 `extra` 个间隔各加 1 个空格。
