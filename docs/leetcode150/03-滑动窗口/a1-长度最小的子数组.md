# 长度最小的子数组
## 题目

给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。

找出该数组中满足其总和大于等于 target 的长度最小的 子数组 `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。

 

### 示例 1：

输入：`target = 7, nums = [2,3,1,2,4,3]`

输出：`2`

解释：子数组 `[4,3]` 是该条件下的长度最小的子数组。
### 示例 2：

输入：`target = 4, nums = [1,4,4]`

输出：`1`
### 示例 3：

输入：`target = 11, nums = [1,1,1,1,1,1,1,1]`

输出：`0`

## 

这题是**典型滑动窗口（双指针）**，而且因为 **nums 全是正整数**，这是关键前提 👍
最优解：**O(n) 时间 + O(1) 空间**

---

## 核心思路（滑动窗口）

用一个窗口 `[left, right]` 表示当前子数组：

1. `right` 向右扩展窗口，不断累加 `sum`
2. 一旦 `sum >= target`，说明窗口 **已经满足条件**

   * 更新最小长度
   * 尝试 **收缩左边界**（`left++`），看看能不能更短
3. 重复上述过程，直到遍历完数组

👉 因为数组元素都是 **正数**，窗口右移只会让 `sum` 变大，左移只会让 `sum` 变小，逻辑是单调的，不会回头。

---

## 代码（JS，可直接提交）

```js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(target, nums) {
  let left = 0;
  let sum = 0;
  let minLen = Infinity;

  for (let right = 0; right < nums.length; right++) {
    sum += nums[right]; // 扩大窗口

    // 当窗口和满足条件，尝试收缩
    while (sum >= target) {
      minLen = Math.min(minLen, right - left + 1);
      sum -= nums[left];
      left++;
    }
  }

  return minLen === Infinity ? 0 : minLen;
};
```

---

## 示例 1 过程拆解

```
target = 7
nums = [2,3,1,2,4,3]

right=0 → sum=2
right=1 → sum=5
right=2 → sum=6
right=3 → sum=8 >=7
  → minLen = 4 ([2,3,1,2])
  → 收缩 left：sum=6

right=4 → sum=10 >=7
  → minLen = 3 ([1,2,4])
  → 收缩 left：sum=7
  → minLen = 2 ([4,3]) ✅
```

---

## 为什么不能用前缀和 + 双重循环？

* 可以，但时间复杂度是 **O(n²)** → 会超时
* 滑动窗口利用了「**全是正整数**」这个条件，做到 **一次遍历**

---

## 面试 / LeetCode 一句话总结

> 使用滑动窗口维护一个连续子数组，当窗口内元素和 ≥ target 时不断收缩左边界，更新最小长度，最终得到 O(n) 解法。

---

如果你想进阶，我可以再给你：

* 🚀 **前缀和 + 二分**（O(n log n)）
* ❌ 为什么「有负数」时滑动窗口会失效
* 🧠 对比 `209 / 713 / 904` 滑动窗口题型模板
