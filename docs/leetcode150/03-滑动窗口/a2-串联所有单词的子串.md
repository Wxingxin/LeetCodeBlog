# 串联所有单词的子串
## 题目

给定一个字符串 `s` 和一个字符串数组 `words`。 `words` 中所有字符串 长度相同。

 `s` 中的 串联子串 是指一个包含  `words `中所有字符串以任意顺序排列连接起来的子串。

例如，如果 words = ["ab","cd","ef"]， 那么 "abcdef"， "abefcd"，"cdabef"， "cdefab"，"efabcd"， 和 "efcdab" 都是串联子串。 "acdbef" 不是串联子串，因为他不是任何 words 排列的连接。
返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。

 

### 示例 1：

输入：`s = "barfoothefoobarman", words = ["foo","bar"]`

输出：`[0,9]`

解释：

因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。

子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。

子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
### 示例 2：

输入：`s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]`
输出：`[]`
解释：

因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。

s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。

所以我们返回一个空数组。
### 示例 3：

输入：`s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]`

输出：`[6,9,12]`

解释：

因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。

子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。

子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。

子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。

## code

```js
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  const res = [];
  if (!words || words.length === 0) return res;

  const wordLen = words[0].length;
  const wordCount = words.length;
  const totalLen = wordLen * wordCount;
  if (s.length < totalLen) return res;

  // need: 目标词频
  const need = new Map();
  for (const w of words) need.set(w, (need.get(w) || 0) + 1);

  // 按每个 offset 分组滑动
  for (let offset = 0; offset < wordLen; offset++) {
    let left = offset;              // 窗口左端（字符下标）
    let matched = 0;                // 当前窗口内“有效匹配”的单词数（按次数累计）
    const window = new Map();       // 窗口词频

    // right 每次走一个单词长度
    for (let right = offset; right + wordLen <= s.length; right += wordLen) {
      const w = s.slice(right, right + wordLen);

      // 如果 w 不是目标词：窗口清空，重新开始
      if (!need.has(w)) {
        window.clear();
        matched = 0;
        left = right + wordLen;
        continue;
      }

      // 否则加入窗口
      window.set(w, (window.get(w) || 0) + 1);
      matched++;

      // 如果某个词超频了，就不断从左边吐掉，直到不超
      while (window.get(w) > need.get(w)) {
        const leftWord = s.slice(left, left + wordLen);
        window.set(leftWord, window.get(leftWord) - 1);
        matched--;
        left += wordLen;
      }

      // 如果窗口内刚好有 wordCount 个词，记录答案
      if (matched === wordCount) {
        res.push(left);

        // 继续滑动：吐掉最左边一个词，保持窗口往前走
        const leftWord = s.slice(left, left + wordLen);
        window.set(leftWord, window.get(leftWord) - 1);
        matched--;
        left += wordLen;
      }
    }
  }

  return res;
};
```